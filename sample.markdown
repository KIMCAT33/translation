The Art of Micro Frontends

마이크로 프론트엔드의 예술 








지속적인 도움과 헌신을 해준 가족들에게 감사함을 전합니다. 가족들 없이는 제 삶이 빛나거나 올바른 길을 갈 수 없었을 거에요. 가르침을 주시고 헌신 해주셔서 감사합니다.
- 플로리안 파플 (Florian Rappl)

 
머리말

플로리안 파플을 알고 지낸 지 5년이 지났다. 플로리안은 코딩을 좋아하는 흔하지 않은 아키텍트다. 5년동안 플로리안이 아키텍트로서 리드한 프로젝트를 몇몇 봤고, 마이크로 프론트엔드에 대한 소개 및 해당 기술을 팀원들이 구현할 수 있도록 리드한 프로젝트가 그 중 하나이다. 플로리안은 .NET과 마이크로 프론트엔드 커뮤니티를 리드하는 전세계에 몇 안되는 한명의 전문가다. “마이크로 프론트엔드의 예술” 책에서는 플로리안이 구현 아이디어, 확장성, 조직적인 문제 그리고 보안 문제를 다룰 예정이다. 이 책을 통해서 성공적으로 직접 마이크로 프론트엔드 솔루션을 구축할 수 있을 것이다. **한땀 한땀 직접 구현을 하고 널리 알려진 프레임워크를 사용할 예정이다.** (either from scratch or using one of the established frameworks 해석 잘못된 것 같음)
오랜 기간 동안 많은 큰 규모의 시스템은 모든 기능이 하나의 형태와 밀접하게 연동된 형태인 솔루션인 모놀리식 형태로 개발되었다. 백엔드에는 마이크로 서비스가 모놀리식 기반 솔루션의 단점인 컴포넌트간의 강력한 밀접성, 복잡한 배포 시나리오 또는 하나의 개발팀에서 관리하는 큰 사이즈의 코드를 보안하기 위해 많이 사용되고 있다. 최근에는 마이크로 서비스 아키텍처는 많은 모던 백앤드를 구축할 수 있는 기반이 된다.
최근에 와서야 이런 마이크로 서비스 형태를 프론트엔드 솔루션에 적용 하려고 하는 중이다. 유동적이며 확장 가능한 사용자 인터페이스를 위한 중요 요구 사항은 컴포넌트를 모듈화하는 것이다. 그 중에서도 레이아웃과 사용 가능한 기능이 강력하게 사용자 행동에 결정되거나 마이크로 서비스를 위해 컨테이너화된 프론트엔드를 필요로 하는 경우 사용한다.
기능을 분리하는 것은 모던 모놀리식 프론트엔드 솔루션에서 널리 적용되어 있지만 적절한 기술을 사용할 수 있는 자율성과 더 작은 규모의 팀을 구성을 할 수 있는 조건이 마이크로 프론트엔드 아키텍처에서 마이크로 서비스의 장점을 활용한다는 것을 의미한다. 그 중에서도 동적으로 독립적인 모듈을 불러올 수 있는 기능은 개발, 테스트 그리고 운영환경에서 새로운 기능을 짧고 빠른 릴리스 주기를 가져갈 수 있는 장점을 제공한다. 이러한 장점이 마이크로 프론트엔드가 큰 규모와 복잡한 웹 개발에 좋은 선택지가 될 수 있다.
백엔드 아키텍처의 기본 구성 요소로 마이크로 서비스를 선택하는 경우, 마이크로 프론트엔트를 적용하는 것이 모든 프론트엔드 솔루션에 이상적이거나 최상의 선택지가 아닐 수도 있다. 유저 인터페이스의 기능적인 부분을 격리하거나 분리하여 사용하는 경우 또 다른 개념의 복잡성이 생길 수도 있다. 그러므로 잘 설계되고 모듈화된 모놀리식 웹 애플리케이션이 위와 같은 시나리오에 오히려 가치 있거나 더 좋은 선택지가 될 수 도 있다. 마이크로 프론트엔드 도입 전 장점과 단점을 알아보고 사용할 것을 권장한다. 이를 기반으로 이 책에서는 프론트엔드 아키텍처에 알맞은 옵션을 선택할 수 있는 가이드로 활용할 수 있다.
마이크로 프론트엔드를 활용하여 슈퍼 히어로급의 개발자가 되어 확장 가능한 웹 애플리케이션을 만들어보세요.

Lothar Schottner (로타르 쇼트너) 
Accenture 및 Microsoft의 솔루션 아키텍트 출신 smapiot의 설립자 겸 CEO 
기여자
저자 소개
플로리안 파플은 디지털 프랜스포메이션 및 IoT 분야에서 분산 웹 애플리케이션을 연구하는 솔루션 아키텍트이다. 플로리안의 주된 관심사는 마이크로 프론트엔드의 구현과 이것이 비즈니스 모델에 미치는 영향에 파악하는 것이다. 지난 몇 년간 여러 팀들이 많은 성공적인 프로젝트를 구현하도록 이끌었다.
수석 아키텍트로서 파플은 많은 업계 선두 기업들을 위한 뛰어난 웹 애플리케이션을 구축하는 것을 도왔다. 정기적으로 소프트웨어 디자인 패턴과 웹 개발에 대한 강의도 한다. 플로리안은 수년간 그의 업적으로 여러 상을 수상했으며 개발 기술 분야에서 마이크소프트 MVP로 인정받고 있다.
물리학을 전공하고 에너지 효율적인 슈퍼 컴퓨터를 만드는 것을 돕기 전에 소프트웨어 공학에서 커리어를 시작했다. 플로리안 현재 독일 뮌헨에서 아내와 두 딸과 함께 살고 있다.
 
검토자 소개
라훌 가울 (Rahul Gaur)은 엔터프라이즈 소프트웨어 개발에 열정을 가진 소프트웨어 엔지니어이다. 라훌은 8년 이상의 대규모 복잡한 소프트웨어 애플리케이션 엔지니어링에 대한 성공적인 경험을 가지고 있다. 라훌은 현재 프론트엔드 기술 전문기업인 이노맥서 엔지니어링 이사로 일하고 있다. 라훌은 헬스케어 플랫폼의 첫 번째 버전 출시를 감독했고 이후 2018년 마이크로 프론트엔드 아키텍처로서의 전사적 전환을 감독하여 헬스케어 플랫폼의 성장를 가속화하여 2021년 초에 야심찬 스타트업을 유니콘으로 격상시켰다. 무료 및 오픈 소스 소프트웨어의 강력한 신봉자인 라훌은 정기적으로 여러 오픈 소스 프로젝트에 기여하고 있다.



 
목차
서문	16

섹션 1: “벌집 준비” – 프론트엔드 모듈화 도입	22
1 왜 마이크로 프론트엔드인가?	24
웹 애플리케이션의 발전	24
웹 프로그래밍	25
소셜 웹	26
프론트엔드와 백엔드 분리	28
모든 것이 마이크로화 된다	28
서비스 지향 아키텍처에서 마이크로서비스로	29
마이크로서비스의 장점	30
마이크로서비스의 단점	31
마이크로와 프론트엔드	32
웹 표준의 부상	33
웹 구성 요소를 통한 분리	33
프레임 통신	34
웹 작업자 및 프록시	36
출시 기간 단축(TTM)	37
온보딩(on-boarding) 시간 단축	37
여러 팀	38
기능 격리화	39
A/B 테스팅	40
요약	42
2 일반적인 도전들과 함정들	43
성능	43
리소스 캐싱(caching)	44
번들 사이즈	45
요청 최적화	47
보안	48
중앙 사용자 관리	48
개별 사용자 관리	49
스크립트 실행	50
지식 공유	52
안정성	55
사용자 경험	56
워딩	56
패턴 라이브러리	57
요약	58
3 배포 시나리오	59
중앙 집중적인 배포	60
하나의 레포지토리 사용하기	60
다수의 레포지토리 결합하기	64
분산 배포	67
모노레포 사용하기	68
전용 파이프라인 사용하기	70
하이브리드 솔루션	71
예정된 릴리즈	71
변화에 대한 트리거	72
요약	74
4 도메인 분해	75
도메인 주도 설계의 원리	75
모듈	76
바운디드 컨텍스트	76
컨텍스트 맵	77
전략적 도메인 설계 대 전술적 설계	77
관심사 분리	79
기술적 분할	80
기능적 분할	81
분할 예제	83
아키텍처 경계	87
공유된 기능	87
적절한 자유도 선택	89
DOM 접근	90
마이크로 프론트엔드의 보편성	93
요약	95

섹션 2: “꿀 만들기” – 마이크로 프런트엔드 아키텍처 구현	96
5 마이크로 프론트엔드 아키텍처의 종류	98
기술적인 요구사항	99
마이크로 프론트엔드 환경	99
정적 대 동적 마이크로 프론트엔드	101
수평 대 수직 구성 마이크로 프론트엔드	106
백엔드 대 프론트엔드 주도 마이크로 프론트엔드	108
요약	113
6 웹 접근 방식	114
기술 요구사항	114
웹 접근 방식의 기본 사항	115
아키텍처	115
예제 구현	116
잠재적인 개선 사항	119
장점과 단점	120
링크	120
중앙 연결 디렉토리	121
로컬 연결 디렉토리	122
아이프레임(Iframes)	123
보안	123
접근성	124
레이아웃	124
요약	126
7 서버 사이드 구성	127
기술 요구 사항	128
서버 사이드 구성의 기본	128
아키텍처	129
예제 구현	130
잠재적인 개선 사항	146
장점과 단점	147
Mosaic 9 소개	147
Podium 소개	148
유명한 사용 사례	149
구성 레이아웃 만들기	149
레이아웃 책임 이해	150
SSI 사용	150
ESI 사용	151
JS 템플릿 문자열 사용	152
마이크로 프론트엔드 프로젝트 설정	154
Podlets	154
수명 주기 검토	156
요약	157
8 에지 사이드 구성	158
기술 요구 사항	158
에지 사이드 구성의 기초	159
아키텍처	159
예제 구현	160
잠재적인 개선 사항	165
장점과 단점	166
SSI 및 ESI	170
SSI	170
ESI	171
BFF의 결합하기	174
요약	175
9 클라이언트 사이드 구성	176
기술적인 필요 조건	176
클라이언트 사이드의 기본 구성	177
아키텍처	177
예제 구현	179
잠재적인 개선 사항	185
장점과 단점	185
웹 구성 요소 살펴보기	186
웹 구성 요소 이해	187
Shadow DOM으로 스타일 분리	189
동적으로 마이크로 프론트엔드 구성	190
마이크로 프론트엔드 레지스트리 사용	190
런타임 시 마이크로 프론트엔드 업데이트	192
요약	194
10 SPA 구성	195
기술 요구사항	195
SPA 구성의 기본 사항	195
아키텍처	196
예제 구현	196
잠재적인 개선 사항	202
장점과 단점	202
핵심 SPA 셸 구축	203
페이지 활성화	203
종속성 공유	205
SPA 마이크로 프론트엔드 통합	209
수명 주기 선언	209
프레임워크 간 구성 요소 사용	210
커뮤니케이션 패턴 탐색	212
이벤트 교환	213
데이터 공유	214
확장 구성 요소	214
요약	216
11 사이트리스 UI	217
기술 요구사항	217
사이트리스 UI의 기본 사항	217
아키텍처	218
예제 구현	219
피드 서버	219
앱 쉘	222
잠재적인 개선 사항	227
장점과 단점	228
서버리스와 비교	228
로컬에서 개발	229
모듈 게시	230
런타임 생성하기	231
Piral로 런타임 빌드	231
Piral로 런타임 배포	234
모듈 작성	235
파일렛의 수명 주기	235
프레임워크에 국한되지 않는 구성 요소 구현	237
요약	240

섹션 3: “바쁘게 움직이는 꿀벌들” – 조직 크기 조정	241
12 팀과 관계자 준비하기	243
고위급 이해관계자와의 커뮤니케이션	243
기대치 관리	244
보고용 요약 문서 작성하기	245
프로덕트 오너 및 운영 위원회 처리	246
팀 구성	248
가능한 팀 설정 이해	249
팀 조직 변경	253
요약	254
13 종속성 관리, 거버넌스 및 보안	255
전부를 공유하거나 아예 공유하지 않기	255
변경 관리를 어떻게 하는가?	257
거버넌스 모델 수립	259
마이크로 프론트엔드 샌드박싱하기	261
일반적인 보안 문제 및 개선	263
요약	268
14 UX 와 스크린 디자인의 영향	269
항상 한 개를 추가하기	269
0에서 시작하는 법 배우기	274
효율적으로 디자인 공유하기	275
디자이너 없이 디자인 만들기	278
요약	279
15 개발자 경험	280
최소한의 개발자 경험 제공	280
표준 IDE에서 개발 지원	280
스케폴딩 경험 개선	281
적절한 개발자 경험 구축	283
코드 문서 중앙 집중화	283
동영상으로 문서화	285
코드 분석 지원	285
테스트 가능성 향상	286
최고의 개발자 경험 달성	287
오류 코드 통합	287
오프라인 우선 개발 환경 제공	288
브라우저 확장을 통한 사용자 정의	290
개발자 포털 구현	291
요약	293
16 사례 연구	294
사용자 대면 포털 솔루션	294
문제 설명	294
팀 설정	295
솔루션	295
영향	297
관리 포털 솔루션	298
문제 설명	299
팀 설정	299
솔루션	299
영향	302
의료 관리 솔루션	304
문제 설명	304
팀 설정	304
솔루션	305
영향	307
요약	309
에필로그	309




 



 
서문 
마이크로 프론트엔드의 패턴은 소프트웨어 개발의 마이크로 서비스 아이디어에서 차용된 프론트엔드 개발을 위한 웹 아키텍처이다. 프론트엔드의 각 모듈은 복잡성과 프론트엔드의 단일 장애 지점을 피하기 위해 별도로 개발 및 배포된다.
대상 독자 
이 책은 솔루션 아키텍트, 소프트웨어 아키텍트, 개발자 및 프론트엔드 엔지니어를 대상으로 집필되었다. NPM이 포함된 Node.js를 포함하여 자바스크립트와 그 생태계에 대한 충분한 지식을 갖춘 HTML 및 CSS에 대한 기본적인 프론트엔드 지식을 기본 가정으로 한다.
이 책에 대해 
제 1장 “왜 마이크로 프론트엔드인가?” 에서는 일반적으로 마이크로 프론트엔드, 주요 사용 영역 및 마이크로 프론트엔드가 가져오는 어려움과 문제에 대해 설명한다. 여기에는 이러한 문제와 과제를 완화하는 데 사용할 수 있는 전략이 포함되어 있다. 
제 2장 “일반적인 과제 및 함정” 에서는 마이크로 프론트엔드를 구현할 때 가장 중요한 과제와 함정에 대해 설명하고 적절한 솔루션으로 이어지는 경로를 설명한다.
제 3장 “배치 시나리오” 에서는 배치와 관련하여 마이크로 프론트엔드의 확장성에 대해 살펴볼 것이다. 여기에는 CI/CD 파이프라인의 예시와 이상적인 사용 사례가 포함된다.
제 4장 “도메인 분해” 에서는 마이크로 프론트엔드에 무엇을 배치해야 하는지를 결정할 때 사용할 수 있는 사고방식이 드러난다. 이 장에서는 도메인 중심 설계의 방법을 사용하여 이러한 결정을 내리는 방법을 소개한다.
제 5장 “마이크로 프론트엔드 아키텍처의 유형” 에서는 가장 인기 있는 패턴을 포함하여 마이크로 프론트엔드 아키텍처를 생성하기 위한 단계 공간을 소개한다. 이 장에서는 각 단계의 장점과 단점을 설명한다.
제 6장 “웹 접근” 에서는 iframe과 링크와 같은 기존의 웹 기술을 활용하여 마이크로 프론트엔드를 다루는 가장 간단한 접근법에 대해 논한다.
제 7장 “서버측 구성” 에서는 서로 다른 서버에서 온 프론트엔드 조각을 단일 웹 사이트로 결합하는 일반적인 백엔드 방법에 대해 설명한다.
제 8장 “엣지 사이드 구성” 에서는 역방향 프록시 설정을 사용하여 엣지에 웹 사이트를 구성하기 위해 서버 측 구성보다 훨씬 더 단순화된 접근 방식을 취한다.
제 9장 “클라이언트측 구성” 에서는 웹 구성요소를 활용하여 사용자의 브라우저에서 서로 다른 조각으로 하나의 웹 사이트를 구성하는 방법을 보여준다.
제 10장 “SPA 구성” 에서는 사용자의 브라우저 내에 구성된 공동 솔루션으로 서로 다른 SPA 웹 사이트를 통합하는 방법에 대해 설명한다.
제 11장 “Siteless UI” 에서는 서버리스 기능의 인기 속성을 프론트엔드로 가져오는 마이크로 프론트엔드 패턴을 소개한다. 
제 12장 “팀 및 이해관계자 준비” 에서는 마이크로 프론트엔드를 도입할 때 필요한 조직 변화를 다룬다.
제 13장 “의존성 관리, 거버넌스 및 보안” 에서는 모든 종류의 프로젝트에 대한 의존성 공유 및 일반적인 마이크로 프론트엔드 거버넌스에 대한 지침을 제공한다. 이 장에서는 배포에서 런타임에 이르는 보안에 대해서도 설명한다.
제 14장 “UX 및 화면 설계에 미치는 영향” 에서는 실질적으로 무제한 확장성이 있는 마이크로 프론트엔드 솔루션에 대한 설계를 작성할 때 처리해야 할 가장 중요한 측면을 소개한다.
제 15장 “개발자 경험” 에서는 프로젝트의 내부 또는 외부 개발자를 만족시키기 위해 포함해야 할 가장 중요한 속성을 나열하고 이것이 높은 수준의 생산성을 유지하는 데 매우 중요하다는 걸 보여준다.
제 16장 “사례 연구” 에서는 세 가지 실제 마이크로 프론트엔드 프로젝트와 그 배경, 핵심 결정 및 사용된 전반적인 아키텍처가 나열되어 있다.
이 책의 활용 방안 
이 책의 모든 예제는 단순함을 염두에 두고 만들어졌다. 예제들은 모두 비슷하게 동작하며 HTML과 CSS를 사용하는 자바스크립트와 같은 핵심 프론트엔드 기술에 대한 지식만 필요로 한다. 코드 실행을 위한 툴링은 Node.js를 기반으로 가장 널리 사용되는 프론트엔드 툴체인을 사용한다. 

책에서 다루는 소프트웨어/하드웨어	OS 요구사항
Node.js 12+	Windows, macOS, and Linux (any)
NPM 6+	Git
ECMAScript 2015 (6)+	


제 8장 “엣지 사이드 구성” 의 코드는 도커를 실행해야 한다. 다른 방안으로는 제공된 Docker 파일을 실행하는 것보다 휠씬 더 복잡할 지라도 로컬 nginx 서버를 설치하면 된다.
이 책의 디지털 버전을 사용하는 경우 코드를 직접 입력하거나 GitHub 저장소 (다음 섹션에 있는 링크)를 통해 액세스하면 된다. 이렇게 하면 코드 복사 및 붙여넣기와 관련된 잠재적인 오류를 방지할 수 있다.
예제 코드 파일 다운로드 
이 책의 예제 코드 파일은 www.packt.com의 계정에서 다운로드할 수 있다. 이 책을 다른 곳에서 구입한 경우 www,packpub.com/support 를 통해서 계정 생성을 한 뒤 등록된 이메일로 직접 파일을 받을 수 있다.
다음 단계를 수행하여 코드 파일을 다운로드할 수 있다:
1.	www.packt.com에 로그인하거나 계정 생성하기
2.	Support (지원) 탭을 선택하기
3.	Code Downloads (코드 다운로드)를 클릭하기
4.	Search (검색) 박스에 책 이름을 입력하고 화면의 지침을 따른다. 
파일이 다운로드되면 다음의 최신 버전을 사용하여 폴더의 압축을 풀거나 폴더를 열어 접근한다:
•	WinRAR/7-Zip for Windows 
•	Zipeg/iZip/UnRarX for Mac 
•	7-Zip/PeaZip for Linux 
이 책의 코드 번들은 GitHub, https://github.com/ PacktPublishing/The-Art-of-Micro-Frontends에서 호스팅된다. 코드 업데이트가 있을 경우 기존 GitHub 저장소에서 업데이트가 된다.
또한 https://github.com/PacktPublishing/ 에서 제공되는 풍부한 책 및 비디오 카탈로그의 다른 코드 번들도 있다. 페이지로 들어가서 확인해보세요.
예제 코드 영상 
이 책의 라이브 코딩 영상은 https://bit.ly/3cbhbL7 에서 확인할 수 있다.
컬러 이미지 다운로드 

또한 이 책에서 사용된 스크린샷/다이어그램의 컬러 이미지가 있는 PDF 파일을 제공한다. https://static.packt-cdn.com/ downloads/9781800563568_ColorImages.pdf 에서 다운로드할 수 있다.
편집 서식 
이 책에는 여러 형태의 편집 서식을 따르고 있다. 
텍스트 형태 코드: 텍스트, 데이터베이스 테이블 이름, 폴더 이름, 파일 이름, 파일 확장명, 경로 이름, 더미 URL, 사용자 입력 및 Twitter 핸들러등이 텍스트 형태 코드로 표시된다. 예를 들어 “URL에서 직접 fragment-1.html를 요청하는 대신 동일한 CDN에서 요청하여 ESI 지시문이 포함되지 않은 사전 평가 버전을 만든다.”
코드 블록은 다음과 같이 설정된다: 

// index.html (original) 
<esi:include src=”http://example.com/fragment1.html” /> 

// fragment1.html 
<esi:include src=”http://example.com/fragment2.html” /> 

// fragment2.html 
<div>... 
명령어 입력 또는 출력은 다음과 같이 작성된다:
npm run build 
npm pack 

볼드체: 화면에 표시되는 새 용어 또는 중요한 단어를 나타낸다. 예를 들어 메뉴나 대화 상자의 텍스트에 다음과 같이 표시된다. 예를 들어, “헤더의 My messages 버튼은 messages micro frontend에서 가져온 것이다.”
팁 또는 중요 참고 사항 
위와 같이 표시된다. 
피드백 
독자들의 피드백은 언제나 환영합니다. 
일반적인 피드백: 이 책에 대해 특정 부분에 대한 궁금한 점이 있다면 해당 부분의 제목을 언급하고 customercare@packtpub.com로 이메일을 보내면 된다. 
오탈자/오류: 컨텐츠의 정확성을 보장하기 위해서 모든 주의를 기울였지만, 오탈자 또는 오류가 있을 수 있다. 이 책에서 틀린 부분이 있으면 저희에게 보고해주시면 감사하겠습니다. www.packtpub.com/support/errata 에 방문하여 책을 선택하고 Errata (오류) 제출 양식 링크를 클릭한 다음 세부 정보를 입력하면 된다.
불법 복제: 인터넷에서 어떤 형태로든 해당 책의 불법 복제품을 발견하신다면 저희에게 위치 주소나 웹사이트 이름을 알려주시면 감사하겠습니다. 자료 링크와 함께 copyright@packt.com으로 연락해주세요.
책 출판에 관심이 있는 경우: 전문 지식을 가지고 있고 글을 쓰거나 책 출판에 관심이 있다면 authors.packtpub.com를 방문해주세요.
의견 공유 
“마이크로 프론트엔드의 예술”를 읽고난 여러분의 생각을 듣고 싶습니다! 이 책에 대한 의견을 https://packt.link/r/1800563566 여기에 자유롭게 공유해주세요.
여러분의 리뷰는 NAT와 기술 커뮤니티에 중요하며 우수한 품질의 컨텐츠를 제공하는 데 도움이 될 것입니다.

 
섹션 1: “벌집 준비” – 프론트엔드 모듈화 도입
이 섹션에서 독자는 마이크로 프론트엔드와 주요 애플리케이션에 대해 더 깊이 이해할 뿐만 아니라 이를 잘 활용하기 위한 다양한 과제와 전략을 이해하게 될 것이다.

이 섹션에서 다룰 내용은 다음과 같습니다.
•	제 1장, 왜 마이크로 프론트엔드인가?
•	제 2장, 일반적인 도전들과 함정들
•	제 3장, 배포 시나리오
•	제 4장, 도메인 분해

 
 
1 왜 마이크로 프론트엔드인가?
모든 여정은 어딘가에서 시작한다. 우리는 종종 특정 문제의 해답을 찾을 것이다. 문제를 심층적으로 파악하는 것이 일반적인 솔루션의 일부이다. 다양한 문제에 대한 자세한 이해 없이는 문제 해결을 위한 적절한 방법을 찾는 것은 불가능에 가깝다. 
약 30년간의 웹 개발 역사를 통해 우리는 무엇이든 가능한 지경에 도달했다. 기존 데스크탑 애플리케이션, 모바일 네이티브 애플리케이션 및 웹 사이트 간의 경계는 허물어졌다. 오늘날 많은 웹사이트는 실제로 웹 애플리케이션이며 도구와 같은 특성을 제공한다.
따라서 개발자는 매우 어려운 상황에 처해있다. 코드 기반의 근본적인 복잡성을 처리하는 인지 부하가 너무 높은 경우가 많다. 결과적으로 효율을 떨어트리고 많은 버그 마주하게 된다.
해당 딜레마에서 벗어날 수 있는 한가지 방법은 마이크로 프론트엔드(Mircro Frontend)의 아키텍처 패턴이다. 이번 장에서는 마이크로 프론트엔드가 다양한 종류의 프로젝트에서 매우 인기 있는 선택이 된 이유에 대해서 알아본다.
이번 장에서는 다음 주요 주제를 다룬다:
	웹 애플리케이션의 발전
	모든 것의 마이크로화
	웹 표준의 부상
	출시 기간 단축 (TTM)
거두절미하고 바로 본론으로 들어가보자.

웹 애플리케이션의 발전
마이크로 프론트엔드를 사용해야 하는 이유를 알아보기 전에 마이크로 프론트엔드가 등장하게 된 이유를 살펴봐야 한다. 웹은 어떻게 유럽 입자 물리학 연구소(Conseil Europeen pours la Recherche Nucleaire/The European Organization for Nuclear Research(CERN))의 작은 사무실에 있는 NeXT 컴퓨터에서 실행되는 작은 개념 증명 (POC)에서 진화하여 정보화 시대의 중심이 되었을까?
웹 프로그래밍
필자가 웹 개발을 처음 접한 것은 1990년대 중반이었다. 당시 웹은 대부분 정적 웹 페이지로 구성되어 있었다. 그림 1.1과 같이 공통 게이트웨이 인터페이스(Common Gateway Interface, CGI) 기술을 사용하여 일부 동적 웹 사이트를 가져올 수 있는 충분한 경험이 있는 사람들도 있었지만, 대부분의 웹 마스터는 이 사실을 알지 못했거나 서버 사이드 렌더링(Server-side Rendering, SSR)에 비용을 지출했다. 웹마스터라는 용어는 웹사이트를 담당하는 사람에게 흔히 사용되었다. 이것 대신 모든 것이 수작업으로 만들어 졌다.
 
그림 1.1 – 정적에서 동적 웹 페이지로 변화
중복이나 불일치의 가능성을 방지하기 위해 새로운 기술인 <frameset> 태그에 선언된 프레임이 사용되었다. 프레임을 사용하여 웹 사이트 내에 웹 사이트를 표시한다. 메뉴, 머리글 또는 바닥글과 같은 항목을 다른 페이지에 효과적으로 재사용이 가능하다. HTML5(HyperText Markup Language 5) 규격에서 프레임은 없어졌지만 아직 모든 브라우저에서 프레임을 사용할 수 있다. 프레임의 명맥을 잇는 다음 세대 기술인 인라인 프레임(iframe) <iframe> 태그는 오늘날에도 살아있다. 
프레임의 단점 중 하나는 링크 처리가 점점 어려워졌다는 것이다. 최상의 성능을 얻기 위해 올바른 대상을 명시적으로 선택해야 했다. 또한 파일식별기(Uniform Resource Locator, URL)의 올바른 처리가 필요했다. 탐색은 주어진 프레임에서만 수행됐기 때문에 표시된 페이지 주소는 변경되지 않았다.
결과적으로 다른 대안을 필요했다. 한 가지 방법은 모든 복잡성을 고려하지 않고 SSR을 사용하는 것이었다. 서버 지시사항을 포함하는 플레이스 홀더(placeholder)로 특수 HTML 주석을 도입하면 동적으로 해결되는 일반 레이아웃이 추가될 수 있었다. 해당 기술의 이름은 일반적으로 SSI로 알려진 Server Side Include이다.
아파치 웹 서버는 mod_ssi 모듈을 통해 SSI 지원을 최초로 도입한 서버 중 하나였다. 마이크로소프트의 인터넷 정보 서비스(Internet Information Services, IIS)와 같은 다른 인기 웹 서버들도 그 후 빠르게 따라왔다. SSI는 점진적인 특징과 허용된 명령어의 튜링 완전성(Turing completeness)으로 성공했다.
그 시점에서 웹사이트는 점점 더 동적으로 변했다. CGI를 활용하기 위해 많은 솔루션이 구현되었다. 그러나 PHP(Hypertext Preprocessor)라는 새로운 프로그래밍 언어가 도입되었을 때 SSR이 주류가 됐다. PHP를 실행하는 비용이 너무 저렴해서 SSI는 거의 잊혀졌다.

소셜 웹
Web 2.0의 등장과 JavaScript의 기능, 특히 AJAX(Asynchronous JavaScript and XML)로 알려진 런타임 시 동적 데이터 로딩을 위한 기능으로 웹 커뮤니티는 또 다른 문제에 직면했다. SSR은 더 이상 모든 문제의 해결책이 아니었다. 대신 웹 사이트의 동적인 부분은 적어도 부분적으로 클라이언트에 있어야 했다. 테스트 및 개발과 함께 애플리케이션을 여러 영역(빌드, 서버, 클라이언트)으로 나누는 복잡성이 급증했다.
결과적으로 클라이언트 사이드 렌더링(client-side rendering, CSR)을 위한 프레임워크가 등장했다. Backbone.js, Knockout.js 및 AngularJS와 같은 1세대 프레임워크는 모두 SSR에서 널리 사용되는 프레임워크와 유사한 아키텍처 옵션을 제공했다. 해당 프레임워크는 전체 애플리케이션을 클라이언트에 배치할 의도가 없었고 무기한 확장할 의도도 없었다.
실제로 이것은 의도한 것과 다르게 작동했다. 애플리케이션 크기가 증가하고 현재 사용자가 사용하도록 의도되지 않은 많은 코드가 클라이언트에 제공되었다. 이미지와 다른 미디어는 최적화 없이 제공되었고 웹은 점점 느려졌다. 
물론, 이런 문제를 해결하기 위한 도구도 만들어졌다. 자바스크립트 축소화(Javascript minification)는 자바스크립트(Javascript)만큼 오래되었지만 이미지 최적화 및 CSS(Cascading Style Sheets) 축소를 위한 다른 도구들도 이러한 상황을 개선하기 위해 등장했다.
누락된 링크는 이러한 도구를 단일 파이프라인으로 결합하는 것이었다. Node.js 덕분에 웹 커뮤니티는 정말 훌륭한 혜택을 받았다. JavaScript를 서버 측으로 가져올 수 있을 뿐만 아니라 크로스 플랫폼 도구를 사용할 수 있는 런타임이 생겼다. Grunt 또는 Gulp와 같은 새로운 작업 실행자는 프론트엔드 코드를 효율적으로 개발하기 쉽게 만들기 시작했다.

웹 2.0의 전환은 다음 그림과 같이 브라우저에서 실행되는 UI에서 직접 웹 서비스를 재사용할 수 있게 되었다. 
 
그림 1.2 – Web 2.0의 움직임과 함께 보편화된 아키텍쳐가 된 서비스와 AJAX

전용 백엔드 서비스를 활용하는 것은 여러 사용 사례에 적합하다. 첫째, 그림 1.2에 설명하는 것처럼 프론트엔드에서 AJAX를 활용하여 부분적으로 다시 로드할 수 있다. 또 다른 사용 사례는 다른 시스템도 정보에 액세스할 수 있도록 하는 것이다. 이렇게 하면 유용한 데이터를 수익화할 수 있다. 마지막으로 표현(일반적으로 HTML을 사용하는 것)과 구조(XML(Extensible Markup Language) 또는 JSON(JavaScript Object Notation)과 같은 형식 사용하는 것)를 구분하면 여러 애플리케이션에서 재사용할 수 있다.

프론트엔드와 백엔드 분리
프론트엔드의 향상된 렌더링 기능은 백엔드와 프론트엔드 간의 분리도 가속화했다. 갑자기 하나의 코드 기반에서 사용자 활동, 페이지 생성 및 데이터베이스 쿼리를 처리하는 거대한 모놀리식(monolith) 방식이 사라졌다. 대신, 데이터 처리는 SSR 시나리오에서 페이지 생성에 사용되거나 사용자의 브라우저에서 실행되는 코드에서 직접 사용할 수 있는 API(애플리케이션 프로그래밍 인터페이스) 계층에 배치됐다. 특히 클라이언트의 모든 렌더링을 처리하는 애플리케이션은 단일 페이지 애플리케이션(single-page application, SPA)라고 불리게 됐다. 
이러한 분리는 이점을 가져왔을 뿐만 아니라 API의 디자인 자체가 고도화됐다. 그러나 적절한 보안 설정을 제공하고 우수한 성능 기준을 설정하는 것이 더 어려워졌다. 결국 이는 배포 관점에서도 문제가 되었다.
사용자 경험의 관점에서 부분 페이지 업데이트를 수행하는 기능도 문제가 없는 것은 아니다. 여기서는 사용자에게 올바른 신호를 전송하기 위해 스피너 로드, 스켈레톤 스타일 또는 기타 방법과 같은 시그널에 의존한다. 처리해야 할 또 다른 사항은 올바른 오류 처리이다. 다시 시도 해야할지? 사용자에게 알려야 할 지? 폴백을 해야할 지? 여러 가지 가능성이 있지만 여기서 올바른 결정을 내리는 것 외에도 구현하고 테스트하는 데 시간을 할애해야 한다.
그럼에도 불구하고 많은 애플리케이션의 경우 단독적으로 프론트엔드와 백엔드 부분으로 분할하는 것이 확실히 적합한 선택이다. 한 가지 이유는 전담팀이 양쪽에서 모두 작업할 수 있기 때문에 더 큰 웹 애플리케이션을 보다 효율적으로 개발할 수 있기 때문이다.
앞으로 보게 될 개발 효율성의 향상은 마이크로 프론트엔드로의 전환의 원동력이다. 웹 개발에서 모듈화가 어떻게 시작되었는지 살펴봅시다.

모든 것이 마이크로화 된다
애플리케이션의 프론트엔드와 백엔드를 독립적으로 분할하는 것이 매우 유용할 수 있다는 것을 이미 확인했다. 백엔드 관점에서 오케스트레이션되고 함께 결합되어야 하는 소규모 서비스인 마이크로서비스가 부상하는 것을 봤다.

서비스 지향 아키텍처에서 마이크로서비스로
서비스 지향 아키텍처(service-oriented architecture, SOA)에 대한 아이디어는 새로운 것이 아니지만, 마이크로서비스 등장은 여러 옵션을 제공해주었다. 2000년대 초반에 SOA라는 용어가 도입되어 이미 이를 시도해보았다. 그러나 SOA의 경우, 다양한 요구사항과 제약 사항이 있었다. 통신 프로토콜부터 API 검색까지 사용량이 많은 애플리케이션까지 모든 것이 미리 결정되었거나 최소한 강력하게 권장되었다. 
SOA의 궁극적인 실패로 커뮤니티는 많은 서비스를 너무 빨리 구축하지 않으려고 노력했다. 결국, 이는 SOA에 의해 야기된 제약 뿐만 아니라 잠재적인 상호의존성을 가진 여러 서비스를 배치하기 위한 과정이었다. 어떻게 하면 두세 개의 환경에 여러 서비스를 안정적으로 배포할 수 있을까?
도커(Docker)가 도입됐을 때 몇 가지 문제를 해결했다. 가장 중요하게도 도커는 배포가 올바르게 작동하도록 안정적으로 수행할 수 있는 방법을 제공했다. 앤서블(Ansible)과 같은 도구와 결합하여 여러 서비스를 출시하는 것이 실현 가능하고 개선 가능성이 있어 보였다. 결과적으로 전 세계의 여러 팀들이 기존의 경계를 허물기 시작했다. 그런 다음 이러한 팀에서 사용하는 일반적인 디자인 패턴을 사용하여 마이크로 서비스라고 하는 일반적인 아키텍처 스타일을 형성하게 된다.
마이크로 서비스를 사용할 때는 단 하나의 권장 사항, 즉 한 가지를 담당하는 서비스를 구축해야 한다. 통신 방법(일반적으로 JSON과의 REST(REpresentational State Transfer))은 결정되지 않았다. 서비스에 자체 데이터베이스가 있어야 하는지 여부는 개발자에게 맡겨졌다. 서비스가 서로 직접 또는 간접적으로 의사소통해야 하는 경우, 설계자가 이를 결정할 수 있다. 궁극적으로 여러 상황에 대한 모범 사례가 등장하며 마이크로 서비스의 성공이 더욱 확고해졌다.
일부 순수론자들은 마이크로 서비스를 "세밀한 SOA"로 보지만 대부분의 사람들은 단일 책임 원칙(single-responsibility principle, SRP)만을 자유롭게 선택하여 사용할 수 있는 옵션으로 여겨진다. 다음 그림은 SPA를 기반으로 마이크로 서비스를 사용하는 웹 애플리케이션을 보여준다.
 
그림 1.3 – SPA와 MSA를 사용한 현재 최신의 웹 애플리케이션

마이크로 서비스는 백엔드 구축에 초점이 맞춰져 있기 때문에 프론트엔드 역시 이러한 동적 접근 방식을 따라야 했다. 결과적으로 많은 애플리케이션이 자바스크립트를 기반으로 구축되어 SPA를 활용하여 SSR와 CSR을 모두 정의해야 하는 복잡성을 처리할 필요가 없다. 이는 그림 1.3에도 나타나 있다.

마이크로서비스의 장점
마이크로 프론트엔드 관련 책이 마이크로서비스의 역사나 잠재적인 이점을 살펴보는 데 시간을 할애해야 하는 이유는 무엇일까? 우선 둘 다 마이크로로 시작한다. 우연의 일치일 수 있지만 실제로는 그게 아니다. 또 다른 이유는 앞으로 살펴보겠지만 두 아키텍처의 배경과 역사가 실제로 매우 유사하기 때문이다. 마이크로서비스는 마이크로 프론트엔드보다 오래됐기 때문에 미래에 대한 전망을 보는 데 사용될 수 있고 디자인 의사 결정을 내릴 때도 도움이 된다. 
마이크로서비스가 어떻게 오늘날 백엔드를 수행하는 실질적인 표준이 됐을까? 물론 좋은 모놀리식 방식은 여전히 많은 프로젝트에 적합한 선택이지만 일반적으로 "대중적인 선택"이 아니다. 대부분의 대규모 프로젝트는 평가 또는 기타 제약 조건과 관계없이 즉시 마이크로서비스 방식으로 정한다.
마이크로서비스는 명백한 인기 외에도 다음과 같은 몇 가지 내재적 이점을 제공한다.
	장애는 단일 서비스와 직접적으로 관련이 있다.
	여러 팀이 독립적으로 작업할 수 있다.
	배포 규모가 작다.
	프레임워크와 프로그래밍 언어를 자유롭게 선택할 수 있다.
	초기 출시 시간이 더 짧다.
	아키텍처 경계가 뚜렷하다.
마이크로 서비스를 선택하는 모든 프로젝트는 위 목록에서 하나 이상의 이점을 얻기를 바라지만 단점도 존재한다. 

마이크로서비스의 단점
동전에 양면이 있듯 모든 장점에는 단점도 있다. 정말 중요한 것은 우리의 관점과 어디에 초점을 맞추냐는 것이다. 예를 들어 오류가 단일 서비스에만 관련된 경우 디버깅에 대한 복잡성이 증가한다. 방금 장애가 발생한 다른 서비스에 의존하는 서비스는 이상하게 동작할 것이다. 서비스 장애가 발생한 근본 원인을 찾고 이 상황을 완화하는 방법을 찾는 것이 점점 더 어려워진다.
그럼에도 불구하고 마이크로서비스라면 단점보다 장점에 더 초점을 맞추어야 한다. 단점을 안고 살 수 없다면 다른 패턴을 찾거나 문제가 되는 단점이 가능한 한 사라지도록 최선의 방향을 찾아야한다.
장점이 단점으로 이어질 수 있는 또 다른 예는 프레임워크 및 프로그래밍 언어에 관한 자율성이다. 개발자 수에 따라 지원할 수 있는 언어의 수가 정해져 있다. 그 수를 초과하게 되면 유지관리가 어려워진다. 새로운 언어와 프레임워크를 사용하는 것은 확실히 세련되다. 그러나 세련된 언어로 작성된 새로운 서비스를 유지할 수 있는 사람이 아무도 없다면 개발을 확장하는 데 어려움을 겪을 것이다.
많이 알려진 단점은 다음과 같다.
	오케스트레이션 복잡성 증가
	다중 장애 지점
	디버깅 및 테스트가 더 어려워짐
	책임감 부족
	서로 다른 서비스 간의 결과적 비일관성
	버전 관리 어려움
위 목록을 보고 처음에는 겁먹을 수 있지만 이미 모범 사례와 향상된 도구를 통해 이러한 문제들이 해결됐다. 결국 상황을 최대한 활용하고 현명하게 선택하는 것이 우리의 목표이다.

마이크로와 프론트엔드
마이크로서비스는 효과적이고 다음 단계로 프론트엔드에 그 원리를 적용하는 것이 분명해 보인다. 가장 쉬운 해결책은 JSON 대신 HTML을 제공하는 마이크로 서비스를 구현하는 것이다. 생각보다 간단할까? 그렇지 만만하지 않다.
HTML만 조합하는 것은 그리 어렵지 않겠지만 그것보다 더 큰 개념에서 생각할 필요가 있다. 자바스크립트, CSS 및 이미지 파일과 같은 에셋(asset)이 필요하다. 자바스크립트 콘텐츠를 서로 인접하지 않게 배열하려면 어떻게 해야 할까? 전역 변수가 같은 이름으로 설정되면 어떤 변수가 선택될까? 모든 파일의 URL이 해당 파일을 서비스하는 개별 서비스로 확인되어야 할까?
답변보다 더 많은 질문이 있지만 한 가지 확실한 점은 이론 상 그렇게 하는 것이 가능하지만 실제로는 제한되고 백엔드와 프론트엔드 간의 분리를 할 수 없게 된다. 이는 오늘날 웹 개발의 사고방식에 있어 근본적인 요소이기도 하다.
따라서 마이크로 프론트엔드는 이러한 장벽 중 일부가 깨질 수 있는 요소가 최근까지 존재하지 않았다. 앞으로 보게 되겠지만 마이크로 프론트엔드 솔루션을 구축하는 방법은 여러 가지가 있다. 마이크로서비스와 마찬가지로 고정된 제약조건은 없다. 결국, 프로젝트를 독립적인 팀이 메인 애플리케이션을 업데이트하지 않고도 프론트엔드의 작은 형태로 자유롭게 배포할 수 있을 때 마이크로 프론트엔드를 사용한다.
일부 기술적 이유 외에도 마이크로 프론트엔드가 마이크로서비스보다 늦게 구축된 또 다른 이유도 있다. 마이크로 프론트엔드가 전에는 필요하지 않았다.
앞서 설명된 대로 웹은 최근 프론트엔드 코드 단에서 폭발적으로 증가하고 있다. 이전에는 균일한 사용자 경험이 없는 구분된 페이지나 모놀리식 방식으로 충분했다. 애플리케이션의 규모가 엄청나게 커지면서 마이크로 프론트엔드가 활용되고 있다.
SSI 또는 전용 로직과 같은 서버 사이드 솔루션은 마이크로 프론트엔드 솔루션을 구축하는 데 상당한 도움이 될 수 있지만 이러한 동적 구성을 클라이언트에 제공하는 것은 어떨까? 밝혀진 바와 같이 새로운 웹 표준이 이것을 가능하게 한다.

웹 표준의 부상
클라이언트에서 실행되는 마이크로 프론트엔드를 개발하는 데 몇 가지 문제가 있다. 다른 고려사항 중에서 코드 충돌을 피하기 위해 코드를 최대한 분리할 수 있어야 한다. 그러나 백엔드 마이크로서비스와 달리 런타임 프레임워크와 같은 리소스를 공유할 수도 있다. 그렇지 않으면 사용자 컴퓨터에서 사용 가능한 리소스가 고갈될 수 있다.
처음에는 이 말이 이상하게 들릴 수 있지만 성능은 마이크로 프론트엔드의 큰 과제 중 하나이다. 백엔드에서는 모든 서비스에 적절한 양의 하드웨어를 제공할 수 있다. 프론트엔드에서는 사용자가 사용하는 기기에서 코드를 브라우저를 통해 실행되어야 한다. 즉 큰 데스크탑일 수도 있고 라즈베리 파이나 스마트폰일 수도 있다.
최근 웹 표준에 상당히 도움이 되는 영역 중 하나는 스타일 분리(Style Isolation)이다. 스타일을 분리하지 않으면 돔(Document Object Model, DOM)이 모든 스타일을 전역으로 처리하여 충돌로 인해 실수로 스타일을 누출하거나 덮어쓰게 된다.

웹 구성 요소를 통한 분리
스타일은 섀도 돔(shadow DOM)의 기술을 사용하여 분리할 수 있다. 섀도 돔을 사용하면 상위 돔의 일부가 되지 않고도 상위 돔에 투영된 구성 요소를 쓸 수 있습니다. 대신 캐리어 요소(호스트라고 함)만 직접 마운트된다. 상위 스타일 규칙이 섀도 돔으로 누출되지 않을 뿐만 아니라 일반적으로 스타일 정의도 적용되지 않는다.
결과적으로 섀도 돔을 사용하려면 상위 스타일 시트를 다시 불러와야 한다. 따라서 섀도 돔에서 스타일링에 대해 완전한 자율성을 원할 경우에만 이러한 분리가 가능하다. 
자바스크립트 파트에는 동일한 분리가 적용되지 않는다. 전역 변수를 통해 상위 스크립트에 액세스할 수 있다. 여기에서 웹 구성요소 표준의 또 다른 단점이 보인다. 일반적으로 섀도 돔의 정의를 전송하는 방법은 사용자 정의 요소를 사용하는 것이다. 그러나 사용자 정의 요소에는 재정의할 수 없는 고유한 이름이 필요하다.
많은 자바스크립트 단점을 해결하는 방법은 언급된 <iframe> 요소로 대체하는 것이다. iframe은 스타일과 스크립트 분리와 함께 제공되지만 상위 프레임과 프레임에 있는 콘텐츠 간에는 어떻게 통신할 수 있을까?

프레임 통신
원래 HTML5에서 소개된 window.postMessage 함수는 마이크로 프론트엔드에서 상당히 유용하다고 입증됐다. 이는 재사용 가능한 프론트엔드 일부에 이미 일찍이 도입됐다. 오늘날 대부분의 챗봇 서비스나 쿠키 동의 서비스 등에서 프레임 통신에 의존하는 재사용 가능한 프론트엔드 일부를 찾을 수 있다.
메시지를 보내는 것이 한 부분이라면 다른 부분은 메시지를 받는 것이다. 이를 위해 window 객체에 메시지 이벤트가 도입됐다. 다른 여러 이벤트와 차이점은 발신인의 URL을 추적할 수 있는 오리진 속성도 제공한다는 것이다.
메시지를 보낼 특정 프레임의 URL이 메시지를 보낼 때 필요하다. 이러한 프로세스의 예를 살펴보자.
다음은 상위 문서의 HTML 코드이다:
<!doctype html>
<iframe src="iframe.html" id="iframe"></iframe>
<script>
setTimeout(() => {
iframe.contentWindow.postMessage('Hello!', '*');
}, 1000);
</script>

잠시 후 iframe.html에서 불러온 문서에 Hello! 문자열이 포함된 메시지를 보낸다. URL에는 * 와일드카드 문자열을 사용한다.

iframe은 다음과 같이 정의할 수 있다:
<!doctype html>
<script>
window.addEventListener('message', event => {
const text = document.body.appendChild(
  document.createElement('div'));
text.textContent = ` Received "${event.data}" from
    ${event.origin}`;
});
</script>
이렇게 하면 게시된 메시지가 프레임에 표시된다.

이러한 통신 패턴은 꽤 생산적이지만, 자원을 공유하지 않는다. postMessage 함수를 통해 문자열만을 전송할 수 있다. 이러한 문자열은 JSON으로 직렬화된 복잡한 객체일 수 있지만 내부에 내포된 순환 참조 또는 함수가 있는 참 객체가 될 수 없다.
다른 대안은 직접적 분리을 포기하고 대신 간접적 분리에 힘쓰는 것이다. 웹 작업자를 활용하여 이를 수행하는 것이 좋은 방법이 될 수 있다.

웹 작업자 및 프록시
웹 작업자는 일반적인 멀티스레딩의 번거로움 없이 자바스크립트 엔진의 단일 스레드 모델을 쉽게 탈피할 수 있는 방법이다. 
iframe과 마찬가지로 메인 스레드와 워커 스레드 간의 유일한 통신 방법은 메시지를 게시하는 것이다. 그러나 중요한 차이점은 작업자가 현재 window 오브젝트가 다니라 글로벌 컨텍스트에서 실행된다는 것이다. 아직 일부 API가 존재하지만 많은 부분이 다르거나 전혀 사용할 수 없다.
한 가지 예는 추가 스크립트를 로드하는 방법이다. 표준 코드는 또 다른 <script> 요소를 추가할 수 있지만 웹 작업자는 importScripts 함수를 사용해야 한다. 이것은 동기적이며 하나의 URL뿐만 아니라 실제로 여러 개의 URL을 지정할 수 있다. 지정된 URL이 순서대로 로드되고 평가된다.
지금까지는 괜찮지만 글로벌 컨텍스트를 달리하는 웹 작업자는 어떻게 사용할 수 있을까? 돔 조작을 시도하는 모든 프론트엔드 관련 코드는 여기서 실패한다. 여기서 프록시가 활용된다.
프록시를 사용하여 원하는 개체 액세스 및 함수 호출을 캡처할 수 있다. 이를 통해 웹 작업자의 특정 동작을 호스트로 전달할 수 있다. 유일한 단점은 postMessage 인터페이스가 본질적으로 비동기적이라는 점이며,이는 동기 API를 모방해야 할 때 문제가 될 수 있다.
가장 간단한 프록시 중 하나는 실제로 모든 것을 처리할 수 있는 프록시이다. 다음 스니펫에 나와 있는 이 소량의 코드는 모든 스텁(stub)의 90%를 제공한다.

const generalProxy = new Proxy(() => generalProxy, {
  get(target, name) {
  if (name === Symbol.toPrimitive) {
      return () => ({}).toString();
    } else {
      return generalProxy();
      }
    },
});

여기서 팁은 generalProxy.foo.bar과 같이 아무런 문제 없고 정의되지 않은 액세스나 유효하지 않은 함수 없이 사용할 수 있다는 것이다.
프록시를 사용하여 필요한 돔 API를 대신할 수 있으며 돔 API는 상위 문서로 전달된다. 물론 안전하게 사용할 수 있는 API 호출만 정의하고 전달할 것이다. 궁극적으로 허용되는 API의 안전한 목록을 기준으로 필터링하는 것이 팁이다.
웹 작업자에서 상위 콜백과 같은 객체 참조를 전송하는 문제에 직면할 때 래핑하는 것으로 대체할 수 있다. 사용자 지정 마커를 사용하여 나중에 콜백을 실행하기 위해 웹 작업자를 호출할 수 있다.
이러한 솔루션에 대한 자세한 내용은 나중에 설명하겠다. 지금은 웹이 강력한 모듈화를 위해 활용할 수 있는 공정한 보안 및 성능 수단을 제공한다는 사실만으로도 충분하다.
마지막 섹션에서는 마이크로 프론트엔드를 선택해야 하는 비즈니스 이유를 살펴보고 원래 질문으로 마무리하겠다.

출시 기간 단축(TTM )
이미 기술한 바와 같이 마이크로 프론트엔드가 백엔드보다 완전히 수용하기 어려운 이유는 기술적 그리고 비즈니스적인 이유가 있다. 기술적인 이유들은 중요하지만 사업적인 이유만큼 중요하지 않다.
마이크로 프론트엔드를 구현할 때 기술적 이유만으로는 절대 찾아서는 안 된다. 궁극적으로는 최종 사용자를 위한 애플리케이션을 만들어야 한다. 따라서 최종 사용자가 당사의 기술적 선택에 부정적인 영향을 받아서는 안된다.
그러나 사용자 경험이 비즈니스 관점에서 원동력이 될 수 있을 뿐만 아니라 생산성 수준과 개발 프로세스도 고려해야 한다. 결국 이는 사용자 경험에도 많은 영향을 미치며 다음과 같은 구현의 기초를 보여준다. 새로운 기능을 얼마나 빨리 제공하거나 일부 사용자 설문 조사에 적응할 수 있는지 알아보자.
온보딩(on-boarding) 시간 단축
20년 전만 해도 대부분 개발자들은 한 회사에 꽤 오래 머물렀다. 시간이 지남에 따라 대부분의 회사 근속 기간이 약 2년으로 감소했다. (출처: https://hackerlife.co/blog/san-francisco-large-corporation-employeetenure). 평균 근속 기간은 다음과 같다.
 
그림 1.4 – 한 회사에서 개발자들의 평균 근속 기간

평균 개발자가 6개월 후에 더 큰 코드 베이스에서 생산성을 얻는다면 이는 투자 중 많은 부분(약 25%)이 무용지물을 뜻한다. 비록 비현실적이더라도 첫날부터 생산적이 되는 것이 목표여야 한다.
필요한 인지 부하를 줄이는 것이 온보딩 시간을 단축하는 한 가지 방법이며 독립적인 저장소를 통해 강력한 모듈화를 수행하면 많은 도움이 될 수 있다. 결국 새 개발자가 버그 하나를 수정하면 크기가 작은 리포지토리가 큰 리포지토리에서 보다 훨씬 빠르게 디버깅하고 인지할 수 있다. 커밋 기록이 작을수록(집중도가 높을수록) 엔트리 레벨도 훨씬 작아진다.

여러 팀
신규 개발자를 신속하게 온보딩할 수 있는 경우 여러 소스를 활용하여 채용할 수도 있다. 정보기술(IT) 분야에서 뛰어난 인재를 영입하는 일이 터무니없이 어려워졌다. 상위 기업들은 이미 특히 소규모 벤처 사업에서 필요로 하는 모든 분야에서 뛰어난 개발자들의 상당한 몫을 유치하고 있다. 한 명의 개발자를 인수하는 데 수개월이 걸리는 상황에서 어떻게 새로운 기능을 신속하게 개발할 수 있을까?
이러한 문제에 대한 해결책은 주문형 개발 지원을 제공할 수 있는 IT 기관 또는 서비스 프로바이더의 도움을 고려하는 것이다. 과거에는 외부인력을 데려오는 것이 문제의 원인이 될 수 있었다. 비공개 계약(NDA)을 작성해야 하며, 액세스를 부여해야 하며 가장 큰 고통은 이러한 복잡한 절차이다.
모듈화를 주요 아키텍처 기능으로 사용함으로써, 서로 다른 팀이 각자의 저장소에서 작업할 수 있다. 고유한 프로세스를 사용하고 릴리스 일정을 가질 수도 있다. 이러한 기능은 내부적으로도 유용하지만 외부 개발자 및 팀과 함께 작업할 때 가장 큰 이점이 있다.
프론트엔드를 모듈화할 수 있는 가장 좋은 장점 중 하나는 팀을 감축하는 새로운 방법을 생각해내는 것이다. 예를 들어, 각 팀이 하나의 백엔드 서비스와 하나의 프론트엔드 모듈을 담당하는 진정한 풀 스택 팀을 도입하는 것이다. 이 경계선이 항상 의미가 있는 것은 아니지만, 여러 시나리오에서 매우 유용할 수 있다. 백엔드 API를 프론트엔드 API로 만든 동일한 팀에 제공하면 세부적 요구 사항이 줄어들고 보다 안정적인 릴리스가 가능해진다.
도메인 기반 설계(DDD)의 아이디어를 여러 팀과 결합하는 것은 인지 부하를 줄이고 명확한 아키텍처 경계를 설정하는 효율적인 방법될 수 있다.
DDD는 유지보수 불가능한 스파게티 코드로 끝나지 않고 모듈화가 수행되는 방법을 공식화하는 기술 집합이다. 4장, 도메인 분해에서는 도메인 분해라고 하는 모듈화를 도출하는 데 도움이 되는 이러한 기술에 대해 자세히 알아볼 것이다. 그러나 올바른 도메인 분해를 도출하는 것은 절대로 쉬운 일이 아니다. 여기서는 서로 다른 기능 도메인을 구분하는 것이 핵심이다.

기능 격리화
마이크로 프론트엔드를 도입하기 위해 저자가 가장 좋아하는 비즈니스 동인은 자신만의 일정을 사용하여 독립적인 기능을 배송할 수 있다는 것이다.
제품 소유자(PO) 중 한 명이 새로운 기능에 대한 아이디어를 가지고 있다고 가정해 보자. 현재로서는 이 기능이 사용자에 의해 어떻게 받아들여질지는 잘 알려져 있지 않다. 여기서 무엇을 할 수 있을까? 물론, 우리는 PO에게 제시된 작은 POC부터 시작할 것이다. 이것이 잘 받아들여진다면, 최종 사용자 피드백을 수집하는 데 도움이 되는 최소 실행 가능한 제품(MVP)을 만들 수 있을 것이다.
과거에는 이 기능을 원하는 방식으로 애플리케이션에 적용하기 위해 많은 조정이 필요했다. 마이크로 프런트엔드를 사용하여 점진적으로 기능을 배포할 수 있게 되었다. 먼저 PO만 사용할 수 있도록 한 다음 대상 최종 사용자에게도 롤아웃을 조정한다. 마지막으로, 전체 지역이나 전 세계에 출시하는 형태이다.
선택적 원격 설치는 기능이 분리된 경우에만 가능하다. 기능 A와 기능 B, 두 가지 기능이 있는 경우 기능 B에 대해 점진적인 롤아웃이 불가능하다. 항상 기능 A의 롤아웃 규칙의 상위 집합이어야 한다. 
일반적으로, 그러한 의존성은 여전히 가능할 수 있지만(또는 심지어 희망할 수도 있지만), 본질적으로는 절대 직접적이어서는 안 된다. 따라서 사용 가능한 모든 형상은 다른 형상에 대해서만 약하게 참조할 수 있다. 약한 참조가 확장성의 기초를 형성하고 건전한 마이크로 프론트엔드 솔루션에 중요하다는 것을 나중에 알게 될 것이다.
구성된 마이크로 프론트엔드가 잘 설계되었는지 확인하기 위한 좋은 테스트는 전원을 꺼보는 것이다. 전반적인 애플리케이션이 여전히 작동합니까? 어쩌면 그것이 더 이상 유용하지 않을 수도 있지만, 그것이 핵심은 아니다. 애플리케이션이 여전히 기술적으로 작동 중인 경우 마이크로 프론트엔드 솔루션은 여전히 건전한다. 항상 자신에게 물어봐야한다: 원칙적으로 이 모듈 없이도 작동하는가?
결과적으로 마이크로 프론트엔드를 끌 수 있기 때문에 개별 마이크로 프론트엔드를 교환할 수도 있다. 내부 작업을 사용할 필요가 없기 때문에 완전히 교체할 수도 있다. 이를 통해 유용한 사용자 피드백을 수집할 수 도 있다.

A/B 테스팅
비즈니스 관점에서 마이크로 프런트엔드를 사용해야 하는 최소 12가지 이유를 찾을 수 있다. 그러나 유감스럽게도 종종 잊혀지는 이유는 사용자 피드백 수집을 단순화하기 위한 것이다. 이를 위한 좋은 방법은 A/B 테스트를 도입하는 것이다.
A/B 테스트에서는 두 가지 변형 기능을 소개하면 하나는 변종 A이고 다른 하나는 변종 B이다. A는 형상의 현재 상태(일반적으로 기준선이라고 함)일 수 있지만, B는 문제에 접근하는 새로운 방법일 수 있다. 다음 다이어그램은 이를 보여 준다:

 
그림 1.5 – 다른 사용자에 대해 다른 결과를 만드는 기능에 대한 A/B 테스트
어쨌든 기능이 새로운 시나리오에서는 여기에 참여하고자 하는 모든 사용자에게 A/B 테스트를 제공할 수 있다. 기준선으로 작업할 경우 기존 습관이 데이터를 오염시키지 않도록 기능에 익숙하지 않은 사용자만 조사하는 것이 타당할 수 있다.
대부분의 프런트엔드 모노리스에는 특정 기능에 대한 A/B 테스트 기능이 포함되려면 상당히 많은 코드 변경이 필요하다. 최악의 경우, 변종 A에서 변종 B로 분기하는 것은 수백은 아니더라도 수십 군데에서 찾아볼 수 있다. 적합한 모듈화를 도입하여 코드 변경 없이 A/B 테스트를 도입할 수도 있다. 이는 마이크로 프런트엔드를 운송하는 부품만 활성 A/B 테스트의 규칙에 대해 알아야 하는 이상적인 시나리오다.
사실, 피드백을 포함하고 결과를 평가하는 것은 물론 완전히 다른 이야기이다. 여기, 마이크로 프론트엔드는 우리에게 별로 도움이 되지 않는다. 데이터 분석을 지원하기 위한 전용 툴과의 연결은 단일 솔루션을 통해 변경되지 않는다.

 
요약
이 장에서는 웹이 마이크로 프론트엔드를 실행 가능한 솔루션으로 제시할 수 있는 지점에 도달하도록 어떻게 진화했는지 살펴봤다. 애플리케이션 확장의 필요성이 조정 노력이 효율성에 큰 영향을 미치는 시점에 도달했다는 점에 대해 논의했다. 몇몇 새로운 기술적 가능성과 함께, 마이크로 프런트엔드의 구조적 패턴은 이제 성공적으로 구현될 수 있다.
이제 마이크로 프런트엔드는 기술적인 배경뿐만 아니라 비즈니스 배경도 있다는 것을 알게 되었다. 하지만, 몇 가지 장점 외에도, 그들은 단점도 가지고 있다. 확실한 해결책을 추구할 때는 처음부터 무엇을 기대해야 하는지 아는 것이 중요하다.
다음 챕터에서는 마이크로 프런트엔드의 당면 과제와 함정에 대해 자세히 알아볼것이다. 우리의 목표는 탄탄한 솔루션을 통해 모든 과제를 성공적으로 해결할 수 있는 것이다. 가장 어려운 문제들 중 몇 가지를 적절한 구현으로 이끄는 길과 함께 다룰 것이다.






 
2 일반적인 도전들과 함정들
이전 장에서 마이크로 서비스의 진화와 궁극적으로 마이크로 프론트엔드는 더 이상 피할 수 없다는 것을 알게 됐다. 기술의 모듈화는 거의 모든 산업에서 찾아볼 수 있는 자연스러운 과정이다. 모듈화는 많은 장점을 가져오지만 또한 몇 가지 도전 과제들을 제시한다. 

마이크로 프론트엔드로 가는 여정에서 몇 가지 문제들을 마주한다. 특히 모듈화의 일반적인 문제들을 생각해보고 프론트엔드가 어떻게 동작해야 하는 지에 관한 우리의 기대에서 오는 추가적인 문제도 다룬다.

이번 장은 마이크로 프론트엔드를 적용할 때 다섯 가지의 가장 일반적인 이슈들에 대해 다룬다. 

이번 장에서는 다음 내용들을 깊이 다룬다.
•	성능
•	보안
•	지식 공유
•	안정성
•	사용자 경험
위의 내용들에 관한 논의는 대부분 이론에서 그친다. 구체적인 구현에 관한 세부적인 내용들은 다른 아키텍처 스타일을 배울 때 다룰 것이다.

성능
성능은 거의 항상 피처(feature)로 여겨진다. 서로 다른 종류의 어플리케이션(application)은 서로 다른 성능의 기준을 충족하겠지만 특히 최종 사용자를 다루는(end-user-facing) 어플리케이션의 경우에는 그들의 만트라가 있는데 “빠를수록 좋다”이다. 아마존(Amazon)은 매 100ms의 지연 시간(latency)이 발생하면 매출의 1%에 영향을 준다고 주장한다. 이것은 매우 큰 숫자이고 지나쳐서는 안 된다.

리소스 캐싱(caching)
우리가 봐온 것처럼 요즘에는 다양한 종류의 웹사이트가 존재한다. 다음과 같은 것들이 있다. 

•	정적 웹사이트
•	동적 웹사이트(서버 사이드 렌더링)
•	AJAX를 이용한 동적 웹사이트
•	SPAs

모든 웹사이트는 저마다 성능을 증가시키고 스케일을 확장하도록 기술을 갖고 있다. 예를 들어 이미 정적 웹사이트들은 모든 요청을 디스크에서 페이지 읽기로 처리하는 것을 피하기 위해 인-메모리 캐시를 사용한다. 이 간단한 피처는 이미 SPAs에 사용될 수 있지만 서버 사이드 렌더링을 위해 손으로 반드시 구현되어야 한다. 
서버 사이드 렌더링을 다루는 대부분의 언어들과 프레임워크는 주어진 요청의 응답을 생성하기 위해 어떤 종류의 의존성(dependency)이 필요한지 모른다. 따라서 이러한 요청들에 대한 자동적인 캐시를 도입하는 것은 매우 어려워 보이지만 힌트를 줌으로써 이러한 프레임워크들을 도울 수 있다.
캐시를 써서 성능을 향상시키기 위해 브라우저 뿐만 아니라 우리의 서버를 돕는 데도 적용할 수 있는 다수의 캐싱 레이어가 있다. 이상적으로 많은 프론트엔드 에셋들은 고유하게 이름이 부여되고 클라이언트에서 영구적으로 캐시될 수 있다.

중요한 노트

캐싱과 적절하게 통신하기 위한 전용 HTTP 헤더가 여럿 있다. 여기서는 가장 강력한 캐싱 보장에 중점을 두지만 일반적으로 보다 세분화된 접근 방식도 아주 유용하다. 캐싱에 더 알고 싶다면 MDN:https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching 을 참고하자.

어느 순간에는 여러 에셋을 하나의 에셋으로 모으고 싶을 수도 있다. 예를 들어 세 개의 마이크로 프론트엔드가 모두 하나의 같은 자바스크립트 파일을 만든다면 이것을 단일한 자바스크립트로 가져가고 싶을 것이다. 이것은 이익일 수 있지만 복잡성과 결과가 투자한 것 대비 좋지 않을 수 있다. 그 이유는 다음과 같다.

•	HTTP2는 요청들을 스트림(stream)하고 하나의 자원에 제공하는 것 만큼 거의 효율적으로 여러 리소스에 제공한다.
•	캐싱은 더 복잡해지고 대체적으로 캐시 미스가 늘어난다.
•	각각의 스크립트은 URL을 새로 고침하기 위해 그들의 문맥을 잃는다. 
•	하나의 에러가 이는 스크립트는 통합하는 과정에서 모든 스크립트의 실행이 중단될 수 있다.

결과적으로 브라우저에서 마이크로 프론트엔드 당 리소스를 직접적으로 소비하는 것은 모든 마이크로 프론트엔드를 포함하는 하나의 큰 리소스를 소비하는 것보다 일반적으로 더 낫다. 

번들 사이즈
일반적으로 SPAs나 자바스크립트로 짜여진 무거운 페이지들에 대해 우리는 자바스크립트의 코드들을 주의할 필요가 있다. 오늘날의 환경에서는 여러 의존성을 너무 부주의하게 사용한다. 자바스크립트의 번들들의 크기를 모니터링하고 이러한 번들들을 작게 유지하는 것은 우수한 성능에 매우 중요하다.
특히 SPA 기반 마이크로 프론트엔드의 경우 각각의 마이크로 프론트엔드에 대한 하나 이상의 자바스크립트 파일을 만들기 위해 webpack이나 Parcel같은 번들을 사용한다. 여기서 각각의 자바스크립트 파일을 작게 하는 것보다 나눠서 활용하는 것이 중요하다. 고전적인 예는 SPA에서 각각의 페이지에 대해 자바스크립트 파일을 따로 생성하는 것이다. 

그래서 아래처럼 코드를 작성하는 것 대신 import 함수를 사용해서 다른 자바스크립트 부분을 레이지 로딩을 통해 번들을 나눔으로써 활용할 수 있다.

import * as React from 'react';
import { Switch, Route } from 'react-router-dom';
import MyPage from './page';
export const Routes = (
<Switch> 
<Route path="/my-page" component={MyPage} />
</Switch> 
); 

리액트(React)에서 Suspense 컴포넌트를 포함하는 lazy 함수는 이렇게 사용한다. 

import * as React from 'react';
import { Switch, Route } from 'react-router-dom';
const MyPage = React.lazy(() => import('./page'));
export const Routes = (
<React.Suspense fallback={<div>Loading...</div>}>
<Switch> 
<Route path="/my-page" component={MyPage} />
</Switch> 
</React.Suspense>
); 

마이크로 프론트엔드에서는 마이크로 프론트엔드가 적용되지 않은 웹 어플리케이션에서 보다 번들을 나누는 것이 더욱 중요하다. 확장성은 중요한 원칙 중 하나이기 때문에 유려한 사용자 경험을 보장하는 유일한 방법은 수요에 알맞게 로드된 작은 에셋을 생성하는 것이다. 

중요한 노트
어떤 의존성이 최종 번들 크기에 얼마나 영향을 미치는 지 아는 건 항상 중요하다. Webpack에서 webpack-bundle-analyzer 같은 패키지는 꽤 보기 좋게 시각화해준다. 또한 https://bundlephobia.com 같은 웹사이트는 의존성을 포함한 비용을 일찍 인지할 수 있도록 도와준다. 

일반적으로 최대한 개별적인 코드의 레이지 로딩을 도입하도록 노력해야 한다. 봤던 것 처럼 SPAs에서 이것은 페이지를 보여주는 모든 컴포넌트를 레이지 로딩하는 것 만큼 쉽다. 또한 “특별한” 상황에서만 사용되는 의존성은 주요 번들에 포함되지 않아야 한다. 최신의 Promise 구조를 사용하는 것은 여기서 많은 도움이 된다. 

요청 최적화
마이크로 프론트엔드는 모듈화가 전부라고 해도 믿을 정도다. 언젠가 요청의 수는 무한히 증가한다. 무엇보다도 모놀리식에서 모든 것을 통합 시키는 것 대신에 요즘은 서버나 혹은 브라우저 안에 서로 다른 기술적인 부분이 아주 많이 분산된 시스템을 갖고 있다. 
모듈은 매우 빈번하게 같거나 유사한 데이터를 요청한다. 만약 우리가 주의하지 않는다면 API 서버에게 많은 부하를 줄 수 있다. 최악에는 결과를 수집하는 것이 더욱 오래 걸리고 더 나쁜 사용자 경험이 된다. 그러므로 API 요청에 대한 마이크로 캐싱을 도입하여 이것을 완화할 수 있다. 만약에 /api/user에 요청이 1초 동안 캐시된다면 다른 실행 단위는 캐시에서 결과를 바로 얻을 수 있다. 중요하게도 서버 사이드에서 이 캐시는 페이지 요청 컨텍스트에 대해 독점적이어야 한다.
또 고려할 요인은 일괄 처리(batching)를 요청하는 것이다. 특히 마이크로서비스 백엔드의 경우 일부 필수 정보를 집계하는 데 필요한 요청이 많을 수도 있다. 만약에 API 게이트웨이에 대해 GraphQL 같은 기술을 도입 할 때 여러 쿼리로 하나의 요청을 처리할 수 있다. 그러면 백엔드는 클라이언트보다 더 빠르고 직접적인 방법으로 서로 다른 모든 쿼리를 처리한다. 여기서 백엔드는 쿼리를 캐시할 수도 있다. 

이제 요청 최적화를 다뤘으니 잠재적인 보안 이슈들과 보안 부문을 조금 더 자세히 살펴보도록 하자. 

보안
잠재적인 취약성을 논하기 전에 마이크로 프론트엔드의 두 가지의 양극단을 더 자세하게 검토해볼 필요가 있다.

•	사용자 관리를 포함한 중앙 집중식으로 제공되는 크로스 커팅 관심사(cross-cutting concerns) 
•	모듈이 사용자 관리에 대해 각각 책임을 지는 완전한 고립

양 쪽 극단은 그들의 장점과 단점이 모두 존재한다. 우리가 이미 봤던 것처럼 적절한 균형을 찾는 것은 성공적인 구현에 매우 중요하다. 만능 열쇠는 없다. 프로젝트에 의해 정의 내려진 경계 조건에 따라서 결정된다. 
지금까지 보안 관리에서 가장 큰 위협은 잠재적으로 믿기 힘든 코드의 실행에서 발견된다. 코드는 더 이상 중앙에서 생성되고 유지되지 않기 때문에 원치 않는 코드 조각(snippet)이 시스템으로 들어갈 가능성이 급격하게 증가한다. 결과적으로 취약성을 피하기 위해 더 많은 경계와 프로세스가 필요하다. 

중앙 사용자 관리
이것은 하나의 백엔드만 사용돼야 할 때 고려해볼 수 있다. 이러한 극단은 대개 많은 문제의 경우에 이상적인 솔루션에 가깝다.
중앙 사용자 관리에서 중앙화 된 함수를 통해 백엔드에 모든 HTTP 요청을 처리하거나 백엔드로 향하는 요청에 내부적으로 세션을 붙힌 쿠키를 사용한다. 전자의 경우 중앙화 된 함수에 의해 생성된 요청에 토큰을 붙일 수도 있다. 후자의 경우 어플리케이션에서 토큰은 사용되면 안 된다. 사용자 정보는 현재 사용자에 관한 공통적인 질문에 대답하는 것을 간소화 하기 위해 중앙에 저장될 수 있다. 
그림 2.1의 다이어그램은 마이크로 프론트엔드가 백엔드와 통신하기 위한 어플리케이션의 사용자 관리 모듈을 면밀히 살펴볼 필요가 있다는 것을 보여준다. 이 방법에서 토큰은 적절하게 삽입돼야 한다. 사용자 관리 모듈은 아래 그림에서 보여주는 것처럼 마이크로 프론트엔드 솔루션의 기초 레이어와 함께 배포되므로 각각의 마이크로 프론트엔드로부터 독립되어야 한다. 

 
그림 2.1 – 중앙 인스턴스를 통과하는 백엔드 요청을 필요로 하는 중앙 사용자 관리

사용자 관리 부분은 미들웨어(middleware)를 통해API 요청자 논리로부터 분리될 수 있다. 이것은 HTTP 헤더 인젝션을 사용할 것이고 통신수단에 따라 다른 기술을 사용할 것이다. 

개별 사용자 관리
이것은 서드 파티 소스로부터 나가거나 들어오는 다수의 백엔드나 마이크로 프론트엔드가 있을 때 고려해볼 수 있다.
예를 들어 각각의 마이크로 프론트엔드는 메모리에 벡엔드 통신을 위한 토큰을 갖는다고 하자. 이것은 벡엔드에서 같은 어플리케이션을 위한 수십 개의 토큰을 다시 생성해야 하는 것을 피하기 위한 요청의 마이크로 캐싱과 잘 맞다. 그림 2.2에 있는 다이어그램은 이것을 잘 보여준다. 

 
그림 2.2 – 잠재적으로 직접적인 API  호출을 허락하는 개인 사용자 관리

개별적인 사용자 관리의 가장 큰 장점은 각각의 마이크로 프론트엔드 독립을 보장한다는 것이다. 여기에는 어느 하나의 모듈도 망가뜨릴 만한 걱정이 없다. 

스크립트 실행
클라이언트나 서버 혹은 모두에서 마이크로 프론트엔드를 운영할 지 말지 관계 없이 전체적으로 어플리케이션과 다른 마이크로 프론트엔드에 영향을 주는 코드가 실행 될 수 있다는 것을 알아야 한다. 따라서 무엇이 마이크로 프론트엔드에 영향을 미칠 지 가장 먼저 명확히 하는 것이 중요하다. 만약 어떤 것도 영향을 미칠 수 있다면 매우 강력한 고립이 필요하다. 혹은 그 답이 내부 팀에만 국한된다면 새로운 것을 구현할 필요는 없다. 그러나 안정적인 시스템을 갖는 것은 중요하다. 

완벽한 고립을 달성하기 위해서는 다양한 노력이 필요하다. 예를 들어, 브라우저 안에서 스크립트들을 <iframe> 안에 두거나 새로운 워커(Worker)에 둘 수 있다. 

// create worker
const myWorker = new Worker('./my-worker.js');

// receive messages from the worker
myWorker.onmessage = e => {
console.log('Received new data', e.data);
}; 

// message the worker using any object that can be cloned
myWorker.postMessage({ type: 'hello', text: 'Hi World!' });


Node.js 에서 새로운 vm.Script를 생성하기 위해 폴백(fall back)할 수 있다.

// import vm module
const vm = require('vm');

// create context with no globals except require and
  // console 
const context = vm.createContext({ require, console });

// create a new script execution environment and run it
const script = new vm.Script('require("./script.js")');
script.runInContext(context);


어떤 경우에서도 호스트와 사용 가능한 APIs 간의 통신은 강력하게 규제된다. 유연성과 보안 사이의 균형을 필요로 한다.
예를 들어, 브라우저에서 중앙 사용자 관리를 하는 두 가지 방법이 있다. 백엔드에서 내부적인 쿠키를 경유하는 방법과 토큰을 저장하는 것이다. 전자는 프론트엔드를 위한 백엔드(Backend for Frontend, BFF)가 필요하고 후자는 안전한 토큰 포맷이 필요하다. 예를 들면 서명된 자바스크립트 웹 토큰(JavaScript Web Tokens, JWTs)를 사용하는 것이다. 어떻게 이것을 얻는지 그리고 보안 속성이 무엇을 포함하고 있는 지(예를 들어, 만료 시간)에 따라 실용적인 목적을 위해 고정된 것으로 여겨질 수 있다. 
쿠키는 특별한 설정 없이 작동하고 브라우저에 의해 내부적으로 보호되기 때문에 항상 사용된다. 쿠키에 대해 브라우저의 보안이 보장할 수 있는 것 중 하나는 HttpOnly 쿠키가 스크립트에 의해 절대 읽힐 수 없다는 것이다. 따라서 스크립트의 실행은 외부에서 작성된 스크립트라 하더라도 이런 점에서 충분히 안전하다고 볼 수 있다.
 
 외부로부터 들어오는 스크립트는 최대한 샌드박스로 남아야 한다. 이전의 정적인 코드 분석 또는 수동적인 리뷰 없이 스크립트는 실행 환경의 일부로 포함될 수 없다. 그렇지 않다면 예를 들어 의심스러운 소스로 돌아가는 리포트를 하는 키로거(keylogger)를 가져오는 것은 정말 쉬운 방법이다.

크랙에 대한 또 다른 과제는 일반적으로 분산 어플리케이션에서 일반적으로 숨겨져 있는 내부적인 지식 공유이다.

지식 공유
이상적으로 각각의 마이크로 프론트엔드는 고립된 모듈을 의미하고 의존성과 다른 마이크로 프론트엔드의 지식이 없어도 동작한다. 그러나 현실에서는 마이크로 프론트엔드는 의존성을 갖고 어느 정도의 다른 마이크로 프론트엔드에 대한 지식을 필요로 한다.

두 개의 참조가 있다.
•	강력한 결합을 구성하는 직접적(또는 강력한)인 참조
•	느슨한 결합을 구성하는 간접적(또는 약한)인 참조

느슨하게 결합된 모듈은 잘 확장한다. 느슨하게 결합된 모듈의 문제는 여전히 따라야 하는 어떤 컨벤션과 계약이 따라올 필요가 있다. 예를 들어 특정 이름의 이벤트를 내보내면 잠재적인 청취자(listener)는 이 이름이 동일하게 유지되기를 기대한다. 일단 이름을 변경하면 청취자는 더 이상 이벤트를 받을 수 없다. 

식별자에 대한 합의를 지식 공유라고 한다. 지식을 공유하는 방법에는 여러 가지가 있다.
•	특정 이름에 대해 두 팀 이상이 동의하는 것
•	한 팀이 이름을 정하는 것

식별자 대신에 특정한 행동, 흐름 또는 공유되는 의존성이나 그들의 버전 같은 기술 결정에 대한 합의가 형성될 수 있다.

그림2.3의 다이어그램은 이벤트를 생성한 팀이 변화가 발생한 모든 컨슈머 팀과 통신해야 하는 예시를 보여준다. 

 
그림2.3 – 이벤트 구조의 모든 변화는 관심 있는 이해 당사자와 커뮤니케이션이 필요하다.

효과적이게도 마이크로 프론트엔드 안에서 사용되는 어떠한 합의조차 내부적으로 그들 사이에서 계약을 형성한다. 이 합의는 일부 도구(예를 들어, 컴파일러)에 의해 강요되지 않기 때문에 잠재적인 오류의 시작 지점이다. 어떻게 강력히 수행할 수 있을까?

여기서 데브옵스(DevOps)의 모범 사례가 등장한다. 무엇보다도 마이크로 프론트엔드는 어플리케이션에 자동으로 적용되지 않는다. 반드시 승인이 필요하고 미리 정의된 빌드 파이프라인을 거쳐야 한다. 어떤 경우라도 무엇이 들어오는 지 제어할 수 있는 중앙문을 어딘가 갖고 있어야 할 것이다. 이 문에서 컨벤션을 강요하고 관계를 확인하며 통합 테스트를 수행한다. 

큰 규모의 수정이 필요하다면 변경 관리의 원칙이 매우 유용하다. 이것은 내부적인 마이크로 프론트엔드에서만 그런 게 아니라 외부의 마이크로 프론트엔드에도 적용할 수 있다. 통신 요인은 매우 중요하다.

중요한 노트

정렬(alignment)의 감소가 마이크로 프론트엔드의 목표 중 하나이지만 그것이 완전히 제거될 수는 없다. 통신과 지식 공유의 필요성은 항상 존재한다. 좋은 소식은 원칙과 효율적인 개발자 소통에 대한 아이디어는 보편적이고 아직까지 마이크로 프론트엔드에 적용할 수 있다. API 변경의 통신에 대한 전략이 궁금하면 이 https://freecontent.manning.com/designing-apis-communicating-with-your-developers/를 참고하자.

유예 기간 없이 대규모의 수정을 하는 것은 반드시 피해야 한다. 한 가지 기본 설정은 사용 중단(deprecated)으로 시작한 다음 스텁(stub) 그리고 관련 부분을 제거한다. 이는 변경 관리 프로세스에도 포함될 수 있다. 

•	사용 중단은 컴파일 시간에서 개발자에게 경고를 제공해야 한다.
•	스텁은 런타임에 소유자에게 보고할 수 있다.
•	삭제는 최종 사용자를 위해 이 피처를 중지한다.

통합 환경은 최종 사용자의 가시성을 통해 프로덕션에 도달하기 전에 유용한 통찰력을 얻음으로써 이 프로세스를 훨씬 덜 두렵게 만든다. 그들은 또한 응용 프로그램의 안정성을 확인하는 데 좋다.

안정성
마이크로 프론트엔드는 다양한 소스에서 수십 개의 작은 모듈을 로드한다. 모든 요청에는 실패할 가능성이 있다. 결과적으로 일부 모듈이 로드되지 않을 가능성이 상대적으로 높으므로 간과해서는 안 된다. 

주어진 애플리케이션이 아키텍처 측면에서 견고한 기반 하에 설계되어 있는 지 확인하기 좋은 테스트는 모듈 중 하나를 비활성화하는 것이다. 그것이 실패를 유발하는가? 실패가 예상되는가? 오류가 보고되는가? 그러면 이 모든 질문에 답할 수 있다. 실제로 로그인 기능을 비활성화하면 애플리케이션을 거의 사용할 수 없게 되지만 애플리케이션 자체는 계속 작동해야 한다. 그렇지 않으면 아키텍처가 너무 많이 결합 되어 있다는 것을 의미한다.

확장성과 마찬가지로 안정성이라는 주제에 접근하는 가장 좋은 방법은 느슨한 결합을 도입하는 것이다. 또한 HTTP 요청을 더 강직하게(robust) 만드는 표준 기술도 사용할 수 있다.
• (매우) 작은 타임 아웃을 지정한다.
• 중요한 요청에 대한 재시도를 한다.
• 연결 끊김을 감지하고 그것을 우아하게 처리한다.

그래도 단일 마이크로 프론트엔드는 충돌한다. 이런 상황에서 가장 중요한 점은 마이크로 프론트엔드가 시작된 정확한 위치에 오류 경계를 배치하는 것이다. 어떤 대가를 치르더라도 다른 모든 모듈을 포함한 기본 응용 프로그램은 죽지 않아야 한다.

안정적인 어플리케이션은 훌륭한 사용자 경험의 기본이다. 그러나 마이크로 프론트엔드의 경우 일관된 사용자 경험을 얻기 위해 조금 더 노력해야 한다.

사용자 경험
마이크로서비스와 마이크로 프론트엔드의 주요 차이점은 마이크로 프론트엔드의 경우 최종 사용자에게 단일 단위로 보여야 한다는 것이다. 이것은 시각적 디자인에 영향을 줄 뿐만 아니라 행동과 문구를 포함한다. 프론트엔드의 모든 부분이 독립적으로 개발되고 유지 관리된다면 어떻게 일관된 단일 애플리케이션이 사용자에게 제공되도록 보장할 수 있을까?

워딩
마이크로 프론트엔드를 원자들로 구성된 분자로 생각하면 사용 가능한 원자를 정렬하여 상황을 조화롭게 만들 수 있다. 여기에서 원자는 폼(form), 카드 또는 텍스트 필드와 같은 컴포넌트를 의미한다. 이것을 표준화하면 분명 도움이 되지만 여전히 디자인 비전이나 특정 워딩을 빠뜨릴 수 있다.

밝혀진 바와 같이 여기에는 만능 열쇠가 없다. 결국 중앙화와 독립 사이의 트레이드 오프다. 어디에 어플리케이션에 대한 요점을 정의할 것인가는 우리에게 달려 있다. 워딩의 경우 다음 중 하나의 옵션을 수행하는 것이다.

• 중앙 워딩 컨테이너에 공유된 워딩 조각 세트를 넣는다. 
• 전담 워딩 팀이 나중에 조각을 수정하고 덮어쓸 수 있도록 허용한다.
• 각 마이크로 프론트엔드에 전문화 및 세부 사항을 남겨둔다.

이는 많은 애플리케이션에 적합한 타협을 보여준다. 개발자가 피처를 빠르게 제공할 수 있도록 차단을 해제하는 동시에 중앙 팀이 나중에 워딩을 정렬하고 조정할 수 있도록 한다.

디자인 비전의 경우 스타일 가이드가 적합하다. 일반적으로 스타일 가이드는 패턴 라이브러리를 중심으로 한다.

패턴 라이브러리
전체 어플리케이션에 걸쳐서 사용되는 컴포넌트들의 집합을 정의하는 것이 패턴 라이브러리라고 한다. "라이브러리"는 우리 애플리케이션에 대한 기술적 종속성으로 가장 자주 언급되지만 "사용 가능한 CSS 스타일"을 의미할 수도 있다. "종이에 지정된 스타일"조차도 패턴 라이브러리의 해석이다.

특정 해석과는 별개로 디자인들과 동작을 포함하여 컴포넌트들을 이동시키는 단일 표준이 있다.

마이크로 프론트엔드에서 사용하기에 충분히 유연한 컴포넌트를 설계하는 문제는 14장, UX 및 화면 디자인에 미치는 영향에서 자세히 설명한다.

요약
이 장에서는 마이크로 프론트엔드를 다룰 때 어떤 핵심 과제가 존재하는지 배웠다. 그리고 작은 트릭이 성능을 얼마나 크게 향상시킬 수 있는지 확인했다. 보안 부문에서 추가 인식을 통해 쉽게 공격할 수 없는 강력한 솔루션을 구축할 수 있다.
개발 팀 내에서 효율적으로 지식을 공유하는 것은 일관된 사용자 경험을 갖는 것만큼 중요하다. 두 영역 모두 규율과 엄격한 지침이 필요하다. 중앙화된 그러나 분산된 접근 방식을 사용하는 것은 서로 다른 모듈에 너무 많은 제약을 가하지 않고 충분한 컨텍스트를 생성하기 위한 좋은 절충안인 경우가 많다.
다음 장에서는 특정 문제를 해결하기 위해 맞춤화된 마이크로 프론트엔드를 구성하고 구현하는 방법에 접근하기 위해 다양한 배포 시나리오를 다룰 것이다.

 
3 배포 시나리오
이전 장에서 우리는 마이크로 프론트엔드를 적용할 때 일반적인 문제와 함정을 살펴봤다. 이러한 문제로 인해 우리의 삶이 조금 더 복잡해지긴 하지만, 원하는 이점을 얻는 것은 자주 필요악 같은 존재다. 즉, 개발 팀의 측면에서 향상된 확장성이다. 이러한 이점을 가장 잘 볼 수 있는 라이프 사이클 부분은 배포에 있다.

모놀리식은 하나의 배포 방식과 같이 온다. 모두이거나 아무것도 아니다. 완전 비즈니스 로직 하나의 액티비티를 시작해야 한다. 마이크로 프론트엔드보다 개발에서 모노리식한 아키텍처가 확장성이 떨어지는 이유는 훨씬 큰 릴리즈를 필요로 하기 때문이다. 아주 자주 대규모의 릴리즈들은 더 긴 릴리즈 사이클을 갖게 된다. 무엇보다도 테스팅과 검증이 필요하다. 

마이크로 프론트엔드들에서 우리는 배포 파이프라인을 생성하는 많은 옵션들을 갖는다. 심지어 여기에서 우리는 하나의 파이프라인을 레버리지한다. 대안적으로 다른 스펙트럼의 극단을 사용할 수 있다. 많은 독립적인 파이프라인과 함께하는 분산된 배포들을 갖는다. 마지막으로 우리는 중앙 집중적인 것과 분산된 배포 스키마에 대한 관점을 사용하는 솔루션을 겨냥한다.

이 장은 세 가지의 시나리오들과 가능한 변이를 갖는다. 일러스트레이션 목적을 위해 우리는 야믈 파일을 사용할 것이고 아이디어들이 대부분의 CI 시스템들로 이동됨에도 불구하고 Azure DevOps에서 그리고 CircleCI에서 찾을 것이다. 특정한 마이크로 프론트엔드 아키텍처를 가정하지 않을 것이다. 

이 장은 다음의 메인 토픽들을 다룰 것이다.
•	중앙 집중적인 배포들
•	분산된 배포들
•	하이브리드 솔루션들


중앙 집중적인 배포
하나의 큰 릴리즈는 종종 모노리식한 아키텍처의 단점이라고 여겨졌지만, 그것은 하나의 원하는 솔루션이라고 보여질 수도 있다. 무엇보다도 함께 작동하는 하나의 유닛으로 확신할 수 있는 하나의 방법이라고 볼 수 있다. 이 솔루션에서 어플리케이션이 업데이트 될 때 아주 잘 다룰 수 있다. 마지막으로 마이크로 프론트엔드에 대해 중앙 집중적인 배포를 사용하는 것의 가장 궁극적인 이점은 이미 upfront한 마이크로 프론트엔드들과 합칠 수 있다는 것이다. 이것은 중앙 집중적인 파이프라인에서 통합하기 어려운 최적화와 강화를 가능하게 한다.

또한 중앙 집중적인 CI 파이프라인에 대해 생각하는 두 가지 방법이 있다. 다음과 같다.
•	하나의 레포지토리를 사용하는 것
•	여러 개의 레포지토리들을 합치는 것

전자가 조금 더 세팅하기 쉽지만 후자는 대부분의 사용자의 이후에 더 가까운 것은 후자다. 둘 다 살펴보자.

하나의 레포지토리 사용하기
모노레포는 매우 유명해졌고 배포에 대한 기다림이 필요없이 서로 다른 패키지를 섞는 것을 허락하는 이유가 되었다. 그러한 방법으로 많은 배포 사이클을 거칠 필요 없이 서로 다른 패키지의 작동 상태를 얻게 됐다.

모노레포는 마이크로 프론트엔드들에 대해 자연스럽게 자격이 되지만 한편으로는 의문이 든다. 무엇보다도 만약 하나의 장소에서 모든 정보가 있다면 왜 소비를 위해 그것들을 분산시킬 필요가 있을까? 끝으로 만약 우리가 배포 독립화를 위해 필요한 것이 아닌 개발을 위한 하나의 메트릭으로써 마이크로 프론트엔드를 생각한다면 이것은 문제를 잘 풀 것이다.

그림 3.1 은 어떻게 하나의 중앙 집중적 CI 파이프라인과 함께 모노레포를 사용하는 방법을 보여준다. 모노레포에서 모든 마이크로 프론트엔드는 같은 파이프라인에서 만들어지고 출시된다.

 
그림 3.1. 하나의 모노레포에서 어떠한 코드의 변화도 모든 마이크로 프론트엔드들의 빌드를 합치는 것을 유발한다

프론트엔드 프로젝트들에서, 모노레포들은 Lerna같은 툴링에 의해 보통 처리된다. 

중요한 노트

Lerna는 모노레포들을 꽤나 쉽게 사용할 수 있도록 만들어주는 테스크 러너이다. Yarn같은 효율적인 패키지 매니저를 함꼐 사용하면 포함된 페키지를 올바르게 레퍼런싱할 동안 디펜던시의 문제점들을 해결할 수 있다. 가장 중요한 커맨드는 lerna bootstrap, lerna run 그리고 lerna publish이다. 이것은 통합된 버저닝(모든 포함된 패키지는 같은 버전을 가진다)이나 독립적인 버저닝(모든 포함된 패키지는 자신의 버전을 스스로 결정한다) 기능을 가질 수 있다. 더 많은 정보는 https://lerna.js.org/ 에서 찾을 수 있다. 


일단 우리가 npm init -y를 사용해서 새로운 Node.js 프로젝트를 시작하게 되면, 우리는 lerna init을 사용해서 Lerna를 적절하게 통합할 수 있다. 이것은 독립적인 마이크로 프론트엔드들이나 다른 라이브러리들을 개발할 수 있는 패키지 폴더를 셋업할 수 있게 해준다.

Azure DevOps를 사용해서 CI 파이프라인을 모노레포에 더하는 것은 package.json 파일 옆에 있는 레포지토리의 루트에 azure-pipelines.yml 파일을 더하는 것처럼 쉽고 간단하다. 컨텐츠를 이것처럼 쉽다. 

trigger: 
- release 

steps: 
- task: NodeTool@0
  inputs: 
versionSpec: '10.x'
displayName: 'Install Node.js 10'
- bash: | 
npx lerna bootstrap
displayName: Bootstrap repository
- bash: | 
npx lerna run test
displayName: Run rests in all packages
- bash: | 
npx lerna run build
displayName: Run build in all packages



CircleCI의 경우에도 셋업은 비슷하다. 다만 차이점은 .circleci 디렉토리 안에 위치한 config.yml 파일을 이용한다. 이것은 다음 코드들을 갖고 있다.

version: 2 
workflows: 
  version: 2 
  default: 
    jobs: 
      - build: 
        filters: 
          branches: 
            only: release

jobs: 
  build: 
  docker: 
    - image: circleci/node:10

working_directory: ~/repo

  steps: 
  - checkout 
  - run: 
    command: npx lerna bootstrap
    name: Bootstrap repository
  - run: 
    command: npx lerna run test
    name: Run rests in all packages
  - run: 
    command: npx lerna run build
    name: Run build in all packages



이것은 레포지토리를 적절하게 셋업, 테스트 그리고 빌드 하기에 충분하다. 검증을 목적으로 할 때(예를 들어, 풀리퀘스트)에도 이것은 훌륭하지만 실제로 배포에 대해서는 충분하지 않다. 여기서 빌드 단계와 릴리즈 단계를 적절히 구분하는 단계를 생성할 수 있다. 

다수의 레포지토리 결합하기
모노레포는 메인터넌스의 많은 필요 없이 다수의 아티펙트들을 배포할 수 있는 가장 좋은 방법이다. 그러나 위대한 개발 확장성을 가능하게 하기 위해서는 다수의 레포지토리들을 도입할 필요도 있다. 이것이 반드시 각각의 레포지토리마다 전용 파이프라인을 셋업해야 할 필요가 있다는 것을 의미하진 않는다. 독립적인 레포지토리들은 중앙 집중적인 파이프라인을 유발하고 하나의 솔루션으로 코드들을 합친다.

이 솔루션의 이점은 개발과 심지어 유지가 명백하게 독립적이라는 것이고 그러나 하나의 통일성있는 솔루션이 CI 파이프라인에 의해 아직 생성될 수 있을 지도 모른다는 것이다. 심지어 우리가 마이크로 프론트엔드들을 독립적으로 사용한다면 중앙 집중적인 파이프라인을 사용해서 중요한 정보를 얻을 수 있고 전체 대비 솔루션들을 확인할 수 있다.

그림 3.2 는 각각의 분리된 레포지토리들로 부터 마이크로 프론트엔들이 하나의 파이프라인 안에 함께 들어갈 수 있는 방법을 보여준다. 궁극적으로 어디에서 코드 변화가 있던지 간에 하나의 빌드 안에서 모든 레포지토리들이 합쳐진다.

 
그림 3.2 어디에서 변화가 발생함에 상관없이 하나의 파이프라인 안에서 여러 개의 마이크로 프론트엔드들이 합쳐진다

이 접근의 단점은 아직 중앙 집중적인 파이프라인이라는 것이고 그것은 모든 정보들이 한 곳에 저장된다는 것을 의미한다. 만약 새로운 레포지토리들이 솔루션에 합쳐지면, 파이프라인은 레포지토리를 인지하기 위해 업데이트 될 필요가 있다.

Azure DevOps에서 작동하는 파이프라인 정의에 가능성 있는 접근은 다음과 같다.

resources: 
  repositories:
    - repository: Microfrontend1
      type: github 
      endpoint: GitHubServiceConnection
      name: ArtOfMicrofrontends/Microfrontend1
      trigger: 
        - release 
    - repository: Microfrontend2
      type: github 
      endpoint: GitHubServiceConnection
      name: ArtOfMicrofrontends/Microfrontend2
      trigger: 
        - release 
    - repository: Microfrontend3
      type: github 
      endpoint: GitHubServiceConnection
      name: ArtOfMicrofrontends/Microfrontend3
      trigger: 
        - release 

steps: 
- checkout: self
- checkout: Microfrontend1
- checkout: Microfrontend2
- checkout: Microfrontend3

- script: dir $(Build.SourcesDirectory)



여기서 파이프라인 그 자체는 CI 일을 만드는 다른 유틸리티나 스크립트들의 집합과 함께 온다. 서로 다른 레포지토리들은 (예를 들어, 다른 브랜치들이나 조건들을 트리거하기 위해서) 개별적으로 아직 적용될 수 있다. 그럼에도 불구하고 이러한 조정들은 중앙 집중적으로 다루어져야 하고 개별적인 팀들이 완전히 힘이 부여되지 않는 이유이다. 



CircleCI와 다수의 레포지토리들

기본적으로 이 기능은 제공되지 않는다. 해결 방법은 git clone을 통해 추가 레포지토리를 명시적으로 복제하고 중앙 파이프라인에서 해당 소스로 작업하는 것이다. 중앙 파이프라인을 트리거하기 위해서는 프로세스를 시작하는  CircleCI으로 부터 HTTP API를 사용하는 파이프라인들이 필요하게 된다.

개별적인 팀들에게 힘을 부여하기 위해서는 분산 배포가 유용하다.

분산 배포
배포 시나리오에 대해 다른 극단은 완전히 분산된 배포 시스템을 생성하는 것이다. 여기서 각각의 마이크로 프론트엔드는 각각의 CI 파이프라인을 만들어낼 필요가 있고 그것은 외부의 어떤 공급자라도 레버리지를 할 수 있다. 어떤 마이크로 프론트엔드들이 이용가능할 지에 대한 정보들이 중앙 집중적인 서비스나 어떤 연합된 접근에 의해 모여질 수 있다. 거기서 각각의 마이크로 프론트엔드 거울들은 레지스트리 안에서 인지된다. 이 레지스트리는 분산되어질 수 있다. 실용적인 시나리오들에서 그러한 레지스트리는 집중될 수 있다. 
분산된 배포의 큰 장점은 개별적인 마이크로 프론트엔드들의 독립에 있다. 그것에 의해 각각의 팀은 완전히 그들의 아티팩트에 대해 책임을 가질 수 있다. 이러한 명령어는 종이에 쓰여질 뿐만 아니라 실제로 어플리케이션 그 자체의 기본적인 셋업에 존재할 수 있다. 만약 팀이 적절한 릴리즈 파이프라인을 셋업하지 못하면, 어떠한 일도 일어나지 않고 그들의 기여는 절대로 알 수 없다.

중앙 집중적인 배포로 인해 두 가지의 시나리오를 볼 수 있다. 코드 베이스로써 모노레포를 사용하거나 전용 파이프라인을 구축하기 위해 개별적인 레포지토리들로부터 시작하는 것이다. 

모노레포 사용하기
모노레포의 케이스는 중앙 집중적인 배포 시나리오와 비슷한 방법에서 시작한다. 관련 파이크로 프론트엔드들을 하나의 코드 베이스에 집어넣는다. 여기서 차이점은 각각의 팀은 모노레포에 있는 그들의 마이크로 프론트엔드들에 대한 그들 자신의 CI 파이프라인을 호스트할 수 있다. 그렇게 함으로써 모노레포 안에서 세 개의 마이크로 프론트엔드들에 대한 세 개의 서로 다른 파이프라인들을 갖게 된다.

그림 3.3 은 개별적인 파이프라인들과 모노레포 사이의 관계를 보여준다. 모노레포에서 하나의 코드 변화는 모든 파이프라인을 유발한다. 종종 파이프라인이 유발되었을 때 가장 먼저 관련 코드 섹션에서 어떠한 변화가 있는 지 찾기 위해 가장 먼저 하는 것은 비교이다. 

 
그림 3.3 – 하나의 코드 변화는 계속 될 지 모르는 여러 파이프라인들을 유발한다

어떠한 변화를 감지하지 않으면서 릴리즈에 새로운 것이 없음에도 불구하고 모든 파이프라인이 릴리즈를 유발할 수도 있다. 이것은 처음에는 아무런 해가 없는 것처럼 보이지만 경제적(필요한 것보다 더 긴 CI 파이프라인을 돌리는 건 불필요한 비용을 의미한다), 사용자 경험(잠재적인 캐시를 무효화하여 어플리케이션이 시작되기 전에 사용자는 더 긴 시간동안 기다리게 된다), 그리고 보안(모든 배포는 이러한 취약점이 드물고 발생할 확률이 적음에도 공격자로부터 코드를 사이드로드할 수 있는 기회를 제공한다)에 대해 문제가 발생한다.

변화를 감지하는 가장 간단한 방법은 Lerna에서 개별적인 버저닝을 도입하는 것으로 해결할 수 있다. 이것은 lerna init –independent 를 사용해서 모노레포를 이니셜라이징 할 때 이것이 행해질 수 있다. 대안적으로 다음의 코드 스니펫처럼 lerna.json 파일에서 version 프로퍼티를 independent로 설정하여 바꿀 수도 있다. 

{ 
  "lerna": "2.11.0",
  "packages": [
  "packages/*"
  ], 
  "version": "independent"
}

독립적인 버저닝을 유지하여 그것의 배포된 마지막 버전과 우리가 관심 있는 마이크로 프론트엔드에 대해 버전 셋을 비교할 수 있다. 

대안으로는 소스들을 해시하거나 빌드 아티팩트의 해시 값을 비교하는 것이다. 전자는 조금 더 신뢰성이 떨어지지만 후자는 매우 더 비싸다. 왜냐하면 질문에 대답하기 전에 완전한 빌드를 돌려야 할 필요가 있기 때문이다.

이에 대한 잠재적인 방법은 모노레포를 여러 레포지토리로 분할하는 것이다. 

전용 파이프라인 사용하기
마이크로 프론트엔드들은 하나의 마이크로 프론트엔드 당 하나의 레포지토리를 사용할 때 빛을 보기 시작한다. 이는 가능한 많은 자유를 얻는 방법이다. 그러나 단점으로 모든 종류의 다른 결정들(예를 들어, 어떤 테스팅 프레임워크를 사용할 지, 어떤 사례를 따를 지, 어떤 네이밍 컨벤션을 고려할 지 등등)이 만들어져야 한다. 일반적으로 완전한 유연성과 자유를 갖는 것의 단점이 된다.

그림 3.4 는 이 시나리오에서 코드 레포지토리들과 CI 파이프라인들의 관계를 보여준다. 여기서 각각의 마이크로 프론트엔드 레포지토리 안의 코드 변화만 그것의 파이프라인의 시작을 유발한다.

 
그림3.4 – 각각의 레포지토리는 각자의 파이프라인을 갖으므로 완전히 독립된다

서로 다른 마이크로 프론트엔드들을 배포하기 위해 독립적인 파이프라인을 사용하기 시작했을 때, 솔루션을 최적화하거나 재결합하는 어떠한 빌드 시간 단계를 수행하는 능력 또한 잃어버리게 된다. 물론 이것이 어떤 서버에 대해 통합되긴 하겠지만 이것은 추가적인 로직을 필요로 할 것이다. 그러므로 이 시나리오에서는 마이크로 프론트엔드가 랜더링 시간에서 동적으로 결합되고 이것이 대부분의 사람들이 실제로 마이크로 프론트엔드의 기본적인 정의라고 생각한다. 

만약 빌드 시간에서 어떤 최적화들을 유지하기 원한다면 분산된 솔루션과 함께 중앙 집중적인 배포 접근을 결합하도록 노력해야 한다. 결론은 하이브리드한 접근이 될 수 있다. 

하이브리드 솔루션
주로 개발(dev) 팀의 관점에서 마이크로 프론트엔드를 도입하는 주된 이유는 확장성이다. 그러므로 요약된 대로 분산 배포 방향으로 가는 것이 자연스럽고 가장 큰 확장 영향을 미친다. 그럼에도 불구하고 하나의 이유에 대해서 하나의 레포지토리 안에서 배포되어야 하거나 적어도 개발되어야 하는 집합적인 마이크로 프론트엔드들이 있을 수 있다. 이제 하이브리드 솔루션이라고 이름지어진 마이크로 프론트엔드를 이용하여 배포를 하는 세 번째 방법에 대해 이야기해보자. 

하이브리드 솔루션들은 중앙 집중적인 배포 솔루션과 분산 배포 시스템 같이 양 극단의 장점들을 레버리지하려고 노력한다. 결과적으로 하이브리드 솔루션에서 오른 어려운 점들은 보통 두 솔루션들을 취하는 시도의 조합에서 오게 된다.

보통 하이브리드 솔루션으로 가는 이유는 마이크로 프론트엔드들의 집합에 대한 예정된 릴리즈를 할 수 있는 능력 때문이다. 대안은 어떤 마이크로 프론트엔드들의 변화가 있을 때 릴리즈를 유발하는 것이다. 두 가지 방법을 모두 살펴보고 잠재적으로 사용할 수 있는 영역들에 대해 살펴보자. 

예정된 릴리즈
이론적으로 모노레포들을 일반적인 레포지토리와 함께 결합할 수 있고 중앙 집중적인 배포는 독립적인 배포와 함께 합칠 수 있다. 일단 우리가 그렇게 하게 되면 많은 새로운 가능성들이 발생한닥 그리고 그것은 예정된 릴리즈에 대한 기회라고도 볼 수 있다. 

만약 우리가 서로 다른 조각들을 완벽하게 함께 맞추고 싶다면 예정된 릴리즈가 괜찮을 수 있다. 또한 이용 가능한 마이크로 프론트엔드들의 부분집합에 대한 예정된 릴리즈를 거는 것도 좋다. 

예정된 릴리즈의 가장 쉬운 방법은 매뉴얼하게 유발될 때에만 동작하도록 파이프라인을 셋업하는 것이다. 이 방법으로 우리의 릴리즈와 이 특정한 파이프라인을 시작하는 지에 대한 날짜를 결정할 수 있다.

대안으로는 매주 월요일 아침처럼 자주 그리고 자동적으로 릴리즈하는 것이다. 예를 들어 릴리즈 브랜치처럼 특정한 브런치가 기본적으로 사용되어 질 브랜치 셋업을 시간 트리거를 함께 결합할 수 있다. 그렇게 함으로써 자주 릴리즈 할 수 있지만 다음 릴리즈를 위해 적절하게 선택된 코드 부분만 릴리즈한다. 

다른 대안은 변화에 대해 릴리즈를 유발하는 것이다.

변화에 대한 트리거
변화에 대해 결합된 릴리즈 파이프라인의 시작을 트리거링하는 것은 매력적일 수 있다 특히 릴리즈를 표시하기 위해 전용 브랜치를 사용하면 더 유용할 수 있다.특히, 여기서 여러 개의 레포지토리들을 하나의 큰 파이프라인에 합치는 것을 고려하지 않을 것이고 그것은 곧 모노레포에 있는 마이크로 프론트엔드들의 부분집합이 대규모의 릴리즈 안에서만 고려되어야 한다는 것만 의미한다.

그림 3.5에 볼 수 있듯이 모노레포에서 오는 코어 마이크로 프론트엔드들과 다른 레포지토리들에서 오는 보조 마이크로 프론트엔드들 사이의 분할이 또한 CI 셋업에 반영되어 진다. 여기서 분산된 개발 형태를 활용할 수 있고 동시에 하나의 일관된 레포지토리 안에서 잘 패키징된 교차 문제를 유지할 수 있다.

 
그림 3.5 – 어떤 마이크로 프론트엔드들은 독립적으로 릴리즈 되지만 다른 것들은 결합해서 릴리즈 한다

예를 들어, 분산된 배포들과 중앙 집중적인 배포와 섞인 방법을 적용할 수 있는 곳은 사용된 디펜던시들에 대해 최적화를 수행하는 것이다. 빌드 타임에서 어떤 마이크로 프론트엔드들을 사용할 수 있도록 하는 것은 우리가 디펜던시 분석을 도입할 수 있도록 하고 새로운(또는 사용되지 않은) 공유된 디펜던시를 여는 것을 의미한다.

 
요약

이번 장에서는 마이크로 프론트엔드들과 가능한 다른 배포 전략들에 대해 배웠다. 어떻게 모놀리식한 릴리즈 사이클이 마이크로 프론트엔드에 적용되는 지 설명하는 중앙 집중적인 계획에 대해 배웠다. 분산 배포를 사용하여 모든 팀이 독립적으로 만들 수 있다. 

자주 여기서 중도를 택할 수 있다. 그것에 관해 하이브리드 솔루션이라는 예시를 다루었다. 여기서 각 팀에 필요한 독립성을 유지하면서 모든 교차 문제와 가장 중요한 마이크로 프론트엔드를 제어할 수 있다.

다음 단원에서는 어떤 마이크로 프론트엔드가 존재해야 하는 지에 대해 정의하는 것을 도와주는 도메인 분해에 관한 주제를 다룰 것이다. 도메인 분해는 본질적으로 적절한 팀 분리를 하는 데 도움을 준다. 




 
 
4 도메인 분해
이전 장에서 마이크로 프론트엔드가 다양한 배포 옵션을 제공하는 것을 배웠다. 어떤 모델을 사용할 지 어떻게 결정하나?와 같은 질문에 대한 답은 프로젝트의 기술 요구 사항과 팀 구성 사이 어딘가에 있다. 그래서 팀 구성을 최대한 활용하려면 개별 마이크로 프론트엔드의 범위를 식별하는데 필요한 적절한 전략이 필요하다. 도메인 분해가 이를 돕는다.

도메인 분해를 통해 관심 도메인을 독립적으로 개발과 배포를 할 수 있게 더 작은 조각으로 나누는 방법을 찾는다. 처음에는 간단하게 들릴 수 있지만 사실 상당히 복잡하다. 이 장의 핵심 내용이 기술적(혹은 실용적)이지 않지만 실제 수행 전에 주의 깊게 보고 적용 해야한다. 최종적으로 도메인 분해 전략은 솔루션 아키텍처 기반이 된다. 

개념을 완전히 이해하려면 먼저 도메인 주도 설계(Domain-driven-design, DDD) 원칙 소개부터 시작해야 한다. 여기서 우리는 도메인 주도 설계:소프트웨어 중심의 복잡성 해결(Domain-Driven Design: Tackling Complexity in the Heart of Software)의 저자 Eric Evans의 생각을 따른다. 그 후 관심사 분리(Separation of Concerns, SoC)를 논하고 두 가지 필수 분해 전략인 기술 전략과 비즈니스 중심 전략을 살펴본다. 마지막으로 가장 먼저 정의해야 하는 아키텍처 경계를 알아본다. 살펴볼 주요 주제는 다음과 같다. 

	도메인 주도 설계의 원리
	관심사 분리
	아키텍처 경계

도메인 주도 설계의 원리
도메인 주도 설계는 Eric Evans가 처음 대중화했다. 그는 책에서 자신의 비전에 따라 도메인 주도 설계를 구성하는 기본 원칙을 설명했다. 이 책은 많은 진실을 담고 있지만 아이디어의 대부분은 실제 프로젝트에 적용되지 않았다. 이 중 마이크로 프론트엔드에서 가장 중요한 개념을 살펴본다. 

마이크로 프론트엔드 관점에서 도메인 주도 디자인을 언급할 때 값 객체나 유비쿼터스 언어의 필요성을 고려하지 않는다. 대신 도메인 주도 디자인을 다음 두 가지에 대한 청사진으로 사용한다. 
	명확한 경계를 가진 마이크로 프론트엔드 정의
	경계를 설정하기 위한 전략 수립
도메인 주도 설계는 이전에 패키지(package)를 가리키던 용어인 모듈(module)을 사용했지만 이제는 이 유닛을 마이크로 프론트엔드(micro frontend)라 한다. 도메인 주도 설계는 바운디드 컨텍스트(bounded context)도 도입한다. 마지막으로 도메인 주도 설계는 컨텍스트 맵(context map)을 정의한다. 잠깐 떨어져서 각 영역을 개별적으로 살펴보자. 

모듈
모듈은 응용 프로그램에서 특정한 기능 모음을 위한 컨테이너 역할을 한다. 언급했듯이 도메인 주도 설계에서 모듈은 일반적으로 마이크로 프론트엔드 형태로 테이블에 제공된다. 그러나 여기에서 일반적인 표기법을 유지하는 것이 합리적이다. 결국 좋은 아키텍처는 특정 구현과 거의 관련이 없지만 실제로 여러 변형 속에서 작동한다는 것을 알 수 있도록 도와준다. 마이크로 프론트엔드에서 기능은 대부분 컴포넌트를 중심으로 설계한다. 

그러나 모듈은 특정 영역에 초점을 맞춘 전체 문제의 일부에 불과하다. 모듈의 일반적인 설계 원칙은 낮은 결합도와 높은 응집력이다. 그래서 마이크로 프론트엔드는 다른 마이크로 프론트엔드에 직접 의존하지 않고 하나의 문제를 해결하기 위한 단일 유닛을 나타내야 한다.
도메인 주도 설계는 어떤 것이 모듈이 될 수 있는지 찾는 데 도움을 주기 위해 바운디드 컨텍스트 개념을 도입했다.

바운디드 컨텍스트
바운디드 컨텍스트는 하위 도메인 기능의 경계를 정의하기 위해 사용한다. 이는 특정 도메인의 기능만 유효한 영역이다. 
이는 모듈과 비슷해 보이지만 실제로 상당히 다르다. 여러 모듈은 동일한 바운디드 컨텍스트 내에 있다. 바운디드 컨텍스트는 이것들을 연결시켜 주는 우산 역할을 하며 런타임 고려사항과 관련이 없다. 
다음 도표는 예제 관심 도메인 내에서 두 개의 바운디드 컨텍스트 관계를 보여준다.
 
그림 4.1 – 예제 관심 도메인에서 두 개의 바운디드 컨텍스트 관계
바운디드 컨텍스트를 모듈로 분할하는 방법은 사람에게 달렸다. 결국에는 관심 도메인에서 바운디드 컨텍스트가 무엇일까? 하는 것이 중요하게 된다. 여기에 청사진은 없지만 컨텍스트를 시각화하고 생각하기 좋은 방법은 컨텍스트 맵 형태를 이용하는 것이다.  

컨텍스트 맵
컨텍스트 맵은 시스템과 관련된 컨텍스트와 연결을 묘사하기에 유용한 도구이다. 다른 컨텍스트의 객체를 재사용하는 대신 항상 컨텍스트 맵에 정의된 변환을 사용하여 도메인별 객체를 생성해야 한다. 
컨텍스트 맵은 설계 결정을 위해 공유가 일어나는 곳과 격리된 마이크로 프론트엔드를 생성하는 방법을 확인하는데 도움을 줄 수 있다. 이를 위해 먼저 독립적인 도메인을 식별해야 한다. 여기에는 전략적 도메인 설계와 이에 대한 대안으로 전술적 설계라는 두 가지 방법이 있다. 두 가지 다 살펴보자. 

전략적 도메인 설계 대 전술적 설계
전략적 도메인 설계가 관심 도메인에 대한 지식을 확장하고 유용한 기준을 떠올리는 데 도움을 준다면 전술적 설계는 시스템을 구성하는 설계 패턴과 구성 요소를 생각하는 데 사용한다. 즉 전략적 도메인 설계는 서로 다른 도메인과 서로 간의 커뮤니케이션을 구분하지만 전술적 설계는 도메인을 구조화한다. 

마이크로 프론트엔드 세계에서는 전술적 설계를 마이크로 프론트엔드 개발자에게 맡기거나 그들에게 지침을 제공하거나 따라야 하는 구조를 미리 정의할 수 있다. 나중에 이러한 아키텍처 경계가 어떻게 결정되는지 살펴볼 것이다.

한편으로는 전략적 도메인 설계는 전체 관심 도메인을 더 작은 하위 도메인으로 세분화할 때 유용하다. 전체 관심 영역에서 개별 하위 도메인을 구분하고 바운디드 컨텍스트를 도출한다. 그런 다음 컨텍스트 간의 관계를 컨텍스트 맵에 기록한다. 다음 도표는 이론적 과정을 보여준다. 
 
그림 4.2 – 동작하는 컨텍스트 맵을 이용해서 전체 도메인 분해를 유도하는 이상적인 과정

다음과 같은 예제 과정을 이해해보자. 온라인으로 전환하려는 도서관이 있다. 그들은 대출자가 자신의 상태를 확인하고 방문자가 카탈로그를 검색할 수 있도록 만들고자 했다. 
여기에서 하위 도메인은 다음과 같다.
•	대출자 정보
•	대출 과정
•	예약 세부정보
•	책 카탈로그
이것이 전부다. 여기서 사용자 관리(또는 인증 및 권한 부여) 같은 보다 일반적인 기술을 추가할 수 있다. 그러나 초기에 관심 부분에 초점을 맞추는 것이 보다 합리적이다.
네 가지 하위 도메인에서 다음과 같은 바운디드 컨텍스트를 찾아낼 수 있다.
•	대출 사용자 정보
•	대출자 책 보유 정보
•	대출 과정
•	공공 도서 세부 정보
•	대출 도서 세부 정보
•	공공 도서 카탈로그
•	대출 책 카탈로그
대출 도서 세부 정보는 대출 정보를 도서 세부 정보와 연결하여 인증된 사용자에게 책을 대출할 수 있는 기간을 알려준다. 마찬가지로 대출 책 카탈로그는 이 정보를 카탈로그 수준에서 이용할 수 있도록 해준다. 
모든 바운디드 컨텍스트는 마이크로 프론트엔드가 될 필요는 없지만 합당한 이유 없이 컨텍스트를 넘어서는 것은 좋지 못하다. 관심 도메인을 너무 과감하게 분할하는 건 좋지 않다. 
이제 물러서서 어떤 종류의 분할이 실제로 의미가 있는지 확인해야 한다. 

관심사 분리
분할을 논의할 때 분할할 도메인보다 분할의 종류에 집중하는 상황에 놓이게 된다. 흥미롭게도 마이크로 프론트엔드가 시작되자 대부분의 사람들이 기술적인 분할에 열광했다. 그러나 마이크로 프론트엔드의 진정한 이점은 비즈니스 중심의 분할 결정에서 나타난다. 

두 가지 옵션의 공통점과 장점을 살펴보자.

기술적 분할
기술적 분할은 일반적으로 화면을 보고 웹 페이지에 선을 그리는 것으로 시작한다. 자연스럽게 아래 스크린샷에 표시된 그림과 가까운 형태로 끝난다.
 
그림 4.3 – 가능한 기술적 분할, 화면의 구성 요소는 그룹화하고 다른 마이크로 프론트엔드에 배치한다

기술적 분할의 문제는 각 마이크로 프론트엔드가 서로 다른 도메인의 일부를 포함한다는 것이다. 예를 들어 네비게이션 마이크로 프론트엔드는 주문 기능을 비롯한 사용자 관리에 대한 링크도 포함한다. 처음에는 괜찮아 보이지만 장기적으로 보면 문제가 된다. 네비게이션 마이크로 프론트엔드가 다른 모든 부분을 어떻게 알 수 있을까?

이런 아키텍처 결정에서 문제를 찾기 위한 좋은 방법은 특정 변경 사항을 추적하는 것이다. 예를 들어 마이크로 프론트엔드(예를 들어 결제 마이크로 프론트엔드)를 도입하면 다른 마이크로 프론트엔드를 건드려야 할 필요가 있을까? 만약 그렇다면 몇 개를 손봐야 하는가? 새로운 마이크로 프론트엔드 도입이 다른 모든 마이크로 프론트엔드 변경에 영향을 준다면 분명히 뭔가 잘못된 것이다. 이것은 아키텍처가 제대로 동작하지 않는다는 분명한 지표다. 

이상적으로는 새로운 마이크로 프론트엔드는 완전히 자체 격리된다. 따라서 다른 마이크로 프론트엔드를 변경할 필요가 없다. 이것이 기능 분할을 사용할 경우 얻을 수 있는 장점이다.
 
기능적 분할
애플리케이션을 기능적인 부분으로 나눈다면 하나의 화면이 단일 마이크로 프론트엔드에만 포함될 수 없다. 이런 식으로는 한 데이터 소스에서 다른 데이터 소스로 연결이 절대 없다. 또한 모든 상호 작용은 상대적으로 정적이고 효율적이지도 않다. 

기능적 분할의 문제는 매우 추상적이고 구현하기 어렵다는 점이다. 그 이유는 모든 것이 어느 시점까지 확장 가능해야 하기 때문이다. 
이 어려움은 실제 다음과 같은 모든 구현 단계에서 마주칠 수 있다.
•	디자인 작업은 모든 것이 확장될 수 있다는 점을 고려한다.
•	구현은 확장을 위한 공간을 마련해야 한다.
•	문서는 확장 지점을 언급해야 한다.
•	테스팅은 테스트하고 확정하기 위해 이 부분을 인지해야 한다.
•	배포 시스템은 올바르게 이를 연결하기 위해 이 부분을 이해해야 한다.

이런 어려움에도 결과는 납득할 만 하다. 그림 4.4에서 볼 수 있듯이 기능적 분할은 자연스럽다. 화면에 보이는 것으로 그룹화하는 대신 동일한 마이크로 프론트엔드 내에 일치하는 항목을 갖는다.
 
그림 4.4 – 가능한 기능적 분할의 예시. 스크린 위의 요소는 확장 가능하고 서로 다른 마이크로 프론트엔드로 구성된다
 
기능적 분할의 가장 좋은 점은 자가 분리 요구 사항을 즉시 충족한다. 하나의 마이크로 프론트엔드를 없애도 나머지는 직접적인 영향을 받지 않는다. 

현재 주문 장바구니 컴포넌트와 주문 버튼이 포함된 주문 마이크로 프론트엔드 예를 보자. 이 기능을 끄면 이 기능만 제거되고 다른 곳에 영향을 주지 않는다. 제품 페이지, 상품 추천 그리고 다른 부분들은 모두 정상이다. 기술적 분할로는 동일한 종류의 유연성을 달성하는 것이 거의 불가능하다. 

따라서 하위 도메인으로 그룹화하는 것은 기능적 분할을 통해 가능할 뿐만 아니라 실질적인 도움을 준다. 도메인 주도 설계는 이런 부분에서 유용한 도구가 된다. 이제 주문 바구니와 제품 추천이 같은 마이크로 프론트엔드에 있어서는 안된다는 것을 알고 있지만 문제는 주문 장바구니와 주문 버튼이 같은 마이크로 프론트엔드에 있어야 하는지 여부이다.

 
마이크로 프론트엔드가 얼마나 작아야 하는가에 대한 질문은 마이크로서비스에서 조차 논쟁의 여지가 있다. 확실한 건 크기를 측정하기 위해 일종의 지표(예를 들어 코드의 라인, 컴포넌트 등)를 만들기 보다 분할을 구성하기 위한 전략을 찾으려고 노력해야 한다. 이를 위해 다음과 같은 질문을 해야 한다.
•	모든 마이크로 프론트엔드의 컴포넌트를 동일한 팀이 개발하고 유지하는가?
•	모든 마이크로 프론트엔드의 컴포넌트는 모두 동일한 사용자가 이용하는가?
•	마이크로 프론트엔드의 컴포넌트를 조건부로 숨기거나 비활성화하는가?
•	마이크로 프론트엔드의 컴포넌트가 다른 조합에 더 적합한가?

이러한 질문을 통해 마이크로 프론트엔드를 구성하기로 한 결정이 적절한 지 확인한다. 예를 들어 한 컴포넌트는 관리자만 사용해야 하고 다른 나머지 컴포넌트에는 일반 사용자가 접근하는 경우 관리자만 접근 가능한 컴포넌트를 자체 마이크로 프론트엔드에서 제외하는 것이 합리적이다. 마찬가지로 사용자 테스트 측면에서 생각할 때(예를 들어 특정 스타일의 컴포넌트가 다른 컴포넌트 보다 선호되는 지 판단하기 위해 A/B 테스트를 실행할 때) 테스트의 일부가 돼야 하는 컴포넌트를 제거하는 것이 적절할 수 있다.

좀 더 구체적으로 설명하기 위해 예제를 살펴보자. 

분할 예제
온라인 쇼핑 애플리케이션을 예로 들어보자. 요구 사항으로서 다음 기능을 제공해야 한다. 

•	사용자 로그인 페이지
•	사용자 로그인 버튼
•	사용자 로그아웃 버튼
•	장바구니 페이지
•	제품 상세 페이지
•	제품 개요 페이지
•	특별 행사 페이지
•	제품 추천 칸
•	장바구니 정보/링크
•	제품 주문 버튼
•	유사 제품 칸
•	제품 비교 칸
•	내 계정 링크
•	내 계정 페이지
•	현재 사용자 정보 패널
•	중요 알림 패널
•	고객센터 페이지
•	고객 피드백 모달 대화 상자
•	고객 피드백 버튼

DDD의 테크닉(technique)을 사용하면 이러한 항목을 다른 바운디드 컨텍스트로 정리할 수 있다. 예를 들어 다음 항목으로 구성된 사용자 컨텍스트를 도입할 수 있다.

•	사용자 로그인 페이지
•	사용자 로그인 버튼
•	사용자 로그아웃 버튼
•	내 계정 링크
•	내 계정 페이지
•	현재 사용자 정보 패널

이 바운디드 컨텍스트에서 다음과 같이 최소한 두 개의 모듈을 추출할 수 있다.

•	사용자 로그인
•	사용자 계정

사용자 로그인 모듈에는 로그인 페이지와 로그인 버튼이 포함되며 익명 사용자에게 노출돼야 한다. 사용자 계정 모듈에는 로그아웃 버튼을 포함한 나머지가 포함되며 인증된 사용자에게 나타나야 한다.

그러나 이 바운디드 컨텍스트에 관한 두 번째 관점이 있다. 로그인/로그아웃 기능을 특정 도메인이 아니라 기술적인 것으로 간주하면 이 모든 것을 공통 관심 사항의 범주에 넣을 수 있다. 이렇게 하면 아래의 항목으로 바운디드 컨텍스트를 구성할 수 있다.

•	내 계정 링크
•	내 계정 페이지
•	현재 사용자 정보 패널

이 바운디드 컨텍스트는 단일 모듈로 구현할 수 있다. 나머지 기능은 일부 모듈에서 구현되지 않고 애플리케이션 자체에서 구현되는 기술 도메인의 일부이다. 

마이크로 프론트엔드에 대한 공통 관심 사항이 갖는 장점은 모든 마이크로 프론트엔드가 접근할 수 있다는 점이다. 예를 들어 인증을 중요 관심 사항으로 본다면 모든 마이크로 프론트엔드가 이름, 이메일 주소 또는 계정 상태와 같은 현재 사용자에 관한 정보를 얻을 수 있다. 

공통 관심 사항의 단점은 유지 관리를 위해 신중하게 발전해야 하는 공유 계층이다. 응용 프로그래밍 인터페이스(Application Programming Interface, API)거나 동작 내에 직접적이고 개별적으로 급격한 변경은 전체 어플리케이션의 광범위한 테스트를 통해서만 드러나는 결과를 갖는다. 
예제로 돌아가 다음과 같이 공통 관심 사항으로 간주될 수 있는 요구 사항이 네 개 더 있다.

•	중요한 알림 패널 
•	고객센터 페이지
•	고객 피드백 모달 대화 상자
•	고객 피드백 버튼

이제부터 다음과 같이 두 가지 바운디드 컨텍스트로 나눌 수 있다.

•	사용자 알림
•	고객 상호작용

알림 패널은 사용자 알림 컨텍스트에 있지만 고객 상호 작용은 두 개의 모듈로 구성할 수 있다. 고객센터 페이지(와 잠재적인 링크)를 포함하는 것과 고객 피드백과 관련된 모든 것이다. 

나머지 항목은 빠르게 구성된다. 제품 주문(장바구니 페이지, 장바구니 정보, 제품 주문 버튼), 제품(제품 세부 정보 페이지, 제품 개요 페이지, 유사 제품 페이지, 제품 비교 칸) 및 판매(특별 행사 페이지, 추천 제품 칸)에 대한 바운디드 컨텍스트를 정의한다. 그러면 이러한 컨텍스트를 마이크로 프론트엔드로 어떻게 분해할까?

제품의 시작할 바운디드 컨텍스트를 선택하자. 네 개의 항목을 다음 두 모듈 안에 둘 수 있다.

•	제품정보(제품 상세 페이지, 제품 개요 페이지)
•	제품관계(유사 제품 페이지, 제품 비교 칸)

한 가지 가능한 분해는 두 마이크로 프론트엔드에서 두 모듈을 갖는 것이다. 이 간단한 옵션은 확실히 좋은 시작이지만 아직 끝난 건 아니다. 

인증된 사용자에게만 제품 비교 페이지를 보여줘야 한다고 가정하자. 이 경우 실제로 제품 관계 모듈을 두 개의 마이크로 프론트엔드로 분할하는 것이 합리적일 수 있다. 하나는 모든 사용자가 볼 수 있고 다른 하나는 인증된 사용자만 볼 수 있다. 

마찬가지로 제품 개요 페이지는 A/B 테스트의 훌륭한 대상일 수 있다. 이 페이지는 확실히 많은 반복을 경험할 것이고 사용자가 클릭 그리고 잠재적으로 주문할 확률이 높은 것에 직접적으로 영향을 미칠 것이다. 이러한 경우 제품 개요 페이지를 마이크로 프론트엔드에 넣는 것이 이득이다. 이렇게 하면 A/B 테스트를 위해 요청 당 제품 개요 마이크로 프런트엔드 변화 A 또는 변화B를 보여줄 수 있다. 

보는 것과 같이 상당수의 결정은 주로 애플리케이션으로부터 예상하고 기대하고 요구하는 것을 기반으로 한다. 이러한 기대치를 기술적으로 확실하게 하려면 먼저 명확한 아키텍처 경계를 도입해야 한다. 

아키텍처 경계
아키텍처 경계를 이야기한다면 이미 코드 수준으로 들어간 상태다. 여기에서 도메인 모델을 넘어 아래에서 나열한 영역으로 이동한다.

•	마이크로 프론트엔드에는 어떤 기능이 있는가?
•	마이크로 프론트엔드의 구조와 디자인에 대해 얼마나 많은 자유를 제공하는가?
•	마이크로 프론트엔드가 사용할 수 있는 응용 프로그래밍 인터페이스(예: 문서 객체 모델(Document Object Model, DOM))은 무엇인가?
•	마이크로 프론트엔드가 애플리케이션에서 분리된 위치는 어디며 주변 시스템과 밀접하게 연결되어 있는가?

일반적인 경우 위의 문제에 대한 답은 상황에 따라 다르다일 것이다. 하지만 거의 모든 훌륭한 해결책에 적용하기 위해 고려할 사항과 명심해야 할 것을 생각할 수 있다.

올바른 수준의 자유도를 선택하기 위해 필요한 것을 결정하기 전에 공유된 기능부터 이야기하자. 문서 객체 모델(DOM)에 접근하는 예를 본 후 마이크로 프론트엔드의 보편성에 대해 논의하며 마무리한다.

공유된 기능
마이크로 프론트엔드를 생성할 때 다음과 같은 두 극단 사이에서 긴장을 느낄 수 있다. 

가)	모든 공유 기능과 코드를 공통 라이브러리 또는 마이크로 프론트엔드에 넣기
나)	아무것도 공유하지 않기 – 모든 마이크로 프론트엔드에 복사하거나 자체 솔루션을 마련해야 한다. 

양 극단은 다양한 의사 결정에서 나타나지만 기능 결정 관점에 중점을 두자. 

(가)의 장점은 모든 마이크로 프론트엔드가 문제 영역에만 집중할 수 있다는 것이다. 단점은 특히 공유 기능과 마이크로 프론트엔드 간의 느슨한 결합을 고려할 때 대규모 공유 코드 베이스의 변경은 자주 일어나며 고장을 유발한다는 점이다. 

(가)가 올바른 접근법이 아니라는 것을 알고 (나)를 선택할 수 있다. 그러나 모든 것이 무작정 복제되는 상황에서 결국에는 비슷한 위치에 놓이게 된다. 일부 공유된 기능에 오류가 있다는 것을 알게 되면 잠재적으로 모든 곳에서 수정해야 하므로 막대한 오버헤드가 발생한다. 

이를 벗어날 수 있는 두 가지 방법이 있다. 공유할 수 있는 모든 것을 공유하지 않고 몇 가지 정말 안정적인 핵심 기능만 공유하여 (가)와 (나) 사이 절충안을 택하거나 (가)를 채택하되 각 마이크로 프론트엔드에서 공유 기능을 작동하지 않도록 할 수 있게 하는 것이다. 이렇게 하면 오류가 발견된 곳에서 수정을 하고 모든 곳에 동일한 해결책을 적용해야 한다면 공유 기능을 활용해 모든 곳에 적용할 수 있다. 

그러면 공유 기능은 무엇일까? 다음과 같이 정의할 수 있다.

•	인증과 인가
•	권한 및 권리
•	기능 표시
•	기본 사용자 정보
•	네비게이션
•	로깅

물론 더 많은 공유 기능을 생각할 여지가 있지만 앞의 목록은 단순히 공유 기능으로 간주 될 수 있는 항목을 보여준다. 
이 시점에서 적절한 수준의 자유도를 선택하는 것이 중요하다는 것은 매우 분명하다. 하지만 적절한 수준이 어느 정도인지 어떻게 결정할까? 다음 부분에서 이를 살펴보자.

적절한 자유도 선택
적절한 자유도는 주로 다음 세 가지 요소에 의해 결정된다.

•	보안 – 우리는 마이크로 프론트엔드를 얼마나 신뢰하는가?
•	성능 – 얼마나 재사용해야 하는가?
•	팀 구성 – 개발자/팀은 어떻게 구성되어 있는가?

여기에 엄격한 우선 순위는 없고 다른 요소가 중요한 역할을 할 수 있다. 이런 것은 모두 프로젝트의 요구사항이 결정한다.

보안 영역에서는 마이크로 프론트엔드를 모든 프론트엔드 코드처럼 실행할 수 있는지 혹은 특별히 샌드박스 처리해야 하는지 여부를 결정해야 한다. 선택한 마이크로 프론트엔드 아키텍처에 따라 샌드박싱이 다소 문제가 될 수 있다. 여기서 가장 간단한 해결책 중 하나는 마이크로 프론트엔드를 <iframe>에 넣는 것이다. 마이크로 프론트엔드 구현자에게 샌드박싱은 DOM API 사용이 제한된다는 것을 의미한다. 따라서 가능한 빨리 샌드박싱 설정을 명확하게 전달하는 것이 중요하다. 

보안은 신뢰에 관한 것이다. 구성상의 이점 때문에 마이크로 프론트엔드를 도입했으나 동일한 팀 또는 관련 팀 내에서 모든 것을 개발하는 경우 보안이 주된 관심사가 아닐 수도 있다. 그러나 타사 개발자가 우리 페이지에 콘텐츠를 배치할 수 있도록 허용해야 한다면 보안은 매우 중요해진다. 

성능 영역은 정말 빠르고 신속하게 실행되는 응용 프로그램을 갖고자 하는 열망에 관한 것이다. 예를 들어 전자 상거래 웹 사이트의 경우 잠재적으로 가장 높은 우선 순위 중 하나가 될 수 있지만 포털과 같은 도구의 경우 순위가 낮다. 우선 순위와 상관없이 뛰어난 성능을 얻으려면 렌더링을 최대한 간소화해야 한다. 여기에는 가능한 가장 적은 수의 프론트엔드 프레임워크를 선택하고 초기 렌더링에 필요한 가장 적은 수의 에셋을 선택하는 것이 포함된다. 

좋은 렌더링 성능을 달성하는 가장 쉬운 방법은 마이크로 프론트엔드당 성능 예산을 가진 마이크로 프론트엔드로 구성된 서버 사이드 방식을 사용하는 것이다. 각 마이크로 프론트엔드는 사전 할당된 예산 범위 내에서 테스트되며 설정된 임계값을 초과하면 이를 사용할 수 없다. 다른 유형의 마이크로 프론트엔드의 경우 상황이 조금 더 복잡하지만 나중에 더 자세히 알아보자.

팀 구성 영역에서 어떤 종류의 개발자가 마이크로 프론트엔드를 작성할 것인지 알아야 한다. 주니어 개발자가 적합할까 아니면 정말 실력 있는 개발자가 좋을까? 전자의 경우 자유도가 적은 환경에서 필요할 때 가이드를 줄 수 있으면 좋지만 후자에게는 많은 자유도가 주어진 환경이 좋다. 어떤 개발자인지 모르는 경우라면 주니어 개발자라는 방향으로 기울면서도 중간 지점을 유지하는 것이 좋다. 이렇게 하면 한 시름 덜 수 있다. 

자유도의 한 가지 예로 마이크로 프론트엔드에서 DOM에 접근하는 것이 있다.    

DOM 접근
마이크로 프론트엔드에 일부 자바스크립트가 포함되어 있다고 가정하자. 다음 장에서 배우겠지만 클라이언트 측에서 구성된 마이크로 프론트엔드의 경우 항상 그러지만 서버 사이드로 구성된 마이크로 프론트도 일부 자바스크립트로 구성될 수 있다. 자바스크립트이기 때문에 다음을 포함하는 모든 작업을 수행할 수 있다.

•	웹 사이트에 키로거(keylogger)를 설치하여 각 키스트로크(keystroke)를 일부 서버로 보내기
•	사이트의 모든 링크를 잠재적인 피싱 웹사이트로 변경하기
•	로그인을 포함한 양식 제출 가로채기

아주 끔찍하지 않은가? 이를 방지하려면 가능성 있는 DOM 접근을 제한해야 한다. 이미 설명했듯이 가장 간단한 솔루션은 실제 다음과 같이 보일 수 있는 샌드박싱 속성을 설정하는 <iframe>이다. 

<iframe 
  sandbox="allow-same-origin allow-scripts allow-popups 
    allow-forms" 
  src="/some-microfrontend.html"></iframe> 

샌드박스 속성을 사용하면 모든 기능이 허용되지 않기 때문에 기능을 사용하기 위해 명시적으로 켜야 한다. 이 경우 마이크로 프론트엔드는 상위 프레임처럼 동일한 소스와 통신하고 자바스크립트를 가져오고 팝업을 사용하고 양식 제출을 허용할 수 있다. 

보안을 향상시킬 수 있는 두 가지 방법이 있다. 사용자 쪽에서 뭔가(중간자 공격 같은 것)가 유입되고 있다고 생각될 경우 이를 막기 위해 SRI(Subresource Integrity)를 사용하는 것이다. 


접근을 제한하는 또 다른 일반적인 방법은 콘텐츠 보안 정책을 의미하는 CSP(Content Security Policy)를 사용하는 것이다. 여기서 HTTP(Hyper Text Transfer Protocol) 헤더는 실제로 허용되는 항목과 허용되지 않는 항목을 정의한다. 콘텐츠 보안 정책은 콘텐츠에 관한 것이므로 DOM API를 실제로 제한할 수는 없다. 그러나 다양한 종류의 리소스(예: 사진, 스타일 시트, 문서 등)의 출처를 제한할 수 있다. 또한 eval과 같은 안전하지 않은 API의 사용을 포함하는 인라인 스크립트를 적극적으로 방지할 수 있다. 

마지막으로 우리가 할 수 있는 또 다른 일은 웹 작업자에 한에서만 스크립팅(scripting)을 허용하는 것이다. HTML(HyperText Markup Language)을 전송하기 전에 HTML을 수정하고 작은 인라인 스크립트로 교체한다. 새로운 스크립트는 웹 작업자를 만들고 허용된 상호작용을 수행한다. 이 방법은 HTML에 액세스 할 수 있으며 마이크로 프런트엔드가 다른 곳에서 서비스되는 경우에는 작동하지 않는다고 가정한다. 

인라인 스크립트 코드는 다음 예제와 같이 간단하다.
if ('Worker' in window) {
  var worker = new Worker('/previous_script_url_here.js'); 
  worker.onmessage = function (e) { 
    try { 
      var msg = JSON.parse(e.data); 
      switch (msg.type) { 
        case 'change_text';
          document.querySelector(msg.selector).textContent 
            = msg.text; 
        break; 
      // more APIs here. 
      default: 
        console.warn('Unrecognized message type.', msg); 
        break; 
      } 
    } catch (ex) { 
      console.warn('Unrecognized message format.', ex); 
    } 
  }; 
}


예제에서는 API 검사와 함께 ECMAScript5(ES5)를 사용하여 구형 브라우저에서의 오류를 방지했다. 이 기술을 사용한다면 적절하게 대체와 API도 통신해야 한다.

자유도는 마이크로 프론트엔드를 한 시스템에서 다른 시스템으로 얼마나 쉽게 전송할 수 있는지 즉 재사용 가능성에도 영향을 미친다.

마이크로 프론트엔드의 보편성
마이크로 프론트엔드의 재사용성은 보편성이라는 범주에 속한다. 마이크로 프론트엔드를 정말 보편적인 방식으로 사용할 수 있다면(다시 말해 공통점은 없지만 비슷한 경계 조건을 갖고 있는 다른 시스템의 경우) 운이 좋은 상황이다. 이 상황에서는 다른 컨텍스트에서 사용할 수 있는 뛰어난 빌딩 블록을 만든다. 이러한 빌딩 블록을 여러 개 생각하면 새로운 웹 애플리케이션을 즉시 조립할 수 있다. 

그러나 이러한 보편성을 취하려면 마이크로 프론트엔드를 실행하기 위한 요구사항과 관련된 적절한 균형을 찾아야 한다(예를 들어 주변 시스템이 필요로 하는 공유 기능은 최소화해야 한다). 공유 기능은 모든 범용 마이크로 프론트엔드를 실행하는 시스템의 요구사항을 설정한다. 

마찬가지로 보안 측면에서도 주변 시스템을 매우 엄격하게 고려해야 한다. 보편적인 마이크로 프론트엔드를 다루기 때문에 잠재적인 대상 시스템을 알지 못하므로 가능한 엄격하게 만든다. 보편성을 포기하고 잘 알려진 몇 가지 시스템을 목표로 삼으면 모든 요구 사항을 완화할 수 있다. 

범용 마이크로 프론트엔드는 순수한 마이크로 프론트엔드에 매우 가깝다. 일부 기본 요구 사항 외에도 모든 기능을 제공한다. 따라서 범용 마이크로 프론트엔드는 프론트엔드 기반 SaaS(Software-as-a-Service) 제품을 보여줄 수 있는 훌륭한 대안이 된다. 이러한 예는 챗봇, 빠른 사용자 피드백 또는 쿠키 동의 대화 상자가 있다. 모두 범용 마이크로 프론트엔드로 구현되며 대부분 로더 스크립트를 통해 구현되어 프론트엔드가 호스팅되는 iframe을 생성한다.  

 
요약
이 장에서는 마이크로 프론트엔드의 실제 구현만큼이나 개념적 정렬과 구성이 중요하다는 것을 배웠다. 결국 도메인 분해는 팀을 구성하고 API를 정의하며 여러 모듈에 기능을 할당하는 데 필요한 경계를 제공한다. 

도메인 주도 설계의 기본 용어와 이것이 컨텍스트 맵이 구별된 하위 도메인에서 파생된 다양한 바운디드 컨텍스트를 구성하는데 어떻게 도움을 주는지 배웠다. 도메인 주도 설계는 기술에 국한되지 않는 언어를 사용하여 모든 것을 작은 조각으로 만들어 구현 방식을 독립적으로 선택할 수 있도록 만들어 준다. 

또한 명확한 관심사 분리와 엄격한 아키텍처 경계가 명확한 팀 책임과 보다 세분화된 모듈로 이어진다는 사실도 배웠다.

다음 장에서는 사용 가능한 마이크로 프론트엔드 유형, 존재하는 유형과 사용해야 하는 시기에 대해 알아본다. 


 
섹션 2: “꿀 만들기” – 마이크로 프런트엔드 아키텍처 구현
이 섹션에서 독자들은 사용 가능한 아키텍처 패턴, 구현, 변형, 애플리케이션, 유지보수, 장점, 단점 및 일반적인 도전 과제에 대한 심도 있는 지식을 얻을 것이다.

이 섹션에서 다룰 내용은 다음과 같다.
•	제 5장, 마이크로 프론트엔드 아키텍처의 종류
•	제 6장, 웹 접근 방식
•	제 7장, 서버 사이드 구성
•	제 8장, 에지 사이드 구성
•	제 9장, 클라이언트 사이드 구성
•	제 10장, SPA 구성
•	제 11장, 사이트리스 UI
 
 
5 마이크로 프론트엔드 아키텍처의 종류

마이크로 프론트엔드가 프로젝트에 도움이 될 수 있다는 사실에 이제 확신이 들 것이다. 그러나 실제로 그것을 구현하기 전에 어떤 것이 미리 수행되어져야 한다. 이전 단원에서 배웠듯이 도메인을 적절하게 분해하는 것이 가장 중요하다.

일단 기초에 대해 다뤘으니 구현 옵션을 살펴볼 차례다. 종종 어플리케이션을 구현하는 방법은 꽤나 명백하다. 그러나 대부분의 경우 가이드나 모범 사례를 가장 먼저 살펴보는 것이 현명하다.

많은 종류의 마이크로 프론트엔드 아키텍처가 있다. 마이크로 서비스를 보게 되면 마이크로 프론트엔드에 대해 상황이 훨씬 더 세분화된 것처럼 느껴진다. 이러한 세분화의 이유 중 하나는 프론트엔드가 제어할 수 있는 많은 옵션을 주기 때문이다. 예를 들어 모든 것을 서버 사이드에서 렌더하거나 클라이언트 사이드에서 할 수 있다. 또한 혼합된 접근 방식을 취할 수도 있다.

이 장에서는 먼저 마이크로 프론트엔드 구현의 현재 환경을 이해하려고 노력한다. 그리고 나서 구체적으로 세 가지의 중요한 구현 프로퍼티를 다룰 예정이다. 이 단원에서 다룰 주제는 다음과 같다.
•	마이크로 프론트엔드 환경
•	정적 vs 동적인 마이크로 프론트엔드
•	수평적 – 수직적으로 구성된 마이크로 프론트엔드
•	백엔드 vs 프론트엔드 주도 마이크로 프론트엔드

이것은 사용할 수 있는 의사 결정 트리를 제공한다. 세 가지의 핵심 결정을 다루고 일곱 가지의 고유한 솔루션을 배운다. 개별 솔루션의 장점과 단점, 사용 영역 그리고 높은 수준의 구현 디테일에 대해 논의한다.

마이크로 프론트엔드 환경에 대한 지식을 얻는 것으로 시작하자.

기술적인 요구사항
이 단원에 필요한 모든 코드 파일들은 https://github.com/PacktPublishing/The-Art-of-Micro-Frontends/tree/main/Chapter05에서 찾을 수 있다. 이 단원에 대한 비디오는 https://bit.ly/2Tv6bkZ에서 찾을 수 있다. 

마이크로 프론트엔드 환경
이것을 이미 알고 있거나 조만간 이 책을 읽으면서 깨닫게 될 것이다. 마이크로 프론트엔드는 새로운 아이디어가 아니다. 실제로 아주 오래된 아이디어이고 심지어 마이크로서비스나 서비스 기반 아키텍처(SOAs)라는 개념이 만들어진 것보다 오래 됐다. 다만 가능성과 기대치가 달라졌을 뿐이다. 오래된 아이디어에 새로운 이름을 부여하는 것은 관심을 끌기 위한 쉬운 속임수였고 실제로 효과가 있었다. 
웹을 넘어서 많은 유저 인터페이스(user interface, UI) 기술에서 가장 기본적인 패턴으로서 플러그인 아키텍처가 있다. 마이크로소프트의 오피스 어플리케이션 같은 아주 유명한 어플리케이션이 이러한 기술을 아주 일찍부터 사용했다. 마이크로 프론트엔드에는 약간의 차이가 있었지만 비슷한 목표와 도전 과제가 있었다. 결과적으로 플러그인 아키텍처는 웹 프레임워크에서 아주 옛날부터 유명했다. 

오늘날 플러그인 아키텍처는 아직 매우 유명하고 거의 모든 대규모의 어플리케이션이나 프레임워크 혹은 툴에도 필수적인 포인트를 제공한다. 익스텐션(Extension)이 없는 비주얼 스튜디오 코드(Visual Studio Code, VS Code)는 존재할 수 있을까? 로더(loader)나 플러그인(plugin)이 없는 웹팩을 상상할 수 있나? 바벨(Babel)이 프리셋이나 플러그인을 허락하지 않는다면?

오늘날에는 많은 플러그인 아키텍처 구현이 런타임 메커니즘이지만 그 중 일부는 어플리케이션의 재시작이나 리컴파일을 필요로 한다. 그러나 마이크로 프론트엔드에 대한 매력은 단일 소프트웨어 디자인 패턴을 사용하여 얻은 것이 아니라 사용된 구현에 대한 개방성을 통해 얻었다. 

잠재적인 구현을 항상 염두해 둔다면 마이크로 프론트엔드를 타입을 고르는데 영향을 주는 적어도 세 가지의 중요한 결정이 있다. 우리는 마이크로 프론트엔드의 사용, 팀 셋업 뿐만 아니라 어디에 구성을 할 것인지에 관한 동적 유형에 대해 알아야 한다. 

결과는 아래의 다이어그램에서 보이는 것처럼 마이크로 프론트엔드의 분류에 대한 3차원의 위상 공간이다. 

 
그림 5.1 – 마이크로 프론트엔드의 종류를 분류하는 3차원의 위상 공간. Siteless 같은 패턴은 그들의 중요한 속성값에 따라 나타난다

위상 공간은 다음 장에서 다룰 패턴을 포함한다. 이러한 패턴의 위치가 과학적으로 정확하진 않다. 구체적인 구현 속에서 하나의 극단으로부터 더 일반적인 중간 값까지 값을 가져오려고 항상 노력한다. 예를 들어 이 예시는Siteless를 프론트엔드에서 구성될 동적 수직 아키텍처를 보여주지만 그것은 백엔드에서 완전히 렌더링되거나 약간의 서버 사이드 렌더링(SSR)으로 향상될 수 있다. 어떤 방법이든 그것은 오른쪽으로 옮겨질 수 있다. 마찬가지로, 마커(marker)를 낮추기 위해 팀을 약간 다르게 구성할 수 있다. 

이제 우리의 첫 번째 축인 정적 대 동적 마이크로 프론트엔드와 같이 양 극단에 대해 논의해보자.

정적 대 동적 마이크로 프론트엔드
마이크로 프론트엔드를 구현하는 가장 간단한 방법 중 하나는 개발을 빌드 타임에서 하나로 합쳐지는 여러 개의 패키지로 분해하는 것이다. 그러나 이것은 마이크로 프론트엔드의 완전히 정적인 사용이다. 

정적 접근의 가장 중요한 이점은 모든 정보를 빌드 시간에 알게 된다는 것이다. 따라서 가능한 최적화, 더 깊은 통합 그리고 강화된 확인을 해야 한다. 더욱 빠르고 안정적인 어플리케이션은 이러한 접근을 사용하여 구현될 수 있다. 

정적 접근의 주된 불리한 점은 추가나 제거 같은 마이크로 프론트엔드의 중요한 변경은 메인 어플리케이션의 변경을 필요로 한다. 추가적으로 어떠한 변경조차 전체 어플리케이션의 재빌드를 유발한다. 

정적 마이크로 프론트엔드 솔루션의 주요 사용 사례는 천천히 변경되는 웹사이트나 상대적으로 작은 웹 어플리케이션이다. Bit가 하나의 프레임워크 예시이다. 

가장 쉬운 경우는 마이크로 프론트엔드 솔루션은 하나의 엔트리 포인트를 갖는 다양한 패키지만 포함한다. 이것을 설명하기 위해 Express와 Node.js를 사용한 간단한 예시를 살펴보자. 여러 마이크로 프론트엔드 패키지와 함께 제공되는 하나의 서버 솔루션을 전송하기 위해 모노레포(monorepo)를 설정하고 사용할 것이다. 아이디어는 모노레포 없이도 작동한다. 이러한 경우 개인 또는 공용 npm(Node Package Manager) 레지스트리에 배포된 패키지를 사용한다. 

중요한 노트

공용 npm 레지스트리는 https://registry.npmjs.org 에 위치해 있고 공짜로 패키지를 퍼블리싱할 수 있다. 단점은 모두가 패키지를 공개적으로 사용할 수 있다. Azure DevOps 같은 어떤 지속적 통합 제공자는 무료 개인 npm 레지스트리를 준다. 대안적으로, Verdaccio 같은 오픈 소스 솔루션을 어떤 환경 속에서도 간단한 npm 레지스트리 서버를 호스트하는 데 사용할 수 있다. 더 많은 정보는 https://verdaccio.org/에서 찾을 수 있다. 


이 솔루션을 생성하기 위해서는 다음 명령어들을 실행해야 한다. 

# Create the Node project
npm init -y

# Make it a Lerna monorepo
npx lerna init

# Add the application itself
npx lerna create @aom/app --yes

# Add some (e.g., 2) microfrontends
npx lerna create @aom/mife-1 --yes
npx lerna create @aom/mife-2 --yes

# Register the dependencies
npx lerna add @aom/mife-1 --scope @aom/app
npx lerna add @aom/mife-2 --scope @aom/app
npx lerna add express pug


이제 메인 어플리케이션은 일부 경로와 어플리케이션 기본 사항을 등록하거나 그렇지 않을 수 있다. 요점을 유지하면 다음과 같이 끝난다. 

const express = require("express");
const app = express();
const port = process.env.PORT || 1234;

app.set("view engine", "pug");

// just an index page "/"
app.get("/", (_, res) => {
  res.render("index", { title: "Sample", message: "Index" });
});
 
// set up the microfrontends
require("@aom/mife-1")(app);
require("@aom/mife-2")(app);

app.listen(port, () => {
  console.log(`Running at ${port}.`);
}); 

다른 페이지는 마이크로 프론트엔드에서 모두 통합된다. 그들의 결합 포인트는 간단한 설정 함수이다. 마이크로 프론트엔드 1에 대해서는 다음과 같다.

const path = require("path");
const express = require("express");

module.exports = setupMicrofrontend1;

function setupMicrofrontend1(app) {
  app.use("/mf1", express.static(path.join(__dirname, "..",
    "public")));

  app.get("/mf1", (_, res) => {
    const page = require.resolve('../views/index.pug');
    res.render(page, { title: "Sample", message: "MF1" });
  }); 
} 

이것은 우리가 필요한 모든 것을 준다. 통합 지점이 있지만 마이크로 프론트엔드에서 거의 독립적이다. 그러나 여기서 할 수 있는 모든 것은 완전한 URL(Uniform Resource Locators)에 대한 핸들러를 만드는 것이다. 다음 단원에서 이것이 실제로 마이크로 프론트엔드 구현에 대한 적절한 기초가 될 수 있다는 것을 보여준다.

앞의 접근 방식의 한 가지 문제는 경로(예를 들어, 보기)에 주의할 필요가 있다는 것이다. 모놀리식에서는 상대 URL을 던져서 views 디렉토리에 대해 작동하도록 만들 수 있다. 이제 다른 어플리케이션 내에서 실행되는 자체 패키지에 있으므로 그렇게 할 수 없다. 불행하게도 많은 작업 없이 상황에 맞는 경로 확인 방법이 없다. 현재 접근 방식은 절대 경로를 사용하는 것이다. 

중요한 노트

상용구 또는 템플릿 코드 기반으로 새 프로젝트를 시작하는 기술은 꽤 유명하다. 일반적으로 이 기술을 스캐폴딩(scaffolding)이라고 하며, 모범 사례에 따라 새 프로젝트로 등장하기 위해 사용자 지정 속성을 알려진 작업 솔루션으로 이전하는 것을 고려한다.

다른 한편으로는 동적 접근 방식은 구현하기 훨씬 어렵다. 해결해야 할 세 가지 과제가 있고 다음과 같이 요약할 수 있다.
•	소스에 마이크로 프론트엔드를 게시하는 방법
•	소스 업데이트 방법
•	애플리케이션을 소스에 연결하는 방법

동적 접근 방식의 주요 이점은 마이크로 프론트엔드를 요청 별로 선택할 수 있어 개발자에게 많은 자유를 제공한다는 것이다. 또한 마이크로 프론트엔드의 업데이트는 메인 애플리케이션을 방해하지 않고 계속해서 일어날 수 있다.

주요 단점은 복잡성과 느슨한 결합으로 인해 애플리케이션이 더 취약해진다는 것이다. 여기에 도움이 되는 추가 도구 및 오류 경계가 있지만 인프라 수준에서 더 많은 복잡성이 추가된다.

동적 마이크로 프론트엔드 솔루션의 주요 사용 사례는 개인화된 웹 사이트 또는 더 큰 웹 애플리케이션이다. 여기에 있는 한 가지 예제 프레임워크는 webpack의 모듈 연합(Module Federation)이다.

동적 및 정적 마이크로 프론트엔드 사이의 결정은 대부분 프로젝트의 요구 사항에 따라 결정되지만 다른 결정은 예상되는 팀 구조를 살펴봄으로써 이루어진다. 이에 대한 예는 수평적 접근과 수직적 접근 사이의 결정이다.

수평 대 수직 구성 마이크로 프론트엔드
마이크로 프론트엔드는 뷰 별로 생성할 수 있을 뿐만 아니라 여러 팀이 동일한 뷰에 기여하는 구성 방식으로 생성할 수 있다. 전자는 수평적 접근, 후자는 수직적 접근에 해당한다. 수평적 접근 방식에서 마이크로 프론트엔드는 일반적으로 다른 하위 도메인에서 온 사람들에 의해 개발된다. 

다음 스크린샷은 일반적인 수평 접근 방식을 보여준다.

 
그림 5.2 – 수평적인 접근에서 다수의 팀들은 여러 개의 페이지를 전달하고 각각의 페이지는 여러 개의 피처들로 구성되어 있다

수평적 접근의 주요 장점은 추론하기가 매우 쉽다는 것이다. 모든 마이크로 프론트엔드는 단독으로 개발될 뿐만 아니라 어떤 방식으로든 격리된 웹 애플리케이션으로 가장 자주 발견된다.

수평 접근 방식의 주요 단점은 확장성이 좋지 않다는 것이다. 대부분의 웹사이트는 일부 페이지에서 여러 하위 도메인의 부분을 사용하지만 수평적 접근 방식은 이를 가능하게 하기 위해 마이크로 프론트엔드끼리 결합하는 것을 긍정적으로 생각하진 않는다.

수평적 마이크로 프론트엔드 솔루션의 주요 사용 사례는 콘텐츠가 많은 웹 사이트 또는 단일 사용 사례 페이지이다. 여기에서 한 가지 예제 프레임워크는 Podium이다.

이와 대조적으로 수직적 접근 방식은 진정한 교차 기능 팀을 사용하여 단일 하위 도메인에 대한 지식만 필요한 마이크로 프론트엔드를 개발한다. 여기서 복잡성은 대부분 디버깅 및 확장이 가능한 시스템을 제공하는 데 있다.

다음 스크린샷은 일반적인 수직 접근 방식을 보여준다.

 
그림 5.3 – 수직적인 접근에서 여러 팀은 여러 피처들을 전달하고 그것들은 여러 페이지에 뿌려진다.

수직적 접근 방식의 주요 이점은 문제 영역을 원하는 만큼 더 작게 분할할 수 있어 단일 마이크로 프론트엔드의 단일 하위 영역에 집중할 수 있다는 것이다. 결과적으로 일부 페이지는 여러 마이크로 프론트엔드로 구성된다.

수직적 접근 방식의 주요 단점은 기존 페이지 제공에 집중하지 않으면 개발자가 작업을 복잡하게 만들 수 있다는 것이다. 많은 화면에서 여러 마이크로 프론트엔드의 디버깅이 필요하기 때문에 이는 애플리케이션 디버깅 기능에도 영향을 미친다.

수직 마이크로 프론트엔드 솔루션의 주요 사용 사례는 대규모 웹 애플리케이션과 웹 포털이다. 여기에서 한 가지 예제 프레임워크는 Piral이다.

수평적 접근과 수직적 접근은 마이크로 프론트엔드의 유형을 선택할 때 중요한 역할을 할 수 있는 유효한 구별을 제시한다. 훨씬 더 중요한 것은 구성 영역으로서 백엔드와 프론트엔드 간의 결정이다.

백엔드 대 프론트엔드 주도 마이크로 프론트엔드
대부분 마이크로 프론트엔드 접근 방식에 대한 논의는 거의 고전적인 “서버 사이드 렌더링(SSR)대 클라이언트 사이드 렌더링(client-side rendering, CSR)” 주제로 시작한다. 일부 주장은 모놀리식에도 적용되지만 마이크로 프론트엔드에만 적용되는 다른 주장도 있다.

중요한 노트

SSR 대 CSR에 대한 논의는 비교적 새로운 축에 속한다. 자바스크립트 프론트엔드 프레임워크가 CSR에 사용할 수 있을 뿐만 아니라 대부분의 상황에서 적극적으로 활용해 볼 수 있는 만큼 강력해진 이례로 이 옵션은 간단할 뿐더러 최소한의 인프라 복잡성과 뛰어난 확장성을 제공한다. 그럼에도 불구하고 정말 빠른 웹사이트의 경우 사전 렌더링 또는 SSR과 CSR의 혼합이 최적일 것이다

종종 서버 사이드 마이크로 프론트엔드라고 불리는 백엔드 마이크로 프론트엔드는 마이크로 프론트엔드 구현의 첫 번째 유형 중 하나다. 그중 한 가지 이유는 SSR이 동적 웹 사이트를 활성화하는 원래 방법이기 때문이다. 또 다른 이유는 필요한 기술이 마이크로 프론트엔드용으로 이미 오래전부터 있었기 때문이다. SSI(Server Side Include) 및 후속 ESI(Edge Side Include)를 사용하면 이 두 가지 가능성이 오랫동안 존재했다.

백엔드 접근 방식의 주요 이점은 마이크로 프론트엔드의 전달이 쉽다는 것이다. 대부분의 경우 인지된 성능은 모놀리식과 동일하다. 또한 자바스크립트가 아닌 사용자 및 로봇의 경우 전달에 이미 핵심 정보가 포함되어 있다.

백엔드 접근 방식의 주요 단점은 확장성과 안정성을 유지하기 위해 상당히 복잡한 인프라가 필요하다는 것이다.

백엔드 마이크로 프론트엔드 솔루션의 주요 사용 사례는 전자 상거래 웹사이트와 콘텐츠 포털이다. 여기에서 프레임워크의 한 예는 Mosaic 9이다.

빌드 타임 통합 마이크로 프론트엔드 솔루션에 대한 이전 샘플 코드로 돌아가 보자. 뷰의 동적 라우팅을 사용하여 이를 서버 솔루션으로 수정할 수 있다. 이 경우 애플리케이션은 일종의 마이크로 프론트엔드 뷰 게이트웨이 역할을 하는 반면 각 마이크로 프론트엔드는 더 이상 패키지가 아니라 전용 포트에서 실행되는 자체 애플리케이션이다.

다시 말해 다음을 변환한다.
•	애플리케이션 게이트웨이가 포트 1234에서 돌아가는 app
•	우리의 어플리케이션이 포트 2001에서 돌아가도록 mife-1
•	우리의 어플리케이션이 포트 2002에서 돌아가도록 mife-2

설명을 위해 Application Gateway의 조회는 지금 정적 상태로 유지될 수 있다. 다음 장에서 더 역동적이고 강력하게 만들 것이다.

두 개의 마이크로 프론트엔드의 경우 다음 코드 스니펫에서 볼 수 있듯이 정적 조회는 매우 간단하다.

const lookup = {
  "/mf1": `http://localhost:${process.env.MF1_PORT ||
    2001}`, 
  „/mf2": `http://localhost:${process.env.MF2_PORT ||
    2002}`, 
}; 

http-proxy와 같은 프록시 솔루션을 사용하여 요청을 대상으로 전달할 수 있다. 다음과 같이 조회 변수의 실제 내용을 기반으로 동적으로 수행한다.

const proxy = httpProxy.createProxyServer();

app.use((req, res) => {
  const [prefix] = Object.keys(lookup).filter((m) =>
    req.path.startsWith(m));

  // nothing found, let's just return an error page
  if (!prefix) {
    return res.status(404).send("Nothing found.");
  }

  const target = lookup[prefix];

  // let's proxy the request – it should be fully handled
    // on the respective microfrontend's server
  return proxy.web(req, res, { target }, e => {
    console.error(e);
    res.status(500).send('Something went wrong...');
  });
});


프록시 연결의 오류를 정상적으로 처리해야 한다. 마이크로 프론트엔드 솔루션에서 우리가 원하는 마지막은 마이크로 프론트엔드 중 하나가 전체 애플리케이션을 중단시키는 것이다.

완전성을 위해 변형된 마이크로 프론트엔드 중 하나를 살펴보자. 이제 완전히 독립적이며 개별적으로 디버깅할 수도 있다. 다음 코드 스니펫에서 이를 확인할 수 있다.

const path = require("path");
const express = require("express");
const app = express();
const port = process.env.MF1_PORT || 2001;

app.set("view engine", "pug");

app.use("/mf1", express.static(path.join(__dirname, "..",
  "public")));

app.get("/mf1", (_, res) => {
  res.render('index', { title: "Sample", message: "MF1" });
});
 
app.listen(port, () => {
  console.log(`Running at ${port}.`);
}); 

현재 여전히 매우 성가신 두 가지는 암시적 지식 공유(즉 선택한 경로 접두사를 애플리케이션 게이트웨이와 마이크로 프런트엔드에서 모두 알려야 함)와 모노레포로 인한 빌드 시 결합이다. 그러나 후자는 첫 번째 프로토타입의 아티팩트일 뿐이며 실제로 제거하기 매우 쉽다.

현시점에서 서버 사이드 구성의 마이크로 프론트엔드 솔루션은 상당히 매력적으로 보인다. 결국 격리된 디버깅 경험과 같은 것을 즉시 얻을 수 있다. 또한 마이크로 서비스 지식의 일부를 마이크로 프론트엔드 인프라로 전송할 수 있다.

반면에 클라이언트 사이드 마이크로 프론트엔드는 요즘 더 수요가 많은 것 같다. 한 가지 이유는 더 직접적인 접근 방식을 제시하기 때문이다. 마이크로 프론트엔드를 진정한 프론트엔드 게임 체인저로 볼 때 백엔드 요구 사항 없이 이 아키텍처를 적용하는 것이 합리적이다. 불행히도 이것은 종종 일부 백엔드 기능을 혼합하여 독점적으로 제공되는 많은 훌륭한 최적화 및 개선 사항을 간과한다. 두 세계의 장점을 최대한 활용하면 대부분의 문제 설명에 대한 이상적인 솔루션을 찾을 수 있다.

프론트엔드 접근 방식의 주요 이점은 모든 접근 방식 중에서 가장 유연하다는 것이다. 결국, 서버 측에서만 렌더링하든 클라이언트 측에서만 렌더링하든 상관없이 모든 UI 프레임워크를 여기에서 사용할 수 있다.

프론트엔드 접근 방식의 주요 단점은 조립 및 구성에 항상 어느 정도 시간이 걸린다는 것이다. 확장성 병목 현상을 피하려고 할 때 리소스를 상당히 낭비하는 것은 이상적이지 않다.

프론트엔드 마이크로 프론트엔드 솔루션의 주요 사용 사례는 도구와 같은 경험과 웹 애플리케이션이다. 여기에서 한 가지 예시적인 프레임워크는 single-spa이다.

이제 이론적인 영역을 뒤로하고 이 세 가지 주요 결정을 생각하면서 마이크로 프론트엔드를 실제로 구현하는 데 집중할 때이다.

요약
이 장에서는 여러 유형의 마이크로 프론트엔드가 있음을 배웠다. 프로젝트 요구 사항에 따라 이들 중 하나를 선택할 때는 매우 신중해야 한다.

잠재적인 솔루션 공간, 특히 빌드 시간 대 런타임, per-view 대 in-view, 서버 대 클라이언트 문제의 세 가지 영역을 정의하는 특정 주요 속성이 있다는 것을 배웠다.

각 결정이 잠재적인 구현 접근 방식으로 이어지는 것을 봤다. 정확한 구현 방식은 아직 정의되지 않았지만 이러한 각 유형의 주요 사용 영역은 현재 매우 명확해야 한다.

다음 장에서는 첫 번째 마이크로 프론트엔드 구현부터 시작한다. 고전적인 웹 접근 방식을 사용하여 여러 웹 서버를 단일 웹 애플리케이션으로 통합해 본다.

 
6 웹 접근 방식
이전 장에서 다양한 종류의 마이크로 프론트엔드를 구현하는 방법을 알아봤다. 중요하게 알아야 할 것은 시스템의 경계 조건이다. 이러한 핵심 기술 요구사항은 잠재적 기술 솔루션에 찬성하거나 반대할 때 중요한 역할을 한다.
이제 본격적으로 직접 구현해보자. 여기서부터 코드기반으로 알아보겠다. 이제 대형 마이크로 프론트엔드 시스템을 구현하기 위해 가장 널리 알려진 아키텍처 패턴을 구현할 것이다. 가장 간단한 패턴부터 시작해서 마이크로 프론트엔드 아키텍처의 정점을 찍을 때까지 계속 진행한다.
이 장에서는 마이크로 프론트엔드를 구현하기 위한 가장 기본적인 패턴으로 웹 접근 방식을 소개한다. 이전 장의 백엔드 영역에서 설명한 예제 코드가 개선 및 대폭 향상된 것을 확인할 수 있다.
먼저 아키텍처 패턴에 대한 몇 가지 기본 사항부터 살펴보자. 여기서 예제 구현도 소개한다. 예제 구현은 여전히 단일 저장소에서 작동하지만 실제로 여러 저장소에서 실험하여 결과를 확인할 수 있다.
이후 이 패턴의 장점과 단점을 상세히 논의한다. 끝으로 웹 접근 방식 패턴을 적용할 수 있는 두 가지 향상된 기능을 살펴본다. 즉, 개별 마이크로 프론트엔드에 대한 링크를 동적으로 생성하는 방법과 아이프레임(iframes)을 완전히 활용하는 방법에 대해 알아본다.
요약하면 이 장에서는 다음과 같은 주제를 다룬다.
	기본 사항
	장점과 단점
	링크 (Links)
	아이프레임 (iframes)
거두절미하고 바로 주제로 들어가보자.

기술 요구사항
이 장에서 사용된 코드는 아래 링크에서 확인할 수 있다. https://github.com/PacktPublishing/The-Art-of-Micro-Frontends/tree/main/Chapter06
위 코드를 사용하는 방법은 설명한 비디오는 아래 링크에서 확인할 수 있다.
https://bit.ly/3yOxuHc

웹 접근 방식의 기본 사항
마이크로 프론트엔드를 구현하는 웹 접근 방식은 URL을 통해 개별 마이크로 프론트엔드를 참조하는 방식으로 작동한다. 기본 원리는 다음 그림과 같다:
 
그림 6.1 – 웹 접근 방식 이면의 아이디어 – 애플리케이션의 다양한 부분을 제공하는 다양한 서버
이러한 패턴에서 팀은 전체 페이지를 대상으로 진행되며 중앙에서 주어진 설계 및 비즈니스 도메인에 의해서만 관리된다.
실제 적용 사례를 보면 기본 원칙에 따라 페이지 변경 중에 오리진이 변경된다. 예를 들어 www.example.com에서 시작하지만 mf1.example.com으로 이동할 수 있다.
그러나 이전 예제에서 구현된 일종의 게이트웨이 뒤에 실제 웹 서버가 종종 숨겨져 있다. 이 경우 오리진은 동일하게 유지되지만 경로가 변경될 수 있다(예: /에서 /mf1로 이동).
예제를 구현하기 전에 웹 접근 방식의 아키텍처를 살펴보고 구현한 예제를 개선할 수 있는 몇 가지 잠재적인 개선 사항도 논의할 것이다.

아키텍처
기본적으로 웹 접근 방식은 마이크로서비스와 거의 동일한 아키텍처를 사용한다. 그러나 JSON과 같이 순수한 데이터 형태로 제공되는 반면 HTML을 사용하는 프레젠테이션은 이미 렌더링되는 구조다. 
웹 접근 방식은 이 형태가 정확히 어떻게 구현되는지를 규정짓지 않는다. 예를 들어 기존 마이크로서비스 백엔드를 활용하여 수락 헤더에 민감한 서비스로 변환할 수 있다.
text/html과 같은 값을 최우선 순위로 보고 프레젠테이션 버전을 다시 보낸다.
 


다른 방법으로 개별 마이크로 프론트엔드에 사용되는 전용 웹 서버를 설정할 수 있지만 기존 API 서버를 사용하여 데이터를 복구할 수 있다. 이 방법이 순수주의자가 선택하는 무기일 수 있지만 가장 높은 인프라 요구사항도 함께 필요하다.
고려해야 할 또 다른 사항은 API 게이트웨이와 같은 집계 계층이다. 이전 예제에서 이미 이 개선 사항을 활용했고 이번 장에서 다시 활용될 것이다. 이유는 간단하다. 이렇게 하면 하나의 큰 규모의 애플리케이션 내에서 모든 페이지가 실행되는 브라우저와 통신 시 발생하는 문제를 많이 방지할 수 있다. 
브라우저 관점에서 애플리케이션의 경계는 여러가지로 정의되지만 가장 중요한 것은 경로 정보 앞의 URL 부분인 웹사이트 출처이다.
예제 구현에서 집계 계층도 사용할 것이다.

예제 구현
이전에는 항상 모노레포(단일 저장소)를 이용했지만 이 예제의 경우 각 마이크로 프론트엔드 자체 저장소에 상주하는 설정을 시뮬레이션 한다. 
이유는 간단하다. 실제 환경에서는 최소한 일부 마이크로 프론트엔드가 자체 저장소에서 개발될 것이기 때문이다. 마이크로 프론트엔드를 고려할 때 선택의 자유와 외부 개발의 가능성은 두 가지 중요한 요소이다. 단일 저장소를 사용하는 설정보다 분산 저장소를 사용하는 설정이 훨씬 그럴 듯 하다.
먼저 각 마이크로 프론트엔드 전용 공간을 만들어보자. 일반적으로 이러한 저장소는 개별 저장소이지만 이 샘플의 경우 별도의 디렉토리를 만드는 것으로 충분하다.
웹 접근 방식에서 모든 마이크로 프론트엔드는 완전한 웹 서버이다. PHP 또는 Node.js와 같은 기능을 사용하는 동적 페이지이거나 일부 정적 HTML 마크업일 수 있다. 데모 목적으로 정적 HTML 서비스를 위해 http-server 패키지를 사용하는 Node.js 프로젝트를 사용한다.
다음과 같이 사용하여 마이크로 프론트엔드를 시작할 수 있다.
# 새로운 Node.js 프로젝트를 만듭니다
npm init -y
# http-server 패키지를 의존성에 추가합니다
npm i http-server --save

package.json의 스크립트 섹션은 시작 스크립트로 확장해야 한다.
“start": "http-server ./views --port 2001”

해당 명령어는 http://localhost:2001의 views 디렉토리를 제공하고 npm start를 통해 실행할 수 있다.
실제 HTML은 마이크로가 아닌 프론트엔드 페이지를 위해 작성하는 HTML과 다르지 않기 때문에 다소 지루하다. 유일한 차이점은 다른 마이크로 프론트엔드를 참조하는 링크를 사용한다는 것이다. 예를 들어 첫 번째 마이크로 프론트엔드에는 다음과 같은 링크를 포함한다.
<a href="/mf2">Go to MF2</a>

나중에 논의하겠지만 이러한 링크는 다소 취약하며 잠재적으로 더 견고하게 만들 수 있다. 
예제의 경우 집계 계층도 추가할 것이고 이것은 단지 마이크로 프론트엔드 프록시 역할이다. 여기에는 많은 기술적 선택이 가능하다. 이 경우 http-proxy-middleware 패키지와 함께 Express를 활용하는 Node.js 서버를 사용한다.
게이트웨이를 구현하는 한 가지 방법은 경로 접두사를 기반으로 모든 요청을 프록시하는 동시에 일부 마이크로 프론트엔드로 /를 전달하는 것이다. 이 방법은 특정 접두사를 사용하고 유지하는 모든 마이크로 프론트엔드에 대한 요구사항을 설정한다. 알려진 접두사가 없는 경우 HTTP 404 상태로 응답한다.
자세한 코드는 아래와 같다.
const express = require("express");
const { createProxyMiddleware } = require("http-proxy-
middleware");

const app = express();
const port = process.env.PORT || 1234;

const targets = {
"/mf1": "http://localhost:2001",
// ... more
};

app.get("/", (_, res) =>
res.redirect(Object.keys(targets)[0]));

Object.keys(targets).forEach((prefix) => {
app.use(
prefix,
createProxyMiddleware({
target: targets[prefix],
changeOrigin: true,
})
);
});

app.get("*", (_, res) => res.status(404).send("Page not
found."));

app.listen(port, () => {
console.log(`Microfrontend gateway running at ${port}.`);
});
구현하는 샘플의 디렉토리 구조는 다음과 같다.
mf-1/	# 마이크로 프론트엔드 1의 레포지토리
├─ views/	# 마이크로 프론트엔드에 의해 제공되는 뷰
│ ├─ mf1/	# 적절한 네임스페이스를 노출하는 현재 폴더
│ │ ├─ index.html	# 마이크로 프론트엔드 1의 메인 뷰
│ │ ├─ fragment/	# 추가 프레그먼트의 노출
│ │ │ ├─ index.html	# 마이크로 프론트엔드 1의 프레그먼트 뷰
│ │ │ ├─ packages.png # 프레그먼트에서 사용되는 리소스
├─ package.json # 프로젝트의 세부 정보
mf-2/	# 마이크로 프론트엔드 2의 레포지토리
├─ views/	# 마이크로 프론트엔드에 의해 제공되는 뷰
│ ├─ mf2/	# 적절한 네임스페이스를 노출하는 현재 폴더 
│ │ ├─ index.html	# 마이크로 프론트엔드 2의 메인 뷰
├─ package.json # 프로젝트의 세부 정보
mf-gw/	# 통합 계층의 레포지토리
├─ package.json # 프로젝트의 세부 정보
├─ lib/	# 런타임 파일
│ ├─ index.js # 서버 스타트업 파일

실제 운영 환경 준비를 위해 일부 중요한 특성이 누락되었다고 주장할 수 있지만 다른 잠재적 개선 사항도 고려해야 한다. 다음 섹션에서 살펴보도록 하겠다.

잠재적인 개선 사항
이미 잠재적인 개선 사항으로 게이트웨이를 도입했다. 게이트웨이를 중심점으로 도입할 경우 모든 웹 서버를 강력하게 연결하지 않도록 해야 한다. 따라서 전용 레지스트리 서비스 또는 다른 검색 매커니즘을 통한 일부 느슨한 결합을 강력히 권장한다.
기본적으로 웹 접근 방식은 이미 상당히 견고하다. 또한 느슨하게 결합되어 있기 때문에 이미 충분하다. 그럼에도 불구하고 특정 패턴을 적용하기 위해 로깅, 오류 처리, 인증과 같은 일반적인 것을 포함하는 상용구를 활용하고 싶어할 수 있다. 이러한 상용구가 있으면 개별 팀에서 이를 시작점으로 사용할 수 있으며 생산성을 엄청나게 향상시킬 것이다.
고려해야 할 또 다른 사항은 사용하려는 특정 UX 패턴 또는 기타 주요 속성을 적용하는 서비스이다. 예를 들어서 마이크로 프론트엔드당 성능 예산을 결정하는 것이 좋은 시작이지만 이를 시행할 도구가 없으면 의미가 없다.
이 패턴을 사용할 때 어떤 다른 장점과 단점이 있는지 다음 세션에서 살펴보자.
장점과 단점
해당 접근법의 주요 장점은 마이크로서비스와 관련된 유사성과 순수성 그리고 단순성이다. 실제 웹 서버 기술에 대한 고급 자바스크립트 기술, 프론트엔드 프레임워크 또는 요구 사항이 없다.
주요 이슈들 또한 이러한 장점과 함께 상속된다. 예를 들어서 프론트엔드는 일반적인 UX 패턴을 사용하여 일관성을 유지해야 하기 때문에 마이크로 서비스에 가까이 접근하기가 매우 어렵다. 이는 정의에 따라 반드시 일치하는 것이 아니다. 마찬가지로 간단한 접근 방식도 상당히 빠르게 한계에 부딪힐 것이다.

한계를 살펴보면 서로 다른 마이크로 프론트엔드를 참조하거나 사용하는 방법은 링크 (전체 페이지 전환용)와 iframe (개별 구성 요소/일부 요소) 두 가지 뿐이라는 것을 알 수 있다. 이 장 뒷부분에서 두 가지 모두에 대해 자세히 설명하겠다.
그렇다면 웹 접근 방식은 언제 사용해야 할까? 일관성이 필요하지 않을 때는 웹 접근 방식이 타당하다. 또한 제3자 출처의 요소를 포함해야 하거나 제 3자 대상에 요소를 제공해야 하는 경우도 사용될 수 있다. 따라서 타사 쿠키 동의서 솔루션, 채팅 봇 또는 유사한 서비스를 사용하는 대부분의 웹 사이트는 이미 마이크로 프론트엔드를 활용하고 있다.
이 패턴은 또한 다른 접근법과 결합된 고전적인 패턴이다. 예를 들어 아마존(Amazon)과 같은 대형 웹 사이트에서도 개별 애플리케이션 (예: 음악, 비디오, 사진, 쇼핑)을 하나의 우산 아래에 놓는 데 사용한다. 서로 다른 애플리케이션이 완전히 일관될 필요는 없다. 대신 이렇게 사용하는 이유는 단일 회사에서 하나의 더 큰 제품으로 보여지기 위한 것이다.
모든 것이 링크에 많이 의존하고 있기 때문에 이러한 패턴의 활용도에 대해 자세히 살펴봐야 한다.

링크
웹 접근 방식의 핵심 매커니즘은 하이퍼링크의 사용이다. 하이퍼링크는 URL을 사용하여 전체 페이지 또는 스타일시트 또는 자바스크립트 파일과 같은 에셋을 참조한다.
하이퍼링크는 단순해 보이지만 웹을 성공적으로 만든 마법의 재료이다. 그러나 느슨하게 결합된 특성 때문에 하이퍼링크가 작동을 유지할 수 있는 직접적인 방법이 없다는 단점이 있다.
마이크로 프론트엔드 1 페이지를 마이크로 프론트엔드 2 페이지에 연결하려고 한다고 가정하자:
  <a href="/mf2/some-page">More details</a>	

해당 코드의 문제는 다른 마이크로 프론트엔드 (페이지 URL)의 정보를 가지고 사용해야 한다는 것이다. 이제 링크를 소개할 때 정보는 정확할 수 있지만 링크의 전체 수명 동안 이 정보를 보장할 수는 없다. 따라서 이런 방법은 다소 취약한 구조이다.
문제의 근원은 언제든지 변할 수 있는 출처의 정보를 사용한다는 것이다. 여기서 풀어야 할 숙제는 우리가 이것을 어떤 식으로 바꿀 수 있을까 이다.
당연히 대답은 바꿀 수 없다이다. 링크는 항상 소유자에 의해 결정된다. 그러나 우리가 할 수 있는 것은 중앙 또는 로컬 링크 디렉토리를 도입하는 것이다. 이러한 연결 디렉토리에 숨겨진 아이디어는 대상 링크가 변경될 수 있지만 이러한 변경은 즉시 발견되고 수정할 수 있다는 것이다. 따라서 이는 일종의 신뢰성 계층으로 작용해야 한다. 다음에는 중앙 및 로컬 링크 디렉토리에 대해 자세히 살펴보자.

중앙 연결 디렉토리
중앙 연결 디렉토리에서는 중앙 서비스에 하이퍼 레퍼런스를 저장, 검색 및 검증한다. 이는 단순한 CRUD 서비스 또는 게이트웨이 서버의 통합 부분일 수 있다.
링크 디렉토리에 얽힌 아이디어는 각 마이크로 프론트엔드가 모든 URL을 보고해야 한다는 것이다. 즉 새 URL, 제거된 URL 및 변경된 URL을 의미한다. 후자는 특히 더 유용하다. 각 마이크로 프론트엔드가 기존 URL에 별칭 (또는 종속성)을 도입할 수 있는 경우 별칭을 업데이트할 수 있다.
URL /common/mf2-some-page를 /mf2/some-page에 매핑한다고 가정해보자. /mf2/ 일부 페이지가 /mf2/other-page로 변경되는 경우 별칭은 그대로 유지되지만 대상은 업데이트 된다. 이렇게 하면 리팩터링이나 변경에 대한 차단없이 안정적인 URL을 얻을 수 있다.
중앙 접근 방식의 한 가지 문제는 분산된 개별 마이크로 프론트엔드가 범위를 벗어나는 서비스를 필요로 한다는 것이다. 이러한 종속성은 견고성 및 디버깅 이유로 인해 문제가 될 수 있다. 실제로 이러한 경우 로컬 연결 디렉토리가 적합한 솔루션이 될 수 있다.

로컬 연결 디렉토리
중앙 서비스를 사용하는 대신 마이크로 프론트엔드의 웹 서버에 로컬 디렉토리를 통합할 수 있다. 이것의 큰 장점은 지역적이라는 것이다. 단점은 인프라가 더 복잡하다는 것이다. 여기서는 강력한 URL을 보장하기 위한 동기화 또는 명시적 검증 매커니즘이 필요하다.
마이크로 프론트엔드 1에서는 /mf1/mf2-some-page와 같은 별칭 URL을 도입하여 실제 URL (예: /mf2/some-page)로 리다이렉션할 수 있다. 이제 이 관계가 하드 코딩되면 HTML 코드가 지정된 URL을 참조하는 위치를 식별하는 대신 단일 위치만 변경하면 된다는 점을 제외하고는 아무런 이점도 얻을 수 없다. 하지만 이를 활용하는 방법이 있다.
각 마이크로 프론트엔드에 로컬 연결 디렉토리가 함께 제공되는 경우 이 디렉토리를 API로 노출할 수 있다. 이제 디렉토리는 두 부분으로 나눌 수 있다. 하나는 고유 ID를 사용하여 모든 링크를 노출하는 부분이고 다른 하나는 현재 값으로 외부 링크를 실제로 표시하는 부분이다.
/mf1/links에 대한 요청은 다음과 같은 응답을 제공한다:
{
"internal": [
{
         "id": "fb2048fb-470c-48f3-85fe-01645adfcd0f",
"url": "/mf1/first"
}
],
"external": [
{
   "id": "d08ee9a5-5f04-41eb-b1c7-2f1a917c1f57",
"alias": "/mf1/mf2-some-page",
"url": "/mf2/some-page"
}
]
}

이렇게 하면 지정된 ID를 사용하여 해당 서비스에 대한 정기 점검을 할 수 있다. 여기서 중요한 부분은 ID가 절대 바뀌어서는 안 된다는 것이다. 제거된 URL을 보여주기 위해 제거될 수 있지만 변경되지 않는다. URL 값은 변경될 수 있지만 이것이 고정 ID가 처음부터 사용되는 이유이다.
링크 디렉토리가 있으면 하이퍼링크뿐만 아니라 에셋에 대한 참조에도 도움이 된다. 이것은 프레임에도 매우 편리하다. 이제 프레임에 대해 살펴보자.

아이프레임(Iframes)
웹 접근 방식에는 아이프레임 태그를 사용하여 요소를 포함한다. 논리적으로 몇 가지 정보(예를 들어 URL의 일부 요소)가 필요하다. 다른 팀이 완전히 소유한 URL을 사용하지 않으려면 글로벌 링크 디렉토리를 사용해야 한다.
다음은 마이크로 프론트엔드 1에서 나온 일부 참조 예시이다.
<iframe src="/mf2/fragment"></iframe>
더 개선된 방법은 아래와 같이 변경하는 것이다.
<iframe src="/mf1/mf2-fragment"></iframe>
여기서 서버는 일반적으로 미리 소개한 대로 로컬 연결 디렉토리를 사용하여 /mf2/fragment로 리디렉션되는 HTTP 304 상태로 응답한다.
인라인 프레임에는 여전히 몇 가지 문제가 있다. 하나는 보안이고 다른 것은 접근성과 레이아웃이다. 이 세가지에 대해 살펴보자.

보안
소스 링크를 더욱 유연하고 견고하게 만드는 것 외에도 올바른 보안 설정에 대해서도 생각해야 한다. 앞서 설명한 것처럼 샌드박스 속성을 사용하여 최상위 프레임을 자식 프레임의 콘텐츠로부터 적절히 보호할 수 있다.

접근성
보안은 iframe의 장점 중 하나이지만 접근성 및 검색 엔진 최적화 (SEO) 기능은 상당히 부족하다 (특히 고객 대상 사이트의 경우). 화면 판독기는 종종 페이지 내용을 분석하는 데 상당한 문제를 겪는다. 마크업은 어떠한 보조적인 의미를 제공하지 않기 때문에 다른 도구를 사용하는 것 자체가 덜 유용할 수 있다.

레이아웃
인라인 프레임은 다른 문서에 내장되어 있기 때문에 자체 스타일이나 위치에 영향을 줄 수 없다. 때로는 이것이 바람직하지만 항상 그렇지 않다. 인라인 프레임은 자체 치수와 통신할 수 없고 해당 치수를 위한 공간을 적절하게 예약할 수 없다. 따라서 상위 프레임은 미리 지정을 해야한다.
이것이 잠재적인 블록커이다. 한편 상위 프레임은 임베딩된 콘텐츠에 대한 내용이 최소화돼야 하며 이를 적절히 포함하려면 먼저 그 치수를 알아야 한다.
적절한 공간을 수용하지 못하면 원치 않은 스크롤 막대가 생기거나 너무 많은 공백이 생긴다. 그러나 CSS를 최신 상태로 유지하는 것은 쉽지 않은 작업이다.
이를 피하는 한 가지 방법은 <iframe> 대신 <script>를 사용하는 것이다. 여기서는 궁극적으로 인라인 프레임을 포함하지만 HTML에서 직접 수행하는 것이 아니라 자바스크립트 DOM를 통해서 수행된다.
이 접근 방식의 장점은 스크립트가 상위 문서에 존재하여 스타일을 조정할 수 있다는 것이다. 그러나 단점은 이제 iframe은 자바스크립트가 실행됐을 때만 표시된다는 것이다. 물론 <nonscript> 태그를 통해서도 포함할 수 있지만 일반적인 상황에서는 프레임이 직접 접근 방식보다 느리게 로드된다.
다른 옵션은 iframe-resizer와 같은 라이브러리를 사용하여 이 문제를 해결하는 것이다. 일반적으로 맨 위 프레임에 다음과 같은 스니펫이 존재한다.
<style>
iframe {
width: 1px;
min-width: 100%;
}
</style>
<iframe class="component" src="/iframe.html"></iframe>
<script src="/iframeResizer.min.js"></script>
<script>
iFrameResize({ log: true }, 'iframe.component')
</script>
실제 iframe (예: iframe html)은 다음과 같은 스니펫처럼 사용될 수 있다:
<style>
html, body {
padding: 0;
margin: 0;
}
</style>
   
이러한 접근 방식의 주요 장점은 레이아웃이 동적으로 최적화 된다는 것이다. 해당 방법은 내용이 변경이 될 때도 작동한다. 단점은 다른 스크립트가 필요해서 웹사이트의 성능이 떨어진다는 것이다.

 
요약
이번 장에서는 대규모 마이크로 프론트엔드 솔루션을 실현하기 위한 첫 번째 패턴을 배웠다. 이제 웹 접근 방식을 사용하면 서로 다른 세분화된 웹 서버를 서로 융합할 수 있다.
겉으로 보기에는 하나의 웹 서버처럼 느껴질 수 있고 사용된 기술들 또한 이색적이지 않다. 그러나 표준 프록시, 링크 및 <iframe> 요소를 사용하여 즉시 안정적인 솔루션을 만들 수 있다.
웹 접근 방식의 주요 장점 또한 가장 큰 단점이다. 시스템이 너무 간단해서 임의로 구성할 수 있다. 따라서 시스템이 원하는 데로 작동하기를 보장하는 것이 상당히 어렵다.
다음 장에서는 서버 사이드 구성 방식으로써 이러한 패턴보다 복잡한 개선 방향에 대해 살펴볼 것이다.









 
7 서버 사이드 구성
이전 장에서 아주 간단한 방법으로 마이크로 프론트엔드를 구성할 수 있었다. 웹은 이미 필요한 모든 것을 우리에게 제공한다. 그러나 간단한 솔루션의 문제는 개발이나 런타임 시점에 확장성이 좋지 않다는 점이다. 그리고 확장성은 마이크로 프론트엔드에서 가장 중요한 포인트 중 하나다. 

여기서의 질문은 다음과 같다. 이에 대해 어떤 것을 할 수 있을까? 확장성에 대한 제약 없이 모든 것을 가능한 격리, 분리 및 독립된 상태로 유지하려면 어떻게 해야할까? 한 가지 가능한 답은 서버 사이드 구성 패턴에서 찾을 수 있다. 여기서 웹 서버가 클라이언트에 도달하기 전에 마이크로 프론트엔트와 연결되기 위해 사용할 수 있는 기술을 사용한다. 

이 패턴의 단점은 백엔드에 추가적인 복잡성을 도입해야 한다는 것이다. 결과적으로는 서버 사이드 구성을 사용하여 다양한 소스의 뷰를 동적으로 결합할 수 있다. 공유 저장소가 전혀 필요 없는 수평적 마이크로 프론트엔드를 허용한다. 이 장에서는 이 패턴을 언제 어떻게 적용해야 하는지에 대해 자세히 설명한다. 

이 아키텍처 패턴에 대한 몇 가지 기본 사항부터 시작한다. 여기서 여러 저장소가 어떻게 동작하는지 완전히 알아보기 위한 예제 구현도 소개한다. 

이후에 이 패턴의 장점과 단점에 대해 논의한다. 마지막으로 이 패턴의 두 가지 특정 구성 요소를 다룬다. 레이아웃은 무엇이며 이 패턴을 사용하여 실제로 마이크로 프론트엔드 개발하는 방법에 관한 부분이다. 
이 장에서는 다음 주제를 간략하게 다룬다.
•	서버 사이드 구성의 기본
•	장점과 단점
•	레이아웃
•	마이크로 프론트엔드
바로 주제로 넘어가보자. 

기술 요구 사항
이전과 마찬가지로 예제 구현을 따라하기 위해 Node.js와 Express에 대한 지식이 충분해야 한다. 코드는 GitHub에서 찾을 수 있으며 여러 저장소에 분산되어 있다. URL은 각 부분을 살펴보기 전에 명시된다. 
이 장에대한 수행 비디오는 여기서 찾을 수 있다:
https://bit.ly/3ifndxV


서버 사이드 구성의 기본

마이크로 프론트엔드를 구현하는 서버 사이드 구성에는 마이크로 프론트엔드가 분해되고 합쳐지는 백엔드의 중심점이 필요하다. 
¬¬¬¬¬ 
그림 7.1 – 서버 사이드 구성의 이면에 있는 아이디어 – 중앙 서버가 서로 다른 프론트엔드 조각들을 결합한다

이 패턴에서 팀은 전체 페이지 또는 개별 조각을 작업한다. ¬¬¬조각은 페이지의 완전히 구성된 부분만큼 크거나 일부 도메인 로직을 가진 UI 컴포넌트만큼 작을 수도 있다. 

표시된 역 프록시는 본질적으로 이전 장에서 소개한 집계 계층과 동일한 역할을 한다. 차이점은 그 책임이 마이크로 프론트엔드를 프록시하는 것 이상이라는 것이다. 따라서 일반적으로 이 지점을 게이트웨이 서비스 또는 BFF(Backend for frontend)라고 한다. 

BFF는 프론트엔드를 제공하기 위해 도입된 백엔드 일부이다. 일반적으로 BFF는 UX와 필요한 리소스 사이의 층으로 생각할 수 있다. 앞의 다이어그램에서 각 서버는 완전히 독립적일 수 있지만 BFF만 개별 리소스를 결합하여 하나의 일관된 UX를 형성한 다음 페이지를 제공할 수 있다.

아키텍처
일반적인 웹 접근 방식으로 개발된 서버도 여기서 사용할 수 있다. 결국 이를 사용해 HTML 조각을 전달하는 것이다. 실제로 새로운 부분은 완전히 렌더링된 페이지를 생성하기 위해 서로 다른 조각을 함께 잇는 집계 계층이다.  

이러한 연결은 페이지 사이를 탐색하는 데 사용될 수 있어서 이러한 페이지가 반드시 격리되는 것은 아니다. 대신 페이지들은 집계 계층에서 항상 구성된다. 만약 우연히 하나의 페이지를 하나의 마이크로 프론트엔드에서 완전히 제공했다면 이 페이지는 클라이언트로 가기 전에 처리되는 곳인 집계 계층을 통과해야 한다. 

집계 계층에는 여러 책임이 있다. 가장 중요한 작업은 URL로 식별되는 현재 페이지와 연관된 템플릿을 결정하는 것이다. 그런 다음 관련 마이크로 프론트엔드에 요청을 프록시하여 템플릿을 확장해야 한다. 마지막에는 반복적인 해결책과 리소스 경로 선정을 고려해야 한다. 

기존 예제 프로젝트에 서버 사이드 구성을 사용해보자.

예제 구현
이 예제에서 단일 저장소 이상의 개념을 다룬다. 이런 방식을 통해 우리는 인공적인 조건 없이 마이크로 프론트엔드가 실제 프로젝트에서 어떻게 작동하는지 알 수 있다. 또한 우리는 보다 정교한 예제 응용 프로그램을 사용할 것이다. 이를 위해 micro-frontends.org에서 유명한 트랙터 매장을 선택한다. 함께 구성된 페이지는 다음과 같다.
 
그림 7.2 – 공식 웹사이트에 표시된 트랙터 매장 샘플
트랙터 상점은 세 개의 마이크로 프론트엔드로 구성된 페이지를 보여준다. 하나의 마이크로 프론트엔드는 제품(빨간색)을, 다른 하나는 스토어 로직(파란색)을 그리고 세 번째는 관련 제품에 대한 추천 상품을 합친다(녹색).

어떻게 빨간색을 담당하는 팀이 마이크로 프론트엔드를 구현하는지 살펴보자. 

제품 페이지 구현 – 빨간색 마이크로 프론트엔드
이 장의 코드는 https://github.com/ArtOfMicrofrontends/07-red에서 찾을 수 있다.
이 마이크로 프론트엔드는 제품 정보 페이지를 담당한다. 예제에서 이 페이지는 유일한 페이지이므로 모든 콘텐츠의 중심 부분이다. 

간단한 Node.js Express 서버를 사용하여 콘텐츠를 제공할 수 있다. ejs와 nodesi 패키지를 사용해서 템플릿 메커니즘을 합칠 수 있다. 이를 통해 다음 HTML을 사용하여 페이지를 정의할 수 있다. 
<link rel="stylesheet" href="./product-page.css">
<h1 id="store">The Model Store</h1>
<esi:include src="/mf-blue/basket-info?sku=<%= current.sku
%>" />
<div id="image">
<div>
<img src="./images/<%= current.image %>" alt="<%=
current.name %>" />
</div>
</div>
<h2 id="name">
<%= product.name %> <small><%= current.name %></small>
</h2>
<div id="options">
<% product.variants.forEach(variant => { %>
<a href="./product-page?sku=<%= variant.sku %>">
<button class="<%= current.sku === variant.sku ?
'active' : '' %>" type="button">
<img src="./images/<%= variant.thumb %>" alt="<%=
variant.name %>" />
</button>
</a>
<% }); %>
</div>
<esi:include src="/mf-blue/buy-button?sku=<%= current.sku
%>" />
<esi:include src="/mf-green/recommendations?sku=<%=
current.sku %>" />

변수를 사용하는 부분은 <%= … %> 자리 표시자를 통해 표시된다. 주목해야 할 또 다른 사항은 다른 마이크로 프론트엔드의 조각을 참조하기 위해 esi:include 태그를 사용한다는 것이다. 나중에 ESI(Edge-Side Include)에 대해 자세히 소개한다. 지금은 이것이 다른 마이크로 프론트엔드의 코드 삽입을 나타내는 가능한 메커니즘이라는 것만 알면 된다. src 속성은 원하는 부분이 검색되는 위치를 나타낸다. 

앞선 문서는 유효한 HTML 조각이며 브라우저에서 잘 렌더링된다. 최종 형식은 사용된 집계 계층에 따라 약간 다르다. 우리는 완전하고 유효한 HTML 문서를 작성하는 것이 일반적으로 가장 이상적인 경우일지라도 보이는 조각들로 제한해야 한다. 

렌더링 될 때 마이크로 프론트엔드는 나중에 예상되는 페이지와 이미 유사하게 보인다.  이 시점에서 페이지의 스타일과 다른 마이크로 프론트엔드가 없기 때문에 분명히 본연의 모습을 확인할 수 있다.  
 
그림 7.3 – 격리되어 실행되는 빨간색 마이크로 프론트엔드의 제품 페이지
Express 서버의 상용구 코드는 지난 예제에서 사용했던 것과 굉장히 유사하다. 다음을 사용해보자.

const { renderFile } = require("ejs");

const app = express();
const port = process.env.PORT || 2001;
const host = `http://localhost:${port}`;

// 뷰와 뷰 엔진을 정의합니다
app.set("views", path.resolve( dirname, "..", "views"));
app.engine("html", renderFile);
app.set("view engine", "html");

// 에셋을 위한 폴더를 정의합니다
app.use(express.static("public"));

// 서버를 시작합니다
app.listen(port, () => {
console.log(`[OK] MF-Red running at ${host} ...`);
});

또한 트랙터 매장의 제품 정보를 위해서 몇 가지 데이터가 필요하다. 그런 다음 제품 정보 마이크로 프론트엔드를 나타내는 /product-page 경로를 정의할 수 있다.

app.get("/product-page", (req, res) => {
const sku = req.query.sku || "porsche";
const current =
product.variants.filter((v) => v.sku === sku)[0] ||
product.variants[0];

res.render("product-page", {
product,
current,
});
});


이 엔드포인트는 사용해야 할 제품에 대한 정보를 query 파라미터로 가져온다. 또는 SKU 정보를 경로의 일부로 만들 수 있다. 기본적으로 일부 데이터 포인트로 폴백한다. 마지막으로 두 개의 변수 product와 current가 있는 제품 페이지 템플릿을 사용하여 페이지를 렌더링한다. 

제품 페이지 그 자체는 흥미롭지만 파란색 마이크로 프론트엔드로부터 도움 없이는 어떠한 상호작용에 대한 가능성도 없다. 이것도 구현해보자. 

상점 기능 구현 – 파란색 마이크로 프론트엔드
이 장의 코드는 https://github.com/ArtOfMicrofrontends/07-blue 에서 찾을 수 있다. 
이 마이크로 프론트엔드는 완전히 다른 기술(예: PHP)을 사용하여 만들 수 있지만 이전 스택을 그대로 사용한다. 결국 우리의 목표는 최대한 많은 기술을 보여주는 것이 아니라 패턴 자체를 설명하는 것이다. 
파란색 마이크로 프론트엔드는 주문 바구니의 관리를 담당한다. 트랙터 매장에서 이 부분은 두 가지 구성 요소로 나뉜다. 

•	바구니에 있는 항목 수를 표시하기 위한 바구니 정보
•	추가 항목을 바구니에 추가할 수 있는 카트 추가 버튼

 여기서 까다로운 부분은 사용자 별 상태도 관리 영역에 포함된다는 것이다. 백엔드에서 이러한 상태를 구현하는 방법에는 여러가지가 있지만 이러한 방법의 대부분은 헤더를 통해 전송되는 쿠키를 이용한다. 

단순화된 세션 관리를 위해서 express-session 패키지를 사용한다. 이는 우리에게 쿠키와 사용자 상태 관리에 대해 간단한 wapper를 제공한다. 이 예에서는 사용자 상태를 관리하기 위한 간단한 메모리 내 저장소로 충분하다. 

세션 통합 설정은 다음 코드와 함께 작동한다:

const session = require("express-session");
app.use(
session({
secret: process.env.STORE_SECRET || "foobar-blue",
resave: false,
saveUninitialized: true,
})
);

장바구니에 항목을 추가하려면 양식 전송이 필요하므로 양식 데이터를 분석할 미들웨어도 설정해야 한다. 여기서 가장 쉬운 방법은 Express에서 이미 제공하는 것을 사용하는 것이다: 

app.use(
express.urlencoded({
extended: true,
})
);

마지막으로 세션 캐시를 실제로 활용하기 위해 요청 객체의 세션 속성을 사용할 수 있다. 예를 들어 다음 엔드포인트는 장바구니 정보를 렌더링한다.
app.get("/basket-info", (req, res) => {
res.render("basket-info", {
count: req.session.count || 0,
});
});

만약 count가 정의되지 않았다면 시작 값을 0으로 설정한다. basket-info 템플릿은 ejs의 템플릿 규칙을 통해 다시 정의된다.

<link rel="stylesheet" href="./basket-info.css">
<div class="blue-basket" id="basket">
<div class="<%= count === 0 ? 'empty' : 'filled'
%>">basket: <%= count %> item(s)</div>
</div>

다시 말하면 이것은 독립적으로 렌더링이 가능한 격리된 조각에 가깝다. 브라우저에서 아래처럼 보인다.
 
그림 7.4 – 별도로 실행되는 파란색 마이크로 프론트엔드의 바구니 정보
파란색 마이크로 프론트엔드의 기능을 이용하면 전체 응용 프로그램은 전반적으로 문제 없이 작동한다. 그러나 성공적인 비즈니스를 위해 제품 페이지에서 볼만한 다른 제품을 찾는 방법 같은 피처가 필요하다. 

초록색 마이크로 프론트엔드는 제품 추천과 관련된 구성 요소를 가져와 이런 비즈니스 요소를 더한다. 

추천 목록 구현 – 초록색 마이크로 프론트엔드
이 장의 코드는 https://github.com/ArtOfMicrofrontends/07-green에서 찾을 수 있다.

구현의 관점에서 보면 초록색 마이크로 프론트엔드가 확실히 가장 단순하다. 추천된 제품 목록을 보여주는 HTML 조각 하나를 제공한다. 

조각은 ejs 패키지의 템플릿 언어를 다시 사용한다. 이는 다음과 같다.

<link rel="stylesheet" href="./recommendations.css">
<div class="green-recos" id="reco">
<h3>Related Products</h3>
<% recommendations.forEach(recommendation => { %>
<img src="./images/reco_<%= recommendation %>.jpg"
alt="Recommendation <%= recommendation %>">
<% }); %>
</div>

다시 말하지만 우리는 이 화면을 위한 스타일을 전용 CSS 파일로 분리한다. 추천 상품을 돌면서 이미지 목록을 생성한다. 그리고 규칙에 따라 이미지를 검색한다.  

브라우저에서 초록색 마이크로 프런트엔드를 렌더링하면 다음과 같이 표시한다.
 
그림 7.5 – 단독으로 실행되는 초록색 마이크로 프론트엔드에 나타난 추천 상품들

엔드포인트도 매우 명확하고 간단하다.

app.get("/recommendations", (req, res) => {
const sku = req.query.sku || "porsche";
res.render("recommendations", {
recommendations: allRecommendations[sku] ||
allRecommendations.porsche,
});
});


위의 코드 베이스에서 초록색 마이크로 프론트엔드에 관하여 특별할 건 없다. 하지만 서버 사이드 마이크로 프론트엔드를 전달하기 위해 강력한 템플릿 언어와 리소스 로딩 기능이 필요하다는 것을 다시 한 번 보여준다. 

이제 모든 부분이 준비됐으니 이제 집계 계층을 사용하여 함께 가져올 차례이다.

게이트웨이 구현
이 장의 코드는 https://github.com/ArtOfMicrofrontends/07-gateway 에서 찾을 수 있다. 

설명된 아키텍처에서 가장 중요한 부분인 집계 계층으로 마무리한다. 다시 말하지만 Express와 Node.js를 사용하여 간단하면서 강력한 웹 서버를 만든다. 

얘기했던 것처럼 집계 계층은 기본적으로 사용자가 볼 수 있는 HTML문서를 정의하기 위한 기본 템플릿인 레이아웃이다. 트랙터 매장의 경우 레이아웃을 다음과 같이 정의할 수 있다. 

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Tractor Store</title>
<link href="/page.css" rel="stylesheet">
</head>
<body>
<div id="app">
<esi:include src="<%= page %>" />
       </div>
</body>
</html>
 
위 코드는 전체 HTML 문서지만 주요 내용에 대한 표시자를 포함한다. 백엔드는 컨텐츠의 출처를 결정한다. 

이 서버의 코드를 살펴보기 전에 요구사항을 요약해보자.

•	마이크로 프론트엔드에 요청을 프록시하기
•	자리 표시자 태그를 마이크로 프론트엔드의 콘텐츠로 교체
•	하이퍼 참조를 조정(예: 링크, 스타일 시트, 이미지, 양식 등)
•	쿠키 전달 및 집계
•	정적 콘텐츠를 제공


단순화를 위해 마이크로 프론트엔드 대상의 정적 그룹을 사용한다.
 
const targets = {
"/mf-red": "http://localhost:2001",
"/mf-blue": "http://localhost:2002",
"/mf-green": "http://localhost:2003",
};

역방향 프록시에 대한 구성도 매우 간단하다. 기본 URL(base URL)을 구성하고 정의된 마이크로 프론트엔드 대상으로 향하는 허용된 호스트(allowed Hosts)를 제한하기만 하면 된다. 순환 참조로 인한 장기 실행 요청을 피하기 위해 자리 표시자 교체 최대 깊이(maximum depth)를 제한한다. 
역방향 프록시 설정에서 마지막으로 고려할 부분은 캐싱이 생각만큼 간단하지 않다는 점이다. 캐싱이 반드시 필요하지만 신중하게 구성을 선택해야 한다. 콘텐츠의 일부분을 수정하면 동일한 상태를 만들어야 한다. 예를 들어 미세한 튜닝 이슈를 다루는 가장 쉬운 방법은 한꺼번에 캐싱을 불가능하게 만드는 것이다. 


const esiConfig = {
baseUrl: host,
allowedHosts: Object.keys(targets).reduce(
(prev, prefix) => [...prev, targets[prefix]],
[host]
),
maxDepth: 8,
cache: false,
 };
 
/page/ 접두사가 붙은 모든 경로는 기본 템플릿을 확인하며 여기서 경로에 표시된 마이크로 프론트엔드에서 콘텐츠를 가져온다.

app.get("/page/*", (req, res) => {
req.esiOptions = {
headers: { cookie: req.headers.cookie },
};
res.render("default", {
page: makeUrl(req.path.substr(5), req.query),
});
});

예를 들어 /page/mf-red/product-page 경로를 사용하여 페이지를 요청하면 /mf-red/product-page에서 내용을 확인하는 템플릿이 렌더링되고 이 템플릿은 요청을 빨간색 마이크로 프론트엔드로 프록시한다.

프록시 요청은 복원력이 뛰어나며 어플리케이션과 충돌하지 않아야 한다. 그리고 개별 마이크로 프론트엔드를 꺼서 충돌 테스트를 할 수 있다. 빨간색 마이크로 프론트엔드를 끄면 내용이 없는 빈 템플릿만 렌더링된다. 




가장 어려운 부분은 성공적인 폼 제출과 하이퍼 참조의 조절이다. 폼 제출의 경우 폼의 본체를 대상 마이크로 프론트엔드로 전달하고 응답은 버리는 솔루션을 마련할 수 있다. 

이상적으로는 이전 HTML 코드를 재사용하고 마이크로 프론트엔드에 해당하는 부분을 교체하여 폼을 제출하는 것이 좋다. 그러나 이 접근 방식의 문제는 폼 제출이 다른 마이크로 프론트엔드 부분에도 영향을 미칠 수 있다는 것이다. 그래서 우리는 동적으로 어떤 것은 유지될 수 있고 어떤 것은 교체가 필요한지 알아야 한다. 

초기 캐싱 문제로 돌아와서 빠른 해결책을 위해 간단한 예제에서처럼 폼 제출의 응답은 실제로 신경 쓰지 않을 것이다. 전체 프레임워크에서는 그런 면에서 더 정교하겠지만 기본만 알면 된다. 

axios 같은 라이브러리를 사용하면 쉽게 폼을 요청할 수 있다. Axios는 상태를 포함하기 때문에 현재 요청 쿠키를 삽입하고 나중에 응답과 함께 보낼 수 있도록 잠재적으로 수정된 쿠키를 검색해야 한다.  코드에서 cookie 헤더를 명시적으로 설정하여 이를 수행할 수 있다:


axios.request({
method: "POST",
data: req.body,
url: target,
headers: { cookie },
})
.then(({ headers }) => res.header("cookie",
headers.cookie))
.finally (() => res.redirect(req.headers.referer));

최종 렌더링은 도착 페이지와 동일해야 한다. 최종 렌더링이 도착 페이지와 동일하게 하기 위해 referer 헤더를 사용한다. 같은 페이지를 렌더링하기 위해 도착 페이지로 리다이렉팅하여 기존 인프라도 재사용한다. 

또 다른 어려운 점은 하이퍼 참조 조정이다. 하이퍼 참조 조정은 HTML 구문 분석이 필요하다. 그렇지 않으면 잘못된 URL 또는 구성 요소를 얻는다. 간단한 경우에는 일부 정규식(regular expression)을 통해 조회하여 참조 가능하지만 실제 DOM 또는 주석과 같은 소스 코드 세부 정보가 중요한 역할을 하는 에지 케이스까지 만족시킬 수 없다.

이를 구현하는 쉬운 방법은 프록시 요청의 응답을 검사하는 것이다. 응답에 HTML이 포함되어 있으면 cheerio와 같은 파서가 전송된 HTML을 읽어서 검사한다.

조정이 필요한 하이퍼 참조를 보기 위해 <img>와 같은 관련된 요소를 검토한다. 일반적인 규칙은 알려진 대상 접두사(예를 들어, /mf-red) 중 하나로 시작하지 않는 상대적인 URL만 조정하는 것이다. 마지막으로 구문 분석 및 조작된 DOM을 다시 HTML로 직렬화하여 클라이언트에 전달된 최종 문서에서 조각으로 사용한다. 

 
그림 7.7 – 게이트웨이에서 페이지를 요청할 때 여러 호출을 보여주는 순서 다이어그램
전체 흐름은 앞의 그림에서 순서 다이어그램으로 표시된다. 이 예시는 게이트웨이에서 오는 템플릿과 빨간 마이크로 프론트엔드에서 응답을 나타내는 부분 해결책의 최대 두 개의 깊이만 포함한다. 

이 예제를 수행한 후 우리가 더 잘할 수 있는 것은 무엇인가? 하는 질문이 생길 수 있다. 
잠재적인 개선 사항
통합 계층에서 마이크로 프론트엔드를 분리하기 위해 연결 디렉토리를 도입해야 한다. 이것은 소망하던 스케일링 작업을 가능하게 한다. 

또 다른 고려 사항은 서로 다른 템플릿을 저장하는 메커니즘이다. 이 메커니즘은 템플릿 형식 정의와 함께 마이크로 프론트엔드 솔루션의 핵심이다. 결국 서버 사이드 구성은 개별 빌딩 블록의 기능이 뛰어나며 서비스에 의해 미리 렌더링되는 CMS의 일종이다. 이러한 패턴은 정보 집약적인 웹사이트에 가장 유용하다.

포함된 조각의 해상도도 더 정교해야 한다. 최대 응답 시간과 재시도를 도입하여 해결할 수 있다. 또한 캐싱 규칙을 설정하여 안전하게 캐싱할 수 있는 항목과 그럴 수 없는 항목을 구분할 수 있다. 마지막으로 폼 대체를 구성하여 페이지 요청 수를 줄일 수 있다.

CMS 애플리케이션과 그 유사성을 고려한다면 바로 이용 가능한 마이크로 프론트엔드의 모든 부분을 사전 렌더링할 수 있는 단편 스토어를 도입하면 된다. 단편 스토어는 마이크로 프론트엔드의 구성 요소를 위한 전부 혹은 스토리북이라고 생각할 수 있다. 단편 스토어를 이용하면 이미 존재하는 조각을 발견하고 새로운 페이지를 더 빠르게 구성할 수 있다.

그러나 이러한 개선 사항이 없더라도 서버 사이드 구성은 매우 매력적이다. 장점과 단점이 이 모든 걸 말해준다. 

장점과 단점
서버 사이드 구성은 마이크로 프론트엔드 구현에 가장 많이 사용되는 패턴 중 하나이다. 여기에는 몇 가지 이유가 있다. 스케일링이 잘 되고 소결합이며 높은 성능을 자랑한다. 또한 동적 발견, 독립적인 개발 및 수준 높은 유연성을 보장한다.

하지만 단점도 있다. 서로 다른 프론트엔드가 단일 페이지로 병합되므로 적절한 분리를 보장할 수 있는 방법이 없다. 따라서 스크립트와 스타일시트가 서로 충돌할 수 있다. 적절한 디버깅 도구가 부족하여 충돌이 자주 발생할 수 있다. 

개별 마이크로 프론트엔드 환경에서 디버깅은 웹 접근 방식 환경만큼 간단하지만 구성된 웹 사이트에서 디버깅하는 것은 매우 어렵다. 이 패턴의 적절한 로컬 개발 흐름을 구축하는 것은 매우 복잡하다. 그렇다면 Mosaic 9 또는 Prodium 같은 기존 프레임워크를 고려하자. 

Mosaic 9 소개

전체 솔루션의 로컬 개발이 복잡한 이유는 일반적으로 서버 사이드 구성 솔루션이 여러 서비스와 기술을 결합해 동작하기 때문이다. 예를 들어 Zalando의 오픈 소스 솔루션인 Mosaic 9은 다음과 같은 부분으로 구성된다. 
•	Tailor : 레이아웃 서비스
•	Skipper : 확장 가능한 HTTP 라우터
•	Shaker : 모든 마이크로 프론트엔드에서 사용할 수 있는 조각을 제공
•	Quilt : Tailor에서 사용하는 템플릿 저장소
•	Innkeeper : Skipper가 사용하는 연결 디렉토리
•	Tessellate : React 구성요소를 렌더링하는 서비스

언급한 바와 같이 이러한 모든 서비스는 전체 로컬 개발을 위해 개별적으로 돌아가야 한다. 특히 Mosaic의 경우 개별 마이크로 프론트엔드의 로컬 환경 설정이 필요하다. 그렇지 않으면 전체 모습이 온라인에서만 확인 가능하다. 
Mosaic 9에 대한 자세한 정보는 https://www.mosaic9.org/. 에서 찾을 수 있다. 
Mosaic 9이 극단적인 예라고 한다면 더 작고 가벼운 Podium도 있다.


Podium 소개
Podium은 Node.js로 만든 재활용 가능한 서비스에서 중요한 인프라를 많이 수행한다. 프레임워크 그 자체는 특정 기술에 구애 받지 않는다고 주장하지만 Express 프레임워크로 구현된다. 또한 플러그인으로 Hapi와 Fastify 도 있다.
중요한 노트

Node.js에서는 몇 개의 HTTP 프레임워크가 있다. 몇몇은 굉장히 간단하고 다른 일부는 더 통합된 기능과 함께 제공되어 결과적으로 더 많은 옵션을 갖게 된다. Express는 틀림없이 가장 많이 사용되는 프레임워크지만 가장 오래되기도 해서 현대적인 패턴과 관리 방법을 놓치고 있다. Hapi 및 Fastify와 같은 프레임워크는 더욱 현대적인 대안을 시도한다. 이 모든 것으로 전반적인 작업을 수행할 수 있다. 다른 것과 비교해 하나를 선택할 때 팀과 일치하는지 확인해야 한다. 

Podium에는 두 가지 개념이 존재한다.

•	마이크로 프론트엔드를 렌더링 된 페이지로 합치는 레이아웃 서비스
•	마이크로 프론트엔드를 제공하는 애플리케이션인 Podlet

Mosaic 9에 비해 Podium은 단순성으로 인해 적용 범위가 좁다. 예를 들어 Mosaic 9에는 연결 디렉토리를 관리하거나 리액트 구성 요소를 렌더링하는 서비스가 제공되지만 Podium에서는 둘 다 제공하지 않는다. 만약 프로젝트가 정적이거나 리액트를 사용하지 않는다면 문제가 되지 않겠지만 이러한 기능이 나중에 필요할 수도 있다. 

그럼에도 불구하고 서버 사이드 구성을 시작한다면  Podium은 매우 적절하다. 로컬 개발 프로세스 부분에서 다른 프레임워크보다 설정하기가 훨씬 쉽다. 요구사항을 작게 유지할수록 필요한 인프라가 줄어들고 비용을 절감한다. 기본적으로 이 모든 것은 온라인 또는 로컬 환경에서 실행되는 Potlet에 구성할 수 있는 레이아웃 서비스로 정리할 수 있다. Podium은 연결 디렉토리가 빠져 있기 때문에 정확히 수행하는 방법은 이를 사용할 팀에 달려있다.

Podium에 대한 자세한 내용은 https://podum-lib.io/ 에서 확인할 수 있다.

유명한 사용 사례
Zalando는 이 패턴을 옹호한 최초의 기업이었고 바로 이 패턴을 개선하고 반복하기 시작했다. 하지만 그 동안 많은 기업들이 합류했다. 이 패턴의 강점이 잘 나타나는 사업 중 하나는 전자 상거래다. 여기에서 독일 브랜드 Otto 또는 잘 알려진 글로벌 기업인 IKEA는 마이크로 프론트엔드를 신뢰한다. 
온라인 쇼핑몰에서 서버 사이드 구성이 성공한 이유는 장점을 통해 알 수 있다. 이 패턴에서는 성능이 가장 큰 강점이다. 또한 구성에서 클라이언트에 요구사항이 없기 때문에 가능한 가장 광범위한 유저에게 도달할 수 있다. 결국 이 패턴은 이탈과 고객 행동에 직접적으로 미치는 부정적인 영향을 줄인다. 
이렇게 서버 사이드 구성이 좋은데 무엇을 더 배워야 할까. 서버 사이드 구성이 이미 성공적인데 다른 패턴도 도입하는 이유가 뭐지? 그 답은 서버 사이드 구성에서도 잘 작동하지 않는 것이 있다. 그 중 하나는 애플리케이션을 구축하는 단일 페이지 애플리케이션 스타일이다. 

구성 레이아웃 만들기
앞서 말한 것처럼 서버 사이드 구성은 항상 게이트웨이 서비스를 이용하여 서로 다른 마이크로 프론트엔드를 합친다. 게이트웨이는 대부분의 경우 역방향 프록시의 역할을 담당하지만 일반적으로 응답을 프록시 하는 것 이상을 수행한다. 실제로 역방향 프록시는 일부다. 더 중요한 것은 레이아웃이다.
다음 섹션에서는 SSI, ESI 및 JS 템플릿 문자열을 포함하는 조각을 가지기 위한 몇 가지 기술과 책임을 살펴보자. 먼저 책임 부분을 알아보자.

레이아웃 책임 이해
레이아웃은 페이지 설계를 담당한다. 레이아웃은 서로 다른 마이크로 프론트엔드에서 개별 조각을 어디에 배치해야 하는지 결정한다. 레이아웃에는 두 가지 종류가 있다.
•	일반 레이아웃
•	특정 레이아웃
일반 레이아웃은 게이트웨이 서비스에 의해 결정된다. 일반 레이아웃은 하드코딩되거나 다른 서비스 또는 데이터베이스와 같은 일부 로직을 통해 해결할 수 있다. 반대로 특정 레이아웃은 개별 마이크로 프론트엔드에 의해 결정된다. 이 두 개념은 배타적이지 않다. 

예를 들어 일반 레이아웃은 머리글, 바닥글, 탐색 모음 및 내용을 결정할 수 있다. 반면에 내용은 특정 마이크로 프론트엔드에 의해서만 결정될 수 있다. 그런 다음 다른 마이크로 프론트엔드에서 가져온 사이드바와 다른 마이크로 프론트엔드를 혼합하기 위해 다른 레이아웃을 사용한다.
유일한 요구사항은 게이트웨이 서비스만이 클라이언트로 다시 보낼 수 있는 일부 HTML을 생성하기 위해 레이아웃을 적절하게 결정해야 하는 책임이 있다는 것이다.
이러한 이유로  게이트웨이 서비스를 레이아웃 서비스 혹은 레이아웃 엔진이라고도 한다. 물론 Mosaic 9의 경우 게이트웨이를 최대한 가볍게 유지하기 위해 다른 마이크로 서비스에 넣을 수 있다.
구조화 부분을 도입하기 위해 다양한 기술을 사용할 수 있다. 얘기한 것처럼 경우에 따라 서버 사이드를 포함하는 것만으로 충분할 수 있다. 그러나 대부분의 경우 ESI와 같은 고급 기술이 더 낫다. 아마 가장 강력하지만 유연하지 않은 방법은 JS 템플릿 문자열을 사용하여 프로그래밍 언어로 정의된 템플릿을 사용해 레이아웃을 하드코딩 하는 경우다. 

SSI 사용
SSI의 장점은 기술이 너무 오래되고 정립되서 거의 모든 웹 서버에서 작동하거나 할 수 있다는 점이다. 기본적으로 지원되더라도 플러그인이나 확장 프로그램이 존재할 가능성이 높다. 그렇지 않더라도 SSI를 구현하는 것이 어렵지 않다.

SSI의 또 다른 아름다운 특성은 진보적인 성격이다. SSI가 지원되지 않는 웹 서버에서 SSI를 활용한 레이아웃을 사용하더라도 아무런 피해가 없을 것이다. 대신 아무것도 렌더링되지 않는다. 그 주된 이유는 HTML 소스 코드에서 HTML 주석을 Carrier로 선택하기 때문이다.
  <!--#include virtual="footer" -->	

Include 또는 echo와 같은 몇 가지 일반적인 지시문 외에도 SSI 표준은 if와 같은 제어 지시문도 정의한다. 조건부로 레이아웃의 일부를 렌더링하거나 숨길 수 있는 using문을 허용한다. 

SSI를 사용하는 또 다른 큰 장점은 이를 정의하는 데 실제 HTML 외에는 아무것도 필요하지 않다. 레이아웃은 데이터베이스에 저장될 것이다. 레이아웃을 실제로 생성하고 업데이트하는 데 CMS와 같은 경험을 사용할 수 있으므로 반복하고 수정하는데 매우 빠르다. 

ESI 사용
SSI와 비교할 때 ESI 표준은 훨씬 더 현대적이다. HTML 주석 대신 XML 기반 ESI 태그를 사용한다. 이러한 태그는 다음과 같다.
  <esi:include src="/footer" alt="/empty" onerror="continue"	
   />	
훨씬 더 풍부한 명령 세트와 더 많은 스크립팅 기능 외에도 SSI에 비해 가장 큰 장점은 오류 처리이다. 오류 처리로 서버를 사용할 수 없는 경우 장애 조치를 취할 수 있다.

그러나 ESI는 구현하기가 더 복잡하다. 일반적으로 Varnish 또는 nginx와 같은 특수 역방향 프록시는 ESI를 사용할 때 고려되는 표준 웹 서버이다. 이런 구성은 쉽지 않고 굉장히 제한적이다. Node.js 에서 예제 구현에서 이용했던 nodesi 패키지가 있다. Express 프레임워크와 전체 ESI 표준의 하위 집합을 지원한다.

중요한 노트

Varnish는 종종 HTTP 가속기라고도 하며 특히 컨텐츠가 많은 웹 사이트에서 사용한다. 동적 웹 사이트 및 API에서 잘 작동하는 강력한 캐싱 시스템을 제공한다. 또한 VCL(Varnish Configuration Language)을 통한 로드밸런싱, 압축, 스트리밍, 플러그인과 스크립팅을 지원한다. VCL은 가장 빠른 실행을 보장하기 위해 C로 변한된 다음 컴파일한다. 더 많은 정보는 https://varnish-cache.org/에서 찾을 수 있다.


일반적으로 SSI의 장점은 ESI에도 유지된다. 마찬가지로 레이아웃을 데이터베이스에 간단한 HTML로 저장할 수 있다. 이렇게 하면 개발자가 아닌 사용자가 레이아웃을 만들고 업데이트 할 수 있다. 팀 규모를 늘릴 뿐만 아니라 마케팅 전문가, UX 디자이너 및 기술적으로 우수한 프로덕트 오너와 긴밀한 협업이 가능하다. 

그러나 때때로 이러한 마크업 익스텐션은 개발자가 익숙하지 않거나 사용해야 하는 기능이 부족하다. 이러한 경우 프로그래밍 방식으로 마이크로 프론트엔드를 합칠 수 있다. 

JS 템플릿 문자열 사용
템플릿 문자열을 사용하면 모든 프로그래밍 언어에서 매우 유연하게 문자열을 쉽게 정의할 수 있다. 자바 스크립트에서 ES6 표준은 ${}로 묶인 표현식을 사용하여 구성을 허용하는 템플릿 문자열을 도입했다. 예를 들어 다음 코드를 보자.

const name = "Florian";
const age = 36;
const content = `My name is ${name} and next year I'll be
${age + 1} years old.`;
필요한 모든 조각을 가져와 전용 변수에 저장하면 템플릿 문자열을 사용하여 프로그래밍 방식으로 결합할 수 있다. 이제 검색할 조각을 알고 실제로 이러한 개별 부분을 가져오는 것만 남았다.
예를 들어 Podium을 사용하려면 다른 부분도 수동으로 가져와야 한다. 하지만 이 프레임워크는 코드를 매우 최소한으로 유지하는데 도움을 준다. 
다음은 content와 navigation 페이지를 결합하는 레이아웃을 사용한 간단한 예이다.
const Layout = require('@podium/layout');
const app = require('express')();

const layout = new Layout({
name: 'homePage',
pathname: '/home',
});

const navigationClient = layout.client.register({
name: 'navigation',
uri: 'http://localhost:7001/manifest.json',
});
const contentClient = layout.client.register({
name: 'content',
uri: 'http://localhost:7002/manifest.json',
});

app.use(layout.pathname(), layout.middleware());

app.get(layout.pathname(), async (req, res) => {
const page = res.locals.podium;

const [navigation, content] = await Promise.all([
navigationClient.fetch(page),
contentClient.fetch(page),
]);

page.view.title = 'Home';

res.podiumSend(`
<nav>${navigation}</nav>
<main>${content}</main>
`);
});
app.listen(7000);
 
Setting up micro frontend projects	113

문자열 템플릿을 사용하는 프로그래밍 방식의 단점은 전체 서비스를 업데이트해야만 업데이트가 가능하다는 점이다. 이렇게 하면 빠른 반복과 개선을 하기 힘들다. 대신 레이아웃은 본질적으로 개발자가 배포하고 유지관리해야 하는 코드가 된다. 

개발자가 관리해야 할 다른 것은 개별적인 마이크로 프론트엔드이다.

마이크로 프론트엔드 프로젝트 설정
마이크로 프론트엔드 프로젝트는 집계 계층에서 도달할 수 있는 독립 웹 서버이다. 서버 사이드 구성을 위한 마이크로 프론트엔드 개발을 최대한 간단하고 쉽게 만들기 위한 다양한 프레임워크와 도구가 있다. 

Podlets
Podlet은 어떻게 생성될까? 예제 시나리오에서는 전체 Node.js 웹 서버를 나타내는 하나의 파일에 모든 것이 들어간다. 도우미 패키지와 Express를 인스턴스화하기 위해 가져오는 것부터 시작한다.

const Podlet = require('@podium/podlet’);
const app = require(‘express’) ();
 

이제 현재 마이크로 프론트엔드 메타데이터를 정의할 수 있다. 메타데이터는 향후 패턴에서 더 중요한 역할을 한다. 그러나 지금은 최소한 마이크로 프론트엔드의 이름과 버전을 알리며 적절하게 노출해야 한다. 

다음 예에서는 홈 페이지의 컨텐츠를 보여주는 마이크로 프론트엔드를 생성한다.

const podlet = new Podlet({
name: 'homeContent',
version: '1.0.0',
development: false,
});

이제서야 웹 서버의 모든 경로를 설정할 수 있다. 여기가 우리의 마이크로 프론트엔드 로직이 나타나야 하는 곳이기도 하다. 
Podium에는 potlet의 메타데이터를 제공하는 엔드포인트가 필요하다. 마지막으로 정의된 포트에서 웹 서버를 시작한다.

app.use(podlet.middleware());
app.get('/manifest.json', (req, res) => {
res.json(podlet);
});
app.get('/', (req, res) => {
res.podiumSend(`<section>Welcome!</section>`);
});
app.listen(7002);


이 예에서는 기존 마이크로 프론트엔드를 위한 포트를 사용하지 않는다. 생소한 포트를 사용하는 게 상당히 인위적이다. 일반적으로 동일한 포트(예: 8000)를 사용하고 컨테이너화 또는 지정된 구성을 통해 최종 설정에서 고유한 포트를 사용한다.

Potlet이 독립적으로 동작할 수 있다. 결국 이것도 표준 Express 응용 프로그램이다. 여기에는 템플릿 서비스로 연결되는 통신이나 구성이 없다. 그렇다면 개발 수명 주기는 Podium을 이용해서 서버 사이드 구성을 어떻게 찾을까? 다음 장에서 이 질문에 대한 답을 찾을 것이다.
 
수명 주기 검토
추가 서비스 없이 Podium을 사용하면 다소 정적인 설정이 된다. 모든 마이크로 프론트엔드는 템플릿 서비스에서 정적으로 알려야 하기 때문이다. 따라서 결국 세 가지 경우로 나뉜다.

•	새로운 podlet 생성
•	기존 podlet 업데이트
•	기존 podlet 제거

첫 번째와 마지막일 경우 변경 사항을 적용할 때 템플릿 서비스를 업데이트해야 한다. 두 번째 경우에는 podlet을 담당하는 팀이 실제로 독립적으로 작업할 수 있다. 프로젝트 설정에 따라 독립적인 작업 흐름은 pull 요청을 하는 것부터 수락하는 것, 서비스에 업데이트를 적용하는 것까지 모든 것을 허용한다. 그러나 일부 작업 흐름은 제한적이며 중앙 팀의 명시적인 승인이 필요하다.

중앙 팀은 이러한 작업 흐름을 원활히 하기 위한 방법을 모색해야 한다. 해결책은 새로운 서비스가 자동으로 검색되고 포함되는 중앙 지점에서 사용 가능한 링크 디렉토리다. 

 
요약
이 장에서는 서버 사이드 구성이 백엔드에 기존의 마이크로 프런트엔드를 통합하는 데 어떤 도움이 되는지 살펴봤다. 서버 사이드 구성을 사용하면 많은 리디렉션 및 성능 저하 없이 웹 접근 방식의 장점을 살릴 수.있다. 서버 사이드 구성을 신속하게 구현할 수 있도록 지원하는 툴과 프레임워크가 많을 뿐만 아니라 이러한 패턴을 처음부터 구현하기 위한 보다 완벽한 예도 있다.

서버 사이드 구성은 빠른 응답 시간과 자바스크립트 사용 감소가 중요한 웹 스토어와 같은 정보 기반 웹 애플리케이션에 가장 적합하다. 이 패턴의 구현에 투자하기 전에 설정의 복잡성과 필요한 인프라를 고려해야 한다.

이 장에 제시된 정보는 서버 사이드 구성 패턴 사용의 찬반을 결정하는 데 도움이 된다. 트랙터 저장소 샘플을 구현하기 위해 도출된 코드를 따라 서버 사이드 구성을 사용하여 대규모 마이크로 프론트엔드 응용 프로그램을 만들 수 있다.

다음 장에서는 서버 사이드 구성보다 가벼운 에지 사이드 구성을 살펴본다.

 
8 에지 사이드 구성
이전 장에서는 서버 측 구성을 사용할 때 수반되는 복잡성과 잠재적인 이득을 살펴봤다. 서버 사이드 구성에서 조금 변형하면 에지 사이드 구성 패턴이다. 이 패턴은 서버 측 구성에 비해 간단하며 더 큰 성능 향상을 가져오는 것을 목표로 한다. 

에지 측 구성은 일반적으로 CDN과 같은 에지 서버에 있지만 이 패턴의 개선 사항을 온프레미스에서도 적용할 수 있다. 핵심은 이 단순화의 이면에 있는 아이디어이다. 구현이 CDN에 배포할 수 있을 만큼 간단하다면 이 패턴이 적합하다는 것을 알 것이다.

이 장에서는 이전 장의 예제를 단순화하는 것이 중요하다. 따라서 에지 측 구성을 자세히 살펴보는 것이 좋다. 다시 말하지만 교육적인 목적을 위해 전체 마이크로 프론트엔드 프레임워크를 사용하진 않는다. 대신 대부분의 웹 개발자가 이미 사용하는 표준 도구로 작업할 것이다. 

이 장에서는 다음 항목을 다룬다.

•	에지 측 구성의 기본
•	장점과 단점
•	SSI 및 ESI
•	BFF에서 결합하기

전체적으로 이전 장에서 소개한 몇 가지 주제를 더 자세히 다루겠지만 이번에는 사용성과 단순화의 관점에서 살펴본다.
 
각설하고 바로 주제로 넘어가보자!

기술 요구 사항
이 장의 샘플 구현을 따라오려면 Node.js에 대한 지식이 필요하고 도커 및 Nginx에 익숙해야 한다.
이 장에 대한 코드는 https://github.com/PacktPublishing/The-Art-of-Micro-Frontends/tree/main/Chapter08 에서 찾을 수 있다. 
이 장에 대한 수행 영상은 여기서 찾을 수 있다.
https://bit.ly/3g6UDMJ

에지 사이드 구성의 기초
웹 접근 방식을 순수하게 링크만 가져오는 것으로 생각한다면 에지 측 구성은 웹 접근 방식 외에 가장 오래된 패턴일 수 있다. 이미 알고 있듯이 SSI 및 이후의 ESI와 같은 기술은 HTML 페이지에 HTML 조각을 배치하기 위해서 발명되었다. 이것은 재사용 가능한 레이아웃을 만드는 간단하면서 유연한 방법이었다.

물론 SSI가 도입됐을 때 CDN(컨텐츠 전송 네트워크)과 분산 개발은 그렇지 않았다. 그러나 이전 장에서 보았듯이 UI 삽입 지점을 나타내는 좋은 방법을 찾고 있을 때 SSI 또는 그 후속 제품인 ESI를 사용하는 것이 좋다. SSI 또는 ESI 는 가장 광범위하게 채택됐고 명세로 관리되는 명확한 규칙이 있기 때문이다. 

샘플 구현을 수행하기 전에 아키텍처를 살펴보자. 마지막에는 샘플 구현에 대한 몇 가지 잠재적인 개선 사항에 대해 설명한다.


아키텍처
당연히 에지 측 구성 패턴의 아키텍처 다이어그램은 서버 측 구성 패턴과 크게 다르지 않다. 하지만 다이어그램에서 볼 수 있듯이 중요한 차이점은 집계 계층의 사용 여부에 있다.

 


이 아키텍처에서 다소 멍청한 결합(stitching) 메커니즘을 이해해야 한다. 

예를 들어 폼을 제출하면 전체 페이지에 걸쳐 동작한다. 마이크로 프론트엔드에서 어려운 문제를 해결할 수 있는 방법을 미리 알게 하여 게이트웨이에서 해결하게 만들지 않는다. 

사용되는 에지 사이드 오퍼링에 따라 모든 집합 계층은 어떠한 유저에게도 전달될 수 있도록 서로 다른 조각들을 하나의 정적이고 캐싱된 HTML 문서로 결합한다. 물론 커스텀 코드를 돌릴 수 있도록 하는 다른 오퍼링도 많다. 엣지에서 마이크로 프론트엔드를 통합한다면 서버리스 함수를 사용하는 것도 심지어 가능하다. 

이전 예제를 기존 CDN 오퍼링에 배포하기 전에 에지에서 작동하도록 조정해보겠다.

예제 구현
이전 장의 예시에서 트랙터 저장소를 매우 강력한 집계 계층을 사용하여 분산 방식으로 작동하도록 만들었다. 에지 측 구성 패턴의 아키텍처를 따르려면 이 집계 계층의 책임을 줄여야 한다. 결과적으로 이것은 각 마이크로 프론트엔드가 더 많은 작업을 수행하고 구성에 대해 더 많이 알아야 함을 뜻한다.

현실적으로 백엔드 기반 트랙터 저장소는 에지 측 구성에 있어 좋지 않다. 나중에 클라이언트에 일부 기능을 배치하여 이것을 변경할 수 있다. 그럼에도 불구하고 캐싱과 같이 CDN을 사용하여 얻을 수 있는 이점을 없앰으로써 여전히 동작하게 만들 수 있다.

이 예에서는 단일 저장소로 돌아간다. 이 선택은 단순성 때문이지 에지 측 구성을 사용하는 저장소 구조에 대한 제약을 반영하진 않는다. 서버 측 구성의 예제에서 시작하여 다음 변경만 하면 된다.

•	게이트웨이를 CDN 오퍼링, Varnish 또는 Nginx와 같은 좀 더 적절한 에지 층으로 교체한다.
•	전체 페이지를 전달하기 위해 빨간색 마이크로 프론트엔드의 코드를 수정한다. 이것을 에지 층의 기초로 사용할 것이다.
•	모든 마이크로 프론트엔드에서 뷰를 수정하여 완전히 준비된 URL을 반환한다. 완전한 URL은 각각 올바른 파일 또는 마이크로 프론트엔드 서비스를 각각 결합한다. 

우리의 의도는 이전 예제를 최소한의 변경으로 에지 측 구성 패턴에 알맞게 바꾸는 것이다. 예를 들어 초록색 마이크로 프론트엔드에서는 경로만 변경하면 된다.  /Recommendations와 같은 마이크로 프론트엔드에 독립적인 경로에 의존하는 대신 접두사를 다시 도입(예: /green/Recommendations)해야 한다. 이는 뷰에도 반영되어야 한다.
<link rel="stylesheet" href="/green/recommendations.css">
<div class="green-recos" id="reco">
<h3>Related Products</h3>
<% recommendations.forEach(recommendation => { %>
<img src="/green/images/reco_<%= recommendation %>.jpg"
alt="Recommendation <%= recommendation %>">
<% }); %>
</div>

게이트웨이에서 변환된 상대 경로를 사용하는 이전 규칙은 이제 마이크로 프론트엔드별 접두사가 포함된 절대 경로로 대체되었다. 너무 많은 변경을 도입하는 대신 ejs 문법을 유지했다. 

일반적으로 파란색 마이크로 프론트엔드도 비슷한 변화를 보였다. 유일한 차이점은 이 마이크로 프론트엔드에도 POST 엔드포인트를 가진다는 점이다. 이를 변환하면 다음과 같이 변경된다.

app.post("/blue/buy-button", (req, res) => {
// ... as before

res.redirect(`http://localhost:1234/red/product-
page?sku=${sku}`);
});

이제 에지 층의 주소로 리다이렉션 할 수 있다. 이 때 에지 층의 주소를 알고 있다고 가정한다. 

마지막으로 빨간색 마이크로 프론트엔드의 경우 URL 변경 사항을 도입하고 이전에 게이트웨이 층에서 템플릿으로 유지되었던 레이아웃을 가져와야 한다. 또한 다른 모든 마이크로 프론트엔드를 참조할 필요가 있다. 지금 마이크로 프론트엔드를 참조하는 방식은 전적으로 에지 측에 의존한다. 만약 Nginx를 사용한다면 SSI가 직접적으로 지원되는 반면 ESI는 플러그인을 통해서만 지원되므로 SSI를 사용하게 될 것이다. 

이러한 변경을 수행하면 다음과 같은 새 제품 페이지 컨텐츠가 제공된다.




<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Tractor Store</title>
<meta name="viewport" content="width=device-width,
initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<link href="/red/style.css" rel="stylesheet">
<link href="/red/product-page.css" rel="stylesheet">
</head>
<body>
<div id="app">
<h1 id="store">The Model Store</h1>
<!--# include virtual="/blue/basket-info?sku=<%=
current.sku %>" -->
... as before
<!--# include virtual="/blue/buy-button?sku=<%=
current.sku %>" -->
<!--# include virtual="/green/recommendations?sku=<%=
current.sku %>" -->
</div>
</body>
 </html>
 
본질적으로 이는 빨간색 마이크로 프론트엔드에 대해서만 이전 템플릿을 사전 평가한 결과다. 
안타깝게도 빨간색 마이크로 프론트엔드는 다른 소스의 접두사를 알아야 한다. 가능한 리다이렉션과 다른 속임수 때문에 더 느슨한 모드가 인정될지라도 이것은 위험 신호가 아니다. 

마지막으로 에지 층에서 Nginx로 이동한다. 여기에는 여러 가지 이유가 있다.
•	Nginx는 상당히 이해하기 쉬운 구성이다.
•	Docker 컨테이너 내에서 문제 없이 실행할 수 있다.
•	이미 많은 웹 애플리케이션의 기초이다.
•	성능이 우수하여 생산에도 적합하다.

주어진 임무는 올바른 역방향 프록시 동작을 만들기 위해 Nginx를 구성하는 것이다. 
여기에서 올바른 서버로 리다이렉션하기 위해 접두사당 하나의 부분을 구성해야 한다.

이 예에서는 지난 시간에 사용할 설정을 사용하여 다음 구성을 만들 수 있다.

server {
listen 80;
server_name frontend;
location /red {
ssi on;
proxy_pass http://host.docker.internal:2001;
}
location /blue {
ssi on;
proxy_pass http://host.docker.internal:2002;
}
location /green {
ssi on;
proxy_pass http://host.docker.internal:2003;
}
 }

 

여기에서 훨씬 더 많은 옵션을 설정할 수 있지만 (예: 역방향 조회 또는 캐시 동작에서 사용을 나타내는 사용자 지정 헤더) 이전 구성으로 시작하기에 충분하다.

여기에서 사용한 URL은 이러한 마이크로 프론트엔드가 실행되는 실제 URL로 대체되어야 한다. 마이크로 프론트엔드가 호스트에서 직접 실행되고 에지가 도커 컨테이너에서 실행되는 로컬 설정에서 특수 DNS인 host.docker가 통신을 맺기 위해 필요하다. 
이 구성을 실행하기 위해 Dockerfile은 다음 두 줄로 구성된다.


FROM nginx:latest
COPY ./nginx.conf /etc/nginx/conf.d/default.conf

이러한 약간의 변경으로 우리 솔루션은 자체 인프라 내에서 리소스를 많이 사용하는 집계 계층 대신 에지 계층과 완벽하게 동작할 수 있다.
그러나 평소와 같이 데모 샘플을 개선할 수 있는 가능성은 있다.

잠재적인 개선 사항
서버 측 구성에서는 느슨한 결합을 위해 동적 연결 디렉토리를 도입했다. 에지 측 구성에서는 덜 강력한 집계 층을 제공하므로 이 개선 사항은 삭제해야 할까 아니면 있어야 할까?

서버 측 구성 위에 에지 측 구성을 개선 사항으로 사용하는 경우 연결 디렉터리가 여전히 관련이 있을 수 있음을 밝혔다. 이 시나리오에서 에지 측 구성은 서버 측 구성의 집계 계층 역할을 하는 역방향 프록시를 통해 모든 마이크로 프론트엔드를 확인한다. 유일한 차이점은 이 집계 레이어가 마이크로 프론트엔드를 해결하고 페이지 템플릿을 제공하는 역할만 한다는 것이다. 마이크로 프론트엔드를 직접 연결하지는 않는다. 

또 다른 개선 사항은 모든 마이크로 프론트엔드에서 직접 캐시 무효화를 허용하는 것이다. CDN에서 자주 업데이트를 수행하는 것은 허용되지만 처음에는 불필요한 로드를 쉽게 생성하고 실제로는 바람직하지 않을 수 있다. 결국에는 폴링 메커니즘이 항상 실패하므로 필요없거나 너무 늦을 것이다. 

이러한 개선 사항 외에도 에지 측 구성을 사용할 때 어떤 장점과 단점이 있을까? 알아보자.

장점과 단점
이 패턴의 장점과 단점을 다루기 위해서 비슷한 서버 측 구성을 살펴볼 필요가 있다. 올바르게 수행되면 에지 측 구성이 훨씬 더 가벼워지고 캐싱과 같은 작업을 수행할 수 있다. 이것은 더 정교한 알고리즘이나 트릭을 요구하지 않고도 웹사이트의 성능을 크게 향상시킨다.  

캐시되지 않은 응답도 에지 측 구성에서 더 빠를 수 있는 이유 중 하나는 조각이 겹쳐지지 않았기 때문이다. 이전 패턴에서 중첩된 조각들을 활용할 수 있을 뿐 아니라 실제로 그렇게 하도록 권장했다. 그러나 평평한 구조가 아닌 경우에도 간단한 트릭을 사용하여 평평하게 만들 수 있다. 코드를 사용하여 이를 설명한다.

// index.html (original)
<esi:include src="http://example.com/fragment1.html" />

// fragment1.html
<esi:include src="http://example.com/fragment2.html" />

// fragment2.html
<div>...


CDN에서 미리 평가된 fragment1.html 버전을 배치하여 이것을 평면 구조로 변환할 수 있다.

// index.html
<esi:include src="./fragment1.html" />

// fragment1.html (original)
<esi:include src="http://example.com/fragment2.html" />

// fragment1.html (as served)
<div>...

따라서 절대 URL을 통해 fragment1-1.html에 직접 요청하는 것 대신에 동일한 CDN에서 요청한다. 이로 인해 ESI 지시문이 포함되지 않은 사전 평가된 버전이 생긴다. 

그럼에도 불구하고 에지 측 구성을 사용할 때 권장 사항은 트릭을 수행할 필요 없이 가능한 평평한 구조를 유지하는 것이다. 이렇게 하면 디버깅이 훨씬 간단해진다. 이렇게 얻은 단순성으로 또 다른 이점은 캐싱이다.

샘플을 구현할 때 이전 장에서 본 동작을 요약해보자. 
집계 계층에서 페이지를 요청하면 몇 가지 요청이 발생한다. 
다음 다이어그램은 응답을 기다리는데 소요된 시간을 보여준다.
 



에지 측 구성에 따라 이것을 평평한 구조로 만들어야 한다. 응답 시간이 가장 나쁜 부분은 페이지 생성 시간을 지배하므로 전체 응답 시간이 된다. 그러나 전송 시간은 그대로 유지된다. 

반면에 여전히 명백한 단점을 고려하더라도 평평하게 하는 것은 가장 긍정적으로 성능에 영향을 미친다. 다음 다이어그램은 이를 보여준다.
 


에지 측 구성을 사용하면 템플릿을 삭제하고 빨간색 마이크로 프론트엔드의 페이지 결과로 교체한다. 이 예에서 이것이 구조를 평평하게 한다. 

그러나 이러한 변경 외에도 가능한 경우 다른 소스가 캐시되도록 해야 한다. 장바구니(Basket)의 경우 잠재적으로 좀 더 정교한 검색이 필요할 수 있지만 나머지 두 조각의 경우 캐시의 수명이 길어질 수 있고 로직도 많이 필요하지 않을 수 있다. 

다음 다이어그램은 에지 측 구성에 의해 제안된 최종 대상을 포함한다. 전송에 필요한 대역폭을 줄이지는 못할 수 있지만 응답 시간을 줄일 수는 있다.


 





에지 측 구성의 주요 단점은 몇 가지 경우로 제한된다는 것이다. 예에서 보았던 것처럼 이것은 우리가 몇몇 사례를 단순화시켰기 때문에 가능했다. 또한 마이크로 프론트엔드의 URL에 직접 폼을 보냈어야 했다. 이는 일반적으로 피해야 할 사항이다. 따라서 에지 측 구성의 거의 모든 구현은 다소 단순하거나 서버 측 구성과 같은 다른 패턴 위에서만 사용한다.

에지 측 구성은 몇몇 회사에서 사용한다. 대부분의 경우 이러한 솔루션은 에지 측 구성에만 기반을 두지 않고 일부 다른 패턴과 함께 사용한다. 에지 측 구성을 많이 활용하는 회사는 IKEA이다. 그들의 웹 사이트는 또 다른 웹 상점이기 때문에 백엔드 기반의 프론트엔드가 이런 종류의 문제에 매우 타당하다는 가설이 있다. 

에지 측 구성의 특징 중 하나는 표준 SSI 및 ESI에 대한 의존도가 높다는 것이다. 이에 대해서는 다음 장에서 더 자세히 살펴보겠다.

 
SSI 및 ESI
서론 장을 주의 깊게 읽었다면 SSI와 그 후속 제품인 ESI가 클라이언트 측 메커니즘 프레임셋을 서버 측 프레임셋으로 대체하기 위해 발명되었다는 것을 알 수 있다. 여기에는 여러가지 이유가 있다.

•	프레임셋은 더 많은 요청을 필요로 했다.
•	프레임셋은 부모의 기본 스타일이나 구조를 이용할 수 없었다.
•	프레임셋은 일반적으로 웹 사이트를 일관성 없게 만든다.

당연히 가장 먼저 변경된 것은 <frameset> 구성 요소이다. 첫 번째 인상은 백엔드가 제대로 처리하지 못할 경우에 대비하여 클라이언트에 이 추가 사항을 숨겨 두는 것이었기 때문에 다른 메커니즘을 선택해야 했다. 

특별한 코멘트가 탄생했다.

  <!--#include virtual="../quote.txt" -->	



일부 웹 서버에는 정적 파일에 대해 특별한 종류의 파일 확장자가 필요하고 다른 웹 서버에는 SSI가 활성화되도록 구성할 필요가 있다. 

SSI
거의 모든 웹 서버(최소한 Apache, LiteSpeed, Nginx 및 IIS)에서 지원하는 일반적인 SSI 지시문은 다음과 같다.
•	include는 virtual 또는 file 속성에 지정된 파일의 내용을 포함한다.
•	exec는 cmd 또는 cgi 속성에 있는 프로그램 또는 스크립트 실행의 결과를 배치한다.
•	echo는 var 속성에 정의된 환경 변수를 표시한다.
•	config는 해당 속성에 의해 주어진 날짜, 시간 또는 파일 크기에 대한  표시 형식을 구성한다. (예: 시간의 경우 timefmt)
•	flastmod는 virtual 또는 file 속성으로 지정된 파일이 마지막으로 수정된 날짜를 표시한다.
•	fsize는 virtual 또는 file 속성으로 지정된 파일의 크기를 표시한다.

여기에는 훨씬 적은 수의 웹 서버에서만 지원되는 제어 지시문이 포함된다. 이 모든 것을 지원하는 서버 중 하나는 Apache이다. 이는 다음과 같다.

•	if는 expr 속성에 지정된 조건을 평가한다.
•	elif는 이전 if 지시문이 실패 했을 때 expr 속성에 지정된 다른 조건을 평가한다.
•	else는 if 지시문이 실패한 경우 대체 컨텐츠 조각을 사용한다.
•	조건부 컨텐츠를 중지하려면 endif를 지정해야 한다.
•	set은 var 속성에 명명된 변수에 value 속성에 지정된 새 값을 제공하는데 사용할 수 있다. 
•	printenv는 사용 가능한 모든 변수를 출력한다.

웹 서버에 대한 지원은 훌륭하지만 CDN 공급자에 대한 지원은 상당히 평범하다. 여기서 보다 현대적인 대안인 ESI가 일반적이다. 

ESI
많은 CDN 공급자는 ESI 사용을 지원한다. 그 중 인기 있는 선택은 CloudFlare, Akamai 또는 Fastly이다. 널리 지원되는 이유 중 하나는 ESI가 이미 이러한 CDN인프라의 일부인 Varnish에서 사용할 수 있기 때문이다. 

다음 코드 조각을 사용하여 Varnish에서 ESI를 활성화할 수 있다.
sub vcl_fetch {
if (req.url ~ "/*\.html") {
  set beresp.do_esi = true; /* Do ESI processing */
  }
}

이렇게 하면 모든 정적 HTML 페이지에서 에지 측 포함을 활성화한다. 

좀 더 현대적이라는 것 외에도 ESI의 채택이 증가한 핵심 이유 중 하나는 https://www.w3.org/TR/esi-lang/ 에서 찾을 수 있는 공식 W3C 사양을 기반으로 하기 때문이다.

SSI가 모든 기능을 특별한 주석 노드에 배치하는 동안 ESI는 esi:include와 같은 esi 접두사를 가진 표준 구성 요소를 사용했다. 이러한 태그를 사용하는 한 가지 장점은 트리 기능을 사용할 수 있다는 것이다. 예를 들어 esi:try 태그는 자동으로 닫히지 않으며 esi:attempt 및 esi:try 태그를 사용하는 동안 필요한 구조를 포함한다.
<esi:try>
Ignored markup here...
<esi:attempt>
<esi:include ... />
This line is valid and will be processed.
</esi:attempt>
Ignored markup here...
<esi:except>
This HTML line is valid and will be processed.
</esi:except>
Ignored markup here...
</esi:try>

이러한 구조적 이점을 바탕으로 ESI는 SSI보다 훨씬 더 많은 경우를 다룰 수 있다. ESI의 힘을 보여주는 한 가지 예는 조건부 요소이다. esi:choose를 사용하여 esi:when으로 작성된 자식 노드의 다양한 경우를 반복할 수 있다. 

기본적인 경우는 esi:otherwise로 표시된다. 이제 이것은 SSI의 if 조건과 매우 유사해 보이지만 esi:when의 테스트 속성에 사용되는 표현식은 훨씬 더 유연하다.
공식 명세의 예를 살펴보자.

<esi:choose>
<esi:when test="$(HTTP_COOKIE{group})=='Advanced'">
<esi:include src=
"http://www.example.com/advanced.html"/>
</esi:when>
<esi:when test="$(HTTP_COOKIE{group})=='Basic User'">
<esi:include src="http://www.example.com/basic.html"/>
</esi:when>
<esi:otherwise>
<esi:include src=
"http://www.example.com/new_user.html"/>
</esi:otherwise>
</esi:choose>


여기에서 사용한 식은 QUERY_STRING, HTTP_COOKIE, HTTP_HOST, HTTP_USER_AGENT와 같은 ESI 변수를 사용할 수 있다. 이렇게 하면 특히 HTML에서 직접적으로 변수로 사용한다.
예를 들어 esi:vars 블록을 입력하면 다음과 같이 HTML 코드를 작성할 수 있다.

<esi:vars>
  <img src="/$(HTTP_COOKIE{type})/hello.gif”>
</esi:vars>


이러한 특수 구조를 바꾸려면 esi:vars를 통해서만 가능하다. 그렇지 않으면 이전 예제의 마지막 출력은 문자 그대로 /$(HTTP_COOKIE{type})/hello.gif 가 이미지 소스로 포함된다.

마지막으로 ESI를 사용할 수 없는 경우 ESI 장식이 표준 렌더링을 방해할 수 있다고 우려될 경우 특별 설명 주석 부분으로 돌아갈 수 있다. HTML의 일부를 <!—esi … --> 로 감싸고 이러한 부분이 ESI 호환 웹 서버에서 처리될 때만 표시되도록 할 수 있다. 이 경우 특수 주석 부분이 제거되고 …만 내용으로 남는다.

이제 마침내 집계 계층이 동작하여 여러 소스에서 하나의 웹사이트를 구성할 수 있다.

BFF의 결합하기
전용 집계 계층의 개념은 서버 측 구성과 에지 측 구성의 중요한 부분이다. 그러나 이 두 가지 패턴을 넘어서 BFF가 HTML을 렌더링하기 위한 집계 계층뿐만 아니라 프런트엔드에만 관련된 정보를 제공하기 위해 모든 종류의 작업에 사용되는 것을 볼 수 있다. 

일반적으로 클라이언트 측 구성과 결합이 브라우저에서 흔하지 않은 건 아니지만 중앙 소스에서 모든 것을 제공함으로써 잠재적인 성능 향상(캐시까지 가능)을 과소평가 해서는 안된다.

정적 리소스를 더 빠르게 제공하기 위해 CDN을 가져오는 것은 확실히 성능을 높이기 위한 좋은 방법이다. 서버 측 구성과 에지 측 구성을 적절히 조합하면 서버에서 레이아웃과 고급 HTML 조각(예: 폼)을 사용하고 최종 조각을 평평한 결합 방식으로 모을 수 있다. 

평평한 결합은 최대 깊이가 1인 ESI 또는 SSI 해상도를 나타낸다. 즉 ESI 또는 SSI를 통해 조각을 합쳐도 일부 해상도가 필요한 다른 HTML 조각이 생성되지는 않는다.

 
요약
이 장에서는 에지 측 구성이 고객에게 마이크로 프론트엔드를 더 가까이 제공하는 데 어떻게 도움을 주는지 배웠다. 에지 측 구성을 사용하면 서버 측 구성을 보다 단순하면서도 빠르게 대체할 수 있다. 하지만, 기본적인 성능 향상 외에도 우리는 패턴을 뒷받침하기 위해 마이크로 프론트엔드에 신중할 필요가 있다. 서버 측 구성에 사용되는 많은 툴과 프레임워크를 에지 측 구성에 적어도 부분적으로 활용할 수 있는 것은 우연이 아니다.

이 패턴은 마이크로 프론트엔드가 서버 측 구성보다 덜 복잡하다는 제약 하에 정보 중심 웹사이트에도 사용될 수 있다.

다음 장에서는 클라이언트에서 마이크로 프론트엔드를 완전히 구성함으로써 한 단계 더 나아간다. 새로운 도전과 기회가 기다리고 있다. 
 
9 클라이언트 사이드 구성
이전 장에서는 백엔드에 매우 잘 적용되는 마이크로 프론트엔드를 배웠다. 마이크로 프론트엔드는 개별적인 서버에 의해 렌더링되고 프레임 또는 어떤 통합 레이어에 의해 구성된다. 이제 잠시 주제를 옮겨서 어떻게 클라이언트에 마이크로 프론트엔드를 함께 붙일 수 있는 지 확인해보자. 보통 이것은 브라우저 단에서 의미한다. 

앞에서 이야기했던 트랙터 매장의 예와 같이 서버 사이드 구성은 대화형 페이지에 몇 가지 문제를 가져올 수 있다. 양식 처리와 관련된 문제를 기억한다면 순전히 클라이언트에서 이 문제를 훨씬 더 쉽게 해결할 수 있었을 것이다.

이 장에서는 클라이언트 사이드 구성의 패턴에 대해 다루고 마이크로 프론트엔드를 셋업하고 구현하는 또다른 가능성을 제공한다.

이 장에서는 다음의 주제들을 다룰 예정이다.
•	클라이언트 사이드 구성의 기본 요소
•	장점과 단점들
•	웹 구성 요소 살펴보기
•	동적으로 마이크로 프론트엔드 구성하기

이 장을 다 배우면 언제 클라이언트 사이드 구성을 하면 되는 지 그리고 어떻게 실질적으로 구현할 수 있는 지에 대해 이해할 수 있게 된다.

기술적인 필요 조건
이 장의 예제 구현을 따라하기 위해서는 Node.js와 webpack 그리고 DOM에 대한 지식이 있어야 한다. 
이 장의 코드는 https://github.com/PacktPublishing/The-Art-of-Micro-Frontends/tree/main/Chapter09 에서 확인할 수 있다. 
이 장에 대한 액션 비디오의 코드는 https://bit.ly/3uJYTqq에서 확인할 수 있다.

클라이언트 사이드의 기본 구성
클라이언트 사이드 구성의 아름다움은 단순함과 직접성에 있다. 어떤 복잡한 백엔드 인프라에 대한 필요성 없이 여기 고용된 현대 웹 철 철학이 많다. 주요 구성 요소는 일반적으로 다른 메커니즘을 사용할 수도 있지만 웹 구성 요소를 사용하는 프레임워크에 구애 받지 않는 전송 메커니즘이다. 

예제 구현을 위한 필수 단계를 수행하기 전에 클라이언트 사이드 구성의 아키텍처를 살펴보는 것으로 시작한다. 마지막으로 예제의 잠재적인 개선 사항을 살펴본다.

아키텍처
이전 장에서 완전히 구성된 HTML 문서를 브라우저에 돌리기 위해서 항상 백엔드 컴포넌트에 의존한다. 만약에 브라우저가 집합 레이어의 일을 맡으면 어떨까? 추측한 게 맞는 것처럼, 정답은 클라이언트 사이드 구성의 구조에 있다. 

그림 9.1에서 보이는 것처럼, 클라이언트 사이드 구성은 집합 레이어가 필요하지 않다. 그대신 스크립트 레퍼런스를 포함하는 주요한 HTML 문서의 위치를 알 필요가 있다. 이 주요한 HTML 문서는 종종 어플리케이션 쉘이나 그냥 앱 쉘이라고 불린다. 앱 쉘은 개별적인 마이크로 프론트엔드를 표현하는 스크립트들 같은 가장 중요한 자원들의 레퍼런스를 갖고 있다. 

 
그림 9.1 – 클라이언트 사이드 구성은 자바스크립트를 사용하여 나머지 조각을 로드하고 표시한다. 

이상적으로, 이 스크립트들은 가능한 독립적이다. 그들은 전용 서버들이나 중앙 집중적인 콘텐츠 제공자로부터 제공받을 수 있다. 이를 게시하는 한 가지 간단한 방법은 번들로 묶는 것이다. UNPKG 또는 jsDelivr과 같은 CDN(콘텐츠 전송 네트워크) 미러에서 사용되는 npm 패키지로 제공된다.

중요한 노트

npm 패키지는 압축된 타르볼일 뿐이다. npm 패키지에는 메타데이터에 대한 package.json 파일과 원래 디렉터리의 무시되지 않은 모든 파일이 포함되어 있다. npm 패키지는 npm pack 명령으로 생성된다. 패키지 게시는 npm publish를 사용하여 수행할 수 있다.

스크립트의 실제 내용은 다소 임의적일 수 있지만 클라이언트 사이드 구성은 일반적으로 확립된 메커니즘과 고정 패턴에 의존한다. 가장 편리한 방법 중 하나는 웹 구성 요소를 사용하는 것이다.

웹 구성요소를 사용하는 것은 많은 유연성과 자유를 준다. 그것은 어떤 어플리케이션 내에서도 특정한 마이크로 프론트엔드를 도입할 수 있게 해준다. 마찬가지로 웹 구성 요소에는 문제를 동반하며 이를 해결하고 길들여야 한다. 이 장에서 이것을 조금 더 구체적으로 살펴볼 것이다.

아키텍처 관점에서 양극단 두 개 사이에서 하나를 선택한다.
•	웹 구성 요소마다 하나의 스크립트를 갖는 것
•	마이크로 프론트엔드마다 하나의 스크립트를 갖는 것

전자를 일반적으로 좋은 생각이지만 후자는 훨씬 간단하고 약간 더 좋은 성능을 제공한다. 웹 구성 요소마다 하나의 스크립트를 갖는 것은 같은 도메인에 속하는 것들의 오케스트레이션을 격국 더 복잡하게 만든다. 

한편, 하나의 마이크로 프론트엔드 마다 하나의 스크립트를 갖는 것은 단일 웹 구성 요소가 필요한 어플리케이션에 대한 오버헤드를 초래한다. 결과적으로 이러한 결과는 ‘4. 도메인 분리’ 장에서 기술한 도메인 분리의 원리로 되돌아 간다. 

브라우저에서 구성되도록 트랙터 저장소를 변환하는 예제 구현을 살펴보자.

예제 구현
클라이언트 사이드 구성 요소 패턴의 적절한 구현을 하기 위해서 이전 코드 베이스를 시작 지점으로 한다. 

각각의 마이크로 프론트엔드에서 각각의 파편에 대해 하나의 스크립트를 생성할 것이다. 파란색 마이크로 프론트엔드는 두 개의 스크립트로 끝나는 반면 다른 마이크로 프론트엔드는 단일 스크립트만 생성한다. 이러한 스크립트를 생성하는 것은 여러 가지 방법으로 수행할 수 있다. 직접 작성할 수도 있지만 이미지나 스타일시트와 같은 자산에 대한 참조에 문제가 있을 수 있다. 번들러와 같은 도구를 사용할 수도 있다.

지금 가장 유명한 번들러는 웹팩(webpack)이다. 웹팩은 일부 자바스크립트 파일을 진입점으로 사용하고 가져오기(import)를 수행하여 최적화된 방식으로 본 입력을 나타내는 일부 출력 파일을 생성한다. 예를 들어, 자바스크립트 파일들을 최소화하고 하나의 에셋으로 합친다. 또한, 향상된 디버깅을 위해 소스 맵을 쓰거나 추가적인 리소스를 레이지 로드하는 것도 가능하다. 

이 경우에는 웹팩(webpack.config.js)의 구성 파일은 아래와 같다.
module.exports = {
entry: {
"product-page": "./src/product-page.js",
},
output: {
filename: "[name].js",
path: dirname + "/dist",
publicPath: "http://localhost:2001/",
},
devtool: "source-map",
module: {
rules: [
{
test: /\.(png|svg|jpg|gif)$/i,
use: ["file-loader"],
},
{
test: /\.css$/i,
use: [
{ loader: "style-loader", options: { injectType:
"linkTag" } },
{ loader: "file-loader" },
],
},
],
  },
};
이것은 file-loader를 사용해서 파일 레퍼런스들을 만들 수 있는 가장 기본적인 웹팩 파일이다. style-loader는 임포트 되어진 CSS 파일을 참조하는 레퍼런스를 사용하여 자동적으로 <link> 테그를 가져올 수 있다. 

CSS 파일 import는 ES 모듈의 명세를 통해 쓸 수 있다. 
import "./style/basket-info.css";

BasketInfo와 같은 개별 웹 구성 요소는 sku 속성의 변경 사항을 수신 대기하는 HTML 요소일 뿐이다.

sku 속성 값을 변경할 때 웹 구성 요소를 다시 렌더링하거나 콘텐츠의 일부를 변경해야 할 수 있다. 가장 쉬운 방법 중 하나는 가장 파괴적이고 성능이 가장 낮은 방법 중 하나는 사용자 정의 요소의 innerHTML 속성을 설정하는 것이다. 이것은 요소에서 모든 자식 노드를 제거하고 주어진 HTML 내용을 다음과 같이 구문 분석한다. 프래그먼트를 만들고 결과 프래그먼트의 노드를 요소에 추가한다. BasketInfo의 경우 구현은 다음과 같을 수 있다. 

class BasketInfo extends HTMLElement {
constructor() {
super();
this.render();
}
static get observedAttributes() {
return ["sku"];
}
render() {
const count = items.length;
this.innerHTML = `
<div class="${count === 0 ? "empty" : "filled"}">
basket: ${count} item(s)</div>
`;
}
attributeChangedCallback(name, oldValue, newValue) {
if (name === "sku" && oldValue !== newValue) {
this.render();
}
}
}
 

사용자 정의 요소를 실제로 사용하기 전에 이름도 지정해야 한다. 관례에 따라 이름은 케밥 케이스 스타일을 따라야 한다. 케밥의 경우 식별자는 모두 다른 세그먼트를 연결하는 빼기 기호(-)와 소문자다. BasketInfo 클래스의 경우 결과는 다음과 같다.

customElements.define("basket-info", BasketInfo);

특히 장바구니 정보와 구매 버튼 구성 요소의 상호 작용을 위해서는 공통 메커니즘이 필요하다. 운 좋게도 두 구성 요소는 동일한 마이크로 프론트엔드에서 제공되지만 독립적으로 배포 및 탑재되기 때문에 여기에서 상태 변경을 전달하는 방법이 여전히 필요하다.

이전에는 페이지 새로 고침과 함께 세션을 사용하여 그에 따라 바구니를 업데이트했다. 이제 DOM 이벤트를 사용하여 변경 사항을 전달할 수 있다. 버튼을 누르면 add-item이라는 사용자 정의 이벤트가 발생한다. 바구니는 이 이벤트를 수신하고 상태를 변경한다. 이 새로운 상태 변경에 대해 잠재적으로 관심이 있는 UI 조각에 알리기 위해 또 다른 사용자 지정 이벤트인 added-item이 전달된다.

코드에서 바구니 모듈의 상태 논리는 다음과 같이 작성할 수 있다.

const items = [];
window.addEventListener("add-item", () => {
items.push("...");
window.dispatchEvent(new CustomEvent("added-item", {
detail: items }));
});


마지막으로 클라이언트 사이드 구성을 위한 앱 쉘을 정의할 필요가 있다. 어플이케이션에서 product-page가 있는 것을 알기 때문에, 그것을 body에 넣어야 한다. 그것을 제외하고는 모든 컴포넌트를 위한 스크립트들을 포함해야 한다.

스크립트는 개별적인 웹 서버에 배포되고 개별적인 팀들에 의해 관리된다. 예제 구현에서, localhost에 대한 그들의 포트를 언급했다. 

<body>
<product-page id="app"></product-page>
<script src="http://localhost:2001/product-
page.js"></script>
<script src="http://localhost:2002/basket-
info.js"></script>
<script src="http://localhost:2002/buy-
button.js"></script>
<script src="http://localhost:2003/product-
recommendations.js"></script>
</body>

이를 브라우저에서 렌더링하면 그림 9.2와 같은 DOM이 생성된다. 개별 조각에 대한 이전 <div> 래퍼가 사용자 지정 요소로 대체되었으며 전체 구조는 여전히 동일하다.
 
그림 9.2 – 앱 쉘에 의해 생성된 DOM

따라서 앱 셸은 이러한 요소로 완전히 구성된다. 그림 9.3에서 장바구니 정보, 구매 버튼 및 제품 추천과 같은 구성 요소에 의존하는 제품 페이지 구성 요소로 시작하여 구성이 매우 자연스럽게 작동했음을 알 수 있다. 구성 요소는 먼저 스크립트에서 가져와야 했다.


 
그림 9.3 – 앱 쉘은 개별적인 웹 구성 요소를 이용해서 프론트엔드를 구성한다. 

 웹 사이트는 직접적으로 실패하지 않으므로 웹 구성 요소 자체도 충돌하지 않는다. 예를 들어 제품 추천을 제공하는 서버가 다운되면 제품 추천은 빈 자리 placeholder로 남게 된다. 반면에 폴백을 사용해야 하는 것보다 폴백을 사용해서 이런 경우를 찾는 것이 더 어렵다.




중요한 노트

클라이언트 사이드 구성은 서버 사이드 렌더링 페이지의 개션 용도로 자주 사용된다. 전체 렌더링이 클라이언트에서 수행되는 단일 페이지 어플리케이션의 경우 라우팅 엔진도 사용해야 한다. 프레임워크별 솔루션이 존재하는 한 프레임워크에 독립적인 접근 방식을 선택해야 한다. 또 한 가지 해결책은 범용 라우터를 사용하는 것이다. 자세한 내용은 https://kriasoft.com/universal-router/에서 확인할 수 있다.

앱 셸이 매우 간단하기 때문에 잠재적인 개선 사항이 많이 있을 것이다. 그렇지 않은가? 같이 한 번 살펴보자.

잠재적인 개선 사항
잠재적인 개선 사항을 살펴보면 이상하게 여겨질 만한 몇 가지 사항을 직접 확인할 수 있다. 예를 들어 앱 셸은 모든 스크립트 참조를 포함해야 한다. 이상적으로 앱 셸은 웹 구성 요소 디렉터리의 위치만 알면 되며, 이 디렉터리는 활발하게 사용되는 웹 구성 요소를 자동으로 로드하는 데 사용된다. 이런 식으로 마이크로 프론트엔드는 필요할 때 각각의 스크립트를 로드하는 앱 셸과 함께 원하는 웹 구성 요소를 사용할 수 있다.
고려해야 할 또 다른 사항은 앱 셸의 책임을 강화하는 것이다. 이 간단한 예에서는 앱 셸에 기본 HTML 구조, 핵심 스타일 및 스크립트 참조만 있다. 인증, 로깅 또는 오류 처리와 같은 항목은 포함되지 않지만 실행 가능한 추가 항목이 될 수 있다.
마지막으로 마이크로 프론트엔드당 단일 서버가 필요하지 않아야 한다. 이러한 정적 파일을 염두에 두고 대부분의 마이크로 프론트엔드는 정적 파일을 제공하는 방법만 있으면 된다. 이 경우 간단한 CDN과 같은 메커니즘이면 충분하다. 역설적이게도 이 아름다운 부작용으로 더 적은 DNS 조회가 필요하고 최신 전송 메커니즘을 활용할 수 있다.
이 접근 방식은 어떤 장점과 단점을 제공할까? 함께 알아 보자.

장점과 단점
가장 명백한 장점이자 단점은 클라이언트 사이드 구성이 자바스크립트에 의존한다는 것이다. 이로 인해 성능 문제와 접근성 문제가 발생한다. 여기에는 개선할 수 없는 것이 아니라 현명하게 고려하고 대처해나가야 할 사항이 있다.

웹 컴포넌트 표준 자체는 화려한 추상화보다는 기본에 중점을 둔 널리 구현된 표준이다. 분명히 이것은 변경 사항이 기존 구현을 중단하지 않을 가능성이 높다. 그러나 그것은 또한 다른 프레임워크가 그 위에 배치될 것이며 이러한 프레임워크가 웹 구성 요소를 직접 사용하는 것보다 개발을 위한 더 생산적인 기반일 가능성이 높다는 것을 의미한다.

웹 구성 요소의 주요 기능 중 하나인 shadow DOM을 실제로 활용하려면 Chrome(53이상), Firefox(63이상), 또는 엣지(79이상) 업데이트가 필요하다. 그러나 그 자체로도 그렇게 큰 문제가 되지 않을 것이다. 그러나 웹 구성 요소가 서버에서 렌더링 되는 표준화된 방법을 제공하지 않기 때문에 사실 마땅한 대안은 없다.

클라이언트 사이드 구성은 이전 장의 다른 패턴과 마찬가지로 꽤 자주 찾을 수 있는 기존 아키텍처에 추가하는 패턴이다. 사실, 웹 컴포넌트와 함께 사용하면 웹 컴포넌트의 채택이 마이크로 프론트엔드의 부상과 어느 정도 관련이 있음을 느끼게 된다.

일반적으로 클라이언트 사이드 구성은 도구 같은 웹 어플리케이션에서 주로 볼 수 있는 패턴이다. 주로 정보 제공에 중점을 둔 웹 사이트와 달리 매우 상호적인 웹 앱이다.

웹 구성 요소가 클라이언트 사이드 구성을 달성하는 유일한 방법은 아니지만 지금까지 가장 널리 사용되는 기술이다. 이 기회를 통해 웹 구성 요소에 대한 지식을 채우자. 

웹 구성 요소 살펴보기
자바스크립트 프레임워크의 부상과 클라이언트 사이드 렌더링의 중요성이 증가함에 따라 웹 구성 요소가 제안되고 표준화됐다. 웹 구성 요소라는 용어는 웹에 대한 표준 구성 요소 모델을 제공하려는 기능 집합에 대한 포괄적인 표현으로 사용된다.

다음 섹션에서는 실제로 웹 구성 요소를 형성하는 가장 중요한 기능과 웹 구성 요소가 스타일을 분리하는 데 어떻게 도움이 되는지 다룰 것이다.

웹 구성 요소 이해
이미 알고 있듯이 웹 구성 요소는 HTML 문서에서 사용자 정의 요소를 사용할 수 있는 기능을 제공한다. 다음 스니펫처럼 간단하다.

  <product-page id="app"></product-page>	


사용자 정의 요소는 HTML 구문 분석 관점에서 변경할 수 없지만 동작 및 모양 측면에서 완전히 구성할 수 있다. 예를 들어, 사용자 정의 요소는 <img> 또는 <meta> 태그와 같이 자체적으로 닫힐 수 없다. 사용자 정의 모양을 추가하기 위해 shadow DOM을 사용할 수 있다.

사용자 정의 요소 외에도 웹 구성 요소라는 용어는 다른 많은 기능을 나타낸다. 가장 중요한 기능은 다음과 같다.

• DOM 트리를 캡슐화하는 Shadow DOM
• 재사용 가능한 DOM 트리를 제공하는 HTML 템플릿
• 새 요소를 정의하는 사용자 정의 요소

이전 예제에서는 HTML 템플릿도 사용할 수 있었지만 사용자 지정 요소만 사용했다. HTML 템플릿 사용의 주요 이점은 DOM에 실제로 HTML 조각을 복사하고 재사용하는 기본 방법을 제공한다는 것이다. HTML 템플릿이 없으면 조각도 사용할 수 있지만 문서의 HTML 소스 내에서 선언적으로가 아니라 자바스크립트에서 프로그래밍 방식으로만 사용할 수 있다.

중요한 노트

웹 구성 요소에 대한 브라우저 지원은 상당히 좋은 편이다. 사용자 지정 요소 사양Internet Explorer를 제외한 모든 주요 브라우저에서 지원된다. 지원되지 않는 브라우저에서 처리돼야 하는 경우 사용자 정의 요소가 모든 브라우저에서 작동하도록 하는 폴리필(polyfill)이 있다.

사용자 정의 요소는 HTML 요소의 수명 주기를 노출한다. 마운트 및 언마운트 이벤트에 연결하고 속성이 변경될 때 알림을 받을 수 있다. 이러한 수명 주기 이벤트가 없으면 MutationObserver를 사용하도록 대체해야 한다.

종종 웹 구성 요소는 직접 사용되지 않고 다른 응용 프로그램의 전송 메커니즘으로 간접적으로 사용된다. 예제의 product-page 요소가 자체 미니 애플리케이션으로 간주될 수 있음을 확인했다. 앞으로 웹 구성 요소 내부에서 React와 같은 다른 프레임워크를 사용한 것을 볼 수 있다. 이를 위해 그림 9.4와 같이 웹 구성 요소의 수명 주기 방법을 사용한다.

 

그림 9.4 - 임의의 프레임워크를 사용하는 미니 응용 프로그램은 웹 구성 요소에서 관리할 수 있다. 

attributeChangedCallback을 사용할 때 사용자 정의 요소의 클래스에서 관찰된attributes 속성을 통해 감시할 속성을 전달해야 한다.

마지막으로 Shadow DOM은 웹 구성 요소에서 가장 흥미로운 것 중 하나다. 이것은 웹 컴포넌트를 이용한 마이크로 프론트엔드의 독자적 개발을 애초에 가능하게 하는 마법의 요소이다.

Shadow DOM으로 스타일 분리
웹 구성 요소가 가져오는 이점 중 하나는 shadow DOM에 직접 액세스할 수 있다는 것이다. Shadow DOM에는 개방형과 폐쇄형의 두 가지 모드가 있다.

•	open은 shadowRoot 아래의 트리가 수정을 위해 열려 있고 요소의 shadowRoot 참조에서 액세스할 수 있다.
•	closed는 shadowRoot 아래의 트리가 수정을 위해 닫혀 있고 생성자가 참조를 저장하지 않는 한 액세스할 수 없다.

종종 closed를 사용하여 얻은 추가 캡슐화는 그다지 흥미롭지 않다. 모드를 열면 이미 shadow DOM의 아주 좋은 기능인 스타일 격리에 액세스할 수 있다.

스타일 격리는 마이크로 프런트엔드 간의 스타일 충돌을 방지하는 데 중요하다. Shadow DOM이 없으면 한 마이크로 프론트엔드의 레이아웃이 다른 마이크로 프론트엔드의 스타일에 영향을 받지 않도록 CSS 네임스페이스와 같은 기술이 필요하다. 또한 글로벌 스타일이 유출되는 것을 방지하여 안정성도 향상시킨다.

단점으로, shadow DOM은 구형 브라우저에서 지원이 매우 약하고 실제로 폴리필할 수 없다. Shadow DOM을 사용하려면 자바스크립트가 필요하다. 이는 클라이언트 사이드 구성만으로는 문제가 되지 않지만 일부 서버 사이드 렌더링과 함께 사용하면 옵션이 아닐 수 있다.


중요한 노트

폴리필은 최신 웹 기능을 구형 브라우저에 가져오는 데 중심적인 역할을 한다. 종종 Internet Explorer 11과 같은 브라우저에 대한 지원이 필요하다. 이러한 브라우저는 최신 웹 응용 프로그램에서 요구되는 많은 기능을 제한적으로 지원한다. 폴리필은 특정 기능을 지원하지 않는 브라우저에서도 제공할 수 있도록 하는 코드이다. 많은 기능을 폴리필할 수 있지만 일부는 적절한 대체로 사용하기에 수준이 낮다.

스타일 격리 자체에도 몇 가지 단점이 있다. 전역 스타일이 무시됨에 따라 다른 마이크로 프론트엔드의 스타일뿐만 아니라 실제로 애플리케이션에 일관된 모양과 느낌을 주는 스타일도 무시한다. 일부 일반적인 스타일을 재사용하는 것은 상당히 번거롭고 명시적인 다시 가져오기가 필요하다.

이제 shadow DOM의 장점과 단점을 넘어서서 실제로 마이크로 프론트엔드를 동적으로 사용하는 방법에 대해 논의해야 한다. 즉, 앱 셸에 미리 정의된 스크립트 목록이 없어야 한다. 다음 섹션에서 이에 대해 논의할 것이다.

동적으로 마이크로 프론트엔드 구성
웹 구성 요소가 작동하도록 하는 데 필요한 다양한 스크립트를 느리게 로드하기 위해 중앙 웹 구성 요소 레지스트리를 사용하는 아이디어를 간략하게 소개했다. 이것은 게으르지만 동적이기 때문에 실제로 궁극적인 솔루션이 될 것이다. 그러나 이를 완벽하게 운영하는 것 또한 쉽지 않다. 더 쉬운 방법은 마이크로 프론트엔드 레지스트리로 시작하는 것이다.

마이크로 프론트엔드 레지스트리 사용
마이크로 프론트엔드 레지스트리는 6장, 웹 접근 방식에서 소개된 링크 사전과 유사하다. 그러나 서버 확인 대신 사용 가능한 모든 스크립트에 대한 경로만 반환한다. 예를 들어 트랙터 매장 예제에 대해 다음 응답이 트리거될 수 있다.

{
"scripts": [
"http://localhost:2001/product-page.js",
"http://localhost:2002/basket-info.js",
"http://localhost:2002/buy-button.js",
"http://localhost:2003/product-recommendations.js"
]
}

이 응답의 가장 큰 장점은 각 사용자 또는 사용 사례에 맞게 조정할 수 있다는 것이다. 익명 사용자를 위해 앱 셸이 전달되는 경우 product-page 구성 요소를 전달하는 다른 스크립트가 제공될 수 있다.

이러한 동적 백엔드 응답이 있으면 이를 프론트엔드에 통합할 수 있다. 이것은 여러 가지 방법으로 구현할 수 있다.

•	각 스크립트가 유효한 <script> 태그로 배치되어 있는 index.html 파일에 이미 완전히 어셈블되어 있다.
•	index.html 파일에 포함된 작은 로더 자바스크립트에서 동적으로 가져오고 로드한다.

로더 자바스크립트는 다음 코드처럼 간단할 수 있다.

fetch("http://localhost:1234/registry")
.then(res => res.json())
.then(({ scripts }) => scripts.forEach(url => {
const script = document.createElement("script");
script.onload = () => {}; // success
script.onerror = () => {}; // error
script.src = url;
document.body.appendChild(script);
}));
 
전체 구성은 마이크로 프론트엔드, 더 구체적으로 말하면 웹 구성 요소를 동적으로 제공할 수 있지만 잘못 명명된 사용자 지정 요소를 사용하거나 사용자 지정 요소의 인터페이스를 올바르게 사용하지 못하는 것을 방지하지 못한다.

종종 마이크로 프론트엔드의 문제는 런타임에 쉽게 패치될 수 있다. 이것은 웹 서버의 런타임에 대해 매우 간단하지만 클라이언트의 런타임에도 가능하다. 방법을 살펴보자.

런타임 시 마이크로 프론트엔드 업데이트
마이크로 프론트엔드의 특징 중 하나는 업데이트 경로를 단순화한다는 것이다. 전체 웹 서버나 애플리케이션을 다시 시작할 필요 없이 단일 모듈을 다시 시작할 수 있다. 여러 서버 중 하나 또는 프론트엔드 자산 모듈로 표시된다.

클라이언트 사이드 구성을 보면 런타임 측면은 응용 프로그램을 실행하는 브라우저가 있는 단일 사용자에 의해 완전히 제공된다. 따라서 하나의 마이크로 프론트엔드를 업데이트하면 F5 키를 눌러 페이지를 강제로 새로 고칠 필요 없이 애플리케이션의 일부에서 최소한 이론적으로 작동해야 한다.

불행히도 웹 구성 요소는 런타임 패치에 가장 적합한 후보가 아니다. 여기서 주요 문제는 웹 구성 요소에 대한 단일 정의만 수행할 수 있다는 것이다. 실행 취소할 방법이 없다. 그렇다면 어떻게 해결할 수 있는가?

실제로 웹 구성 요소를 핫 리로드하는 방법이 있다. 예를 들어, 원본 참조를 유지함으로써 기존 클래스의 라이프 사이클 메소드를 패치할 수 있다. 그러나 다음과 같은 몇 가지 단점이 있다.

•	기존 인스턴스는 생성자를 다시 실행하지 않는다.
•	기존 인스턴스에는 필드 및 속성이 추가되지 않는다.
•	관찰된 속성 목록은 업데이트할 수 없다.

더 나은 방법은 실제로 customElements의 정의 기능 위에 추상화를 배치하는 것이다. 다음 의사 코드가 설명하는 것처럼 추상화는 실제로 작동한다.

const elementsVersion = {};

function defineMicrofrontendElement(elementName, Component) {
const currentVersion = elementVersions[elementName] || 0;
const version = currentVersion + 1;
elementVersions[elementName] = version;
customElements.define(`${elementName}-${version}`,
Component);

if (version === 1) {
class WrapperComponent extends HTMLElement {
connectedCallback() {
// 만일을 대비하여 이벤트 핸들러를 리렌더러에게 붙입니다
// 업데이트를 합니다
// 엘리먼트를 렌더링합니다; 모든 속성에게 포워딩합니다
}
disconnectedCallback() {
// 이벤트 핸들러를 삭제합니다
}
}

customElements.define(elementName, WrapperComponent);
} else {
window.dispatchEvent(new CustomEvent("component-
updated", { detail: elementName }));
}
}

남은 유일한 문제는 속성 변경 콜백이 감시할 속성의 명시적 목록이 필요하다는 것이다. 래퍼에 플랫 돌연변이 관찰자(flat mutation observer)를 도입하여 이 문제를 해결할 수 있다. 이 관찰자는 모든 속성 변경 사항을 래핑된 요소에 적절하게 전달한다.

이러한 변경을 통해 웹 구성 요소를 동적으로 업데이트할 수 있어 마이크로 프런트엔드의 진정한 핫 리로딩이 가능하다. 그러나 일반적으로 여기에도 약간의 UX 문제가 있으므로 여기에서 약간 방어적이어야 한다. 이에 대해서는 14장, UX와 화면 디자인에 미치는 영향에서 더 자세히 논의할 것이다.

 
요약
이 장에서는 브라우저에서 마이크로 프론트엔드를 함께 구성하는 방법을 배웠다. 웹 구성 요소를 사용하여 서로 다른 소스의 조각을 정적으로 동적으로 함께 전송하는 방법을 살펴봤다. 또한 이 패턴의 장점과 문제점에 대해서도 논의했다.

클라이언트 사이드 구성은 콘텐츠와 독립적으로 실행되는 몇 가지 위젯과 함께 제공되는 웹 애플리케이션에 가장 적합하다. 여기의 한 가지 예는 대화형 그래픽에서 추가 정보를 찾을 수 있는 기사를 게시하는 온라인 신문이다. 기존 애플리케이션을 확장하거나 마이크로 프론트엔드로 천천히 마이그레이션하는 데 클라이언트 사이드 구성을 사용하는 것이 가장 좋다.

이 장에 제공된 정보는 클라이언트 사이드 구성 패턴 사용에 대한 찬성 또는 반대를 결정하는 데 도움이 될 것이다. 예제 구현에 사용한 코드는 마이크로 프론트엔드 솔루션을 만들기 위한 시작점으로 사용할 수 있다.

다음 장에서는 단일 페이지 애플리케이션이 마이크로 프론트엔드를 활용할 수 있도록 하는 이 패턴의 개선 사항을 살펴볼 것이다. 웹 구성 요소의 단점 중 일부는 보다 정교한 프레임워크를 대신 사용하여 없앨 수 있다.
 
10 SPA 구성
이전 장에서는 적극적인 백엔드 지원 없이 브라우저만 사용하여 마이크로 프론트엔드를 구성하는 방법에 대해 살펴보았다. 사용자 상호 작용이 증가함에 따라 이러한 방식은 매우 효과적이다.
오늘날 단일 페이지 애플리케이션 (SPA)은 많은 경험이 목표로 하는 이와 같은 종류의 애플리케이션을 제공한다. 앵귤러 또는 리액트와 같은 표준 SPA 프레임워크의 여러 구성 요소를 결합하는 것이 SPA 구성 패턴과 함께 설명할 것이다.
SPA의 주요 특징은 라우팅이 서버에서 수행되지 않고 프론트엔드에서 실행된다는 것이다. 자바스크립트에서 라우팅하려면 URL의 해시를 가져오거나 HTML5의 과거 API를 제어하는 등의 기술이 필요하다. 그러면 AJAX와 같은 오래된 기능을 사용하여 페이지에 표시되어야 하는 콘텐츠를 느리게 로드할 수 있다.
이 장에서는 SPA 구성 패턴을 다루어 서로 다른 SPA 프레임워크를 동일한 애플리케이션에 포함할 수 있도록 할 것이며 다음과 같은 주제를 살펴본다. 
	SPA 구성의 기본 사항
	장점과 단점
	핵심 SPA 쉘 구축
	SPA 마이크로 프론트엔드 통합
	커뮤니케이션 패턴 탐색
이를 통해 SPA 구성이 적합한 시기와 실제 구현 방법을 파악할 수 있다.

기술 요구사항
이 장의 예제 구현을 위해 Node.js, 웹팩 및 DOM에 대한 지식이 필요하다. 
이 챕터에서 사용된 코드는 아래 링크에서 확인할 수 있다:
https://github.com/PacktPublishing/The-Art-of-Micro-Frontends/tree/main/Chapter10
위 코드를 사용하는 방법은 설명한 비디오는 아래 링크에서 확인할 수 있다:
https://bit.ly/3g1fgcT

SPA 구성의 기본 사항
SPA 구성은 클라이언트 측 구성 위에 구축된다. 그러나 HTML 태그를 명시적으로 언급하지 않고 다른 스크립트만 가져온다. 이러한 스크립트는 자동으로 통합되고 활성 상태일 때 개별 애플리케이션을 실행한다. 활용 방안으로 이러한 독립 SPA가 항상 활성화되지 않으며 활성 상태일 경우 서로 공존할 수 있다는 것이다.
다른 모든 패턴과 마찬가지로 SPA의 아키텍처를 살펴봄으로써 SPA 구성에 대한 설명을 시작할 것이다. 그런 다음 예제 구현을 위해 필수적인 단계를 따른다. 마지막으로 파생 예제에 대한 잠재적인 개선사항에 대해서 살펴볼 것이다.

아키텍처
웹 구성요소에서 미니 애플리케이션을 호스트하는 방법은 이미 확인했다. SPA 구성은 이 아이디어를 한 단계 발전시킨 것이다. 미니 애플리케이션의 라이프사이클을 처리하기 위해 웹 구성 요소에 의존하는 대신 사용자 지정 로드 스크립트가 사용된다.
그림 10.1과 같은 패턴은 클라이언트측 구성과 상당히 유사하다. 그러나 SPA 구성은 각 요소별로 분리된 HTML 페이지를 전달하는 대신 앞서 언급한 로더 스크립트를 포함하는 앱 쉘과 함께 배포된다.
 
그림 10.1 – 로더 스크립트를 사용하여 다양한 SPA 프레임워크 조정

로더 스크립트의 작업은 서로 다른 마이크로 프론트엔드를 조정하는 것이다. 각 마이크로 프론트엔드는 독립적인 SPA를 보여준다. 그러나 항상 활성 상태로 모든 내비게이션을 캡처하는 대신 각 마이크로 프론트엔드는 특정 조건이 충족될 때만 SPA를 활성화 시킨다. 이러한 조건은 특정 URL에서 특정 상태, 예상되는 사용자 작업에 이르기까지 모든 것이 될 수 있다.
SPA 구성을 정당화하려면 트랙터 스토어보다 더 역동적이고 대화식형태의 애플리케이션을 사용해야 한다. 구현 예제에서 마이크로 프론트엔드에 배포된 여러 페이지로 구성된 작은 회계 앱을 만들 것이다. 세부 사항에 대해서 알아보자.

예제 구현
해당 예제는 마이크로 프론트엔드 3개와 함께 제공되는 회계 애플리케이션을 만들 것이다. 도메인 분해 관점에서 다음과 같은 모듈을 확인할 수 있다.
	대차대조표 표시, 소득 또는 지출 항목 추가, 세부사항 보기와 관련된 잔액
	세금 공제 대상 항목 표시와 관련된 세금
	설정, 사용자 선호도 고려
통화 처리, 애플리케이션 레이아웃 및 메뉴 구조와 같은 모든 교차 명세는 SPA 쉘에 배치된다. SPA에는 총 세 개의 전용 페이지가 제공된다.
	대차대조표 (대차대조 마이크로 프론트엔드)
	항목 세부 정보 (잔액 마이크로 프론트엔드)
	현재 설정 (설정 마이크로 프론트엔드)
설계 안의 경우 부트스트랩을 v5를 사용했다. 부트스트랩을 v5의 장점은 부트스트랩을이 기본적으로 프레임워크에 구애받지 않다는 것이다. 따라서 SPA 쉘에 부트스트랩을이 통합된 경우 모든 마이크로 프론트엔드에서 부트스트랩을 사용할 수 있다.
쉘의 경우 많은 것이 필요로 하지 않는다. 애플리케이션의 스타일시트 및 스크립트 요소에 대한 참조가 포함된 작은 HTML 문서를 사용한다. 또한 기본 레이아웃이 여기에 정의되어 있다. 이 레이아웃 내에서 마이크로 프론트엔드에서 제공되는 컨텐츠 모음을 찾을 수 있다.
<main class="col-md-9 ms-sm-auto col-lg-10 px-md-4" 
  id="app-content"></main>

SPA와 같은 방식으로 애플리케이션 스크립트 안에 전체 애플리케이션이 정의되어 있다. 포괄적인 관점에서 보면 다음과 같다.
window.registerComponent = (appName, componentName, 
  lifecycle) => {};

window.renderComponent = (appName, componentName, target, 
  props) => {}; 

window.destroyComponent = (appName, componentName, target) 
  => {}; 

window.activateOnUrlChange = (appName, componentName, 
  handler) => {}; 

window.addEventListener('popstate', urlChanged); 

import('./scripts.json').then(scripts => 
  scripts.forEach(url => { 
    const script = document.createElement("script"); 
    script.src = url; 
    document.body.appendChild(script); 
}));

마이크로 프론트엔드에서 글로벌 기능을 사용하여 추가 컨텐츠를 가져올 수 있다. 예를 들어 registerComponent 함수를 사용하여 새 구성 요소를 선언할 수 있다. 그런 다음 renderComponent 함수를 사용하여 이러한 구성요소를 렌더링할 수 있다. activateOnUrlChange 기능은 라우팅 엔진에 리스너를 추가하는 데 사용된다.
이러한 기능은 앞에서 언급한 여러 마이크로 프론트엔드를 조정하는 로더 스크립트의 일부이다. 이렇게 하려면 로더 스크립트의 라우팅 엔진도 popstate와 같은 DOM 이벤트에 연결해야 한다.
라우팅 엔진을 편리하면서 보편적으로 만들기 위해 모든 SPA 내부 링크를 따라 리스너를 연결한다.
document.body.addEventListener("click", followLink); 

이렇게 하면 대부분의 마이크로 프론트엔드에서는 라우팅 엔진 및 구현에 대해 알 필요가 없다. 탐색용으로 링크를 사용하면 전체 페이지를 다시 로드하는 대신 애플리케이션 내부로 유지된다.

코드의 마지막 부분은 서로 다른 마이크로 프론트엔드를 로드하는 것을 설명한다. SPA 구성에서 각 마이크로 프론트엔드는 주로 유효한 JavaScript 파일로 표시된다. JSON 파일, script.json에 모든 마이크로 프론트엔드를 수집하고 로드하고 아래와 같이 간단하다.
[
  "https://example.com/microfrontends/balance/1.0.0/root.js",
  "https://example.com/microfrontends/settings/1.0.0/main.js",
  "https://example.com/microfrontends/tax /1.0.0/index.js"
]

이론적으로 이 파일은 일부 도구를 사용하여 작성 및 업데이트할 수 있다. 예제 코드에서는 수동으로 유지관리 한다.
서로 다른 마이크로 프론트엔드로 넘어가면 모두 다른 프레임워크를 사용하여 작성할 수 있다. 예를 들어 다음과 같은 항목이 있을 수 있다.
	밸런스 마이크로 프론트엔드를 만드는 팀은 React를 많이 사용해봤다.
	Tax Micro 프론트엔드를 만드는 팀은 Svelte로 실험하는 것을 좋아한다.
	설정 마이크로 프론트엔드를 만드는 팀은 Vue를 선호한다.
대부분의 팀이 동일한 프레임워크를 사용하는 것이 이상적이다. 이렇게 하면 일관성이 향상되고 유지관리가 쉬워진다. 그럼에도 불구하고 예제에서는 패치워크 접근 방식을 사용하여 이러한 개념의 성능과 유연성을 입증할 것이다.
 
그림 10.2 – SPA 구성을 사용한 회계 애플리케이션의 홈 페이지
그런 다음 마이크로 프론트엔드내에서 글로벌 통합 도우미를 직접 사용할 수 있다. 예를 들어 세금 마이크로 프론트엔드는 아래와 같이 단일 구성 요소만 등록하면 된다.
let Info = undefined; 
window.registerComponent("tax", "info", { 
  bootstrap: () => 
    import("./Info.svelte").then((content) => { 
      Info = content.default; 
    }), 
  mount: (target, props) => new Info({ 
    target, 
    props, 
  }), 
  unmount: (_, info) => info.$destroy(), 
}); 

모듈 전역 변수 Info 는 부트스트랩 기능 에서 지연 로드되는 실제 구성 요소를 버퍼링하는 데 사용된다 . 그러면 마운트 및 마운트 해제 기능이 Svelte 프레임워크에 완전히 의존할 수 있다. 이것은 표시된 생성자를 사용하여 구성 요소를 클래스로 제공한다. Svelte 구성 요소의 인스턴스는 Svelte 구성 요소 를 마운트 해제 하는 $destroy 메서드 와 함께 제공된다 .
밸런스 마이크로 프론트엔드는 리액트로 작성되었다. 이전에 정의된 수명 주기와 함께 세금 정보 구성 요소를 사용한다. 결국 대차 대조표에 행을 표시하는 코드는 다음과 같이 간단하다.
const BalanceItem = ({ item }) => (
  <tr>
    <td>{item.name}</td>
    <td>{item.description}</td>
    <td>{item.amount}</td>
    <td>{item.location}</td>
    <td>
      <TaxInfo {...item} />
    </td>
  </tr>
);

여기에서 TaxInfo 는 전역 renderComponent 및 destroyComponent 도우미 함수를 호출하는 래퍼이다. 이에 대한 가장 간단한 구현은 다음과 같을 수 있다.

const TaxInfo = (props) => { 
  const ref = React.useRef(null); 
  
  React.useEffect(() => { 
    window.renderComponent("tax", "info", ref.current, 
      props); 

    return () => { 
      window.destroyComponent("tax", "info", ref.current); 
    }; 
  }, []); 
    return <slot ref={ref} />;
}; 
이 접근 방식은 구성 요소가 이미 등록된 경우에만 작동한다. 지연된 등록은 작동하지 않는다. 대신 구성 요소 레지스트리가 변경될 때 렌더링 업데이트를 보장하기 위해 이벤트 또는 기타 메커니즘을 사용해야 한다. 이상적으로는 프레임워크 내에서 이미 처리된다.
대차 대조표 자체는 전용 페이지에 배치된다. 따라서 라우팅 엔진의 일부여야한다. 루트 모듈에는 activateOnUrl 변경 함수에 대한 호출이 포함되어야 한다 .

import * as React from "react";
import { render } from "react-dom"; 

let BalanceSheet = undefined; 

window.registerComponent("balance", "sheet", { 
  bootstrap: () => 
    import("./BalanceSheet").then((content) => { 
      BalanceSheet = content.BalanceSheet; 
    }), 
  mount: (target) => render(<BalanceSheet />, target), 
  unmount: (target) => render(null, target), 
}); 

window.activateOnUrlChange( 
  "balance", 
  "sheet", 
  (location) => location.pathname === "/" 
); 
다시 말하지만, 지연 로드 구성 요소를 버퍼링하기 위해 동일한 기술을 사용하고 있다. 또 다른 메커니즘은 Suspense 구성 요소 와 함께 React의 지연 기능 을 사용하는 것일 수 있다 . 이 경우 등록된 구성 요소는 루트 경로 / 에 표시된 홈 페이지를 사용자가 방문할 때만 표시된다.

마지막으로 마이크로 프론트엔드 설정은 밸런스 프론트엔드와 거의 동일하게 작동한다. 다른 프론트엔드 프레임워크(리액트 대신 뷰)를 사용하는 것 외에도 다른 마이크로 프론트엔드의 구성 요소에 의존하지 않는다.  /settings 경로로 이동하면 현재 마이크로 프론트엔드가 마운트 해제되고 설정에서 나오는 콘텐츠가 마운트된다.
이 패턴에 대해 논의할 내용이 많으므로 예제 자체의 잠재적인 개선 사항에 대해 논의를 시작하겠다.
잠재적인 개선 사항
이 솔루션의 주요 문제 중 하나는 모든 마이크로 프론트엔드가 JSON 파일 형식으로 쉘에서 알려야 한다는 것이다. 새로운 마이크로 프론트엔드가 추가되면 JSON 파일도 변경해야 한다. 이전의 모든 접근 방식과 마찬가지로 예를 들어 마이크로 프론트엔드의 해상도를 전용 백엔드 서비스로 이동하여 이를 분리하여 사용할 수 있다.
앱 셸에서 마이크로 프론트엔드를 분리하는 또 다른 이점이 있다. 마이크로 프론트엔드 중 일부만 현재 사용자에게 적합할 수 있다고 가정해 보자. 왜 여전히 모든 것을 참조하거나 준비해야할까? 대신 유효한 사용 가능성이 있는 마이크로 프론트엔드를 가져오는 것이 어떨까? 이것은 또한 주로 백엔드에서 구성되는 마이크로 프론트엔드 솔루션의 중요한 차이점 중 하나이다. 항상 모든것을 마이크로 프론트엔드로 작업할 필요는 없다.
유연성 향상의 맥락에서 메뉴 항목 또는 모든 마이크로 프론트엔드에 흩어져 있는 기능과 관련된 모든 종류의 UI 조각은 SPA 셸에 하드코딩되어서는 안된다. 대신 구성 요소 확장과 같은 메커니즘을 사용해야한다. 이 장의 뒷부분에서 이 접근 방식에 대해 설명할 것이다.
예제 구현에 대한 이러한 개선 사항은 제외하고 일반적으로 이 패턴에 어떤 장점과 단점이 있는지 알아보자.
장점과 단점
SPA 구성 패턴을 기반으로 하는 마이크로 프론트엔드 솔루션은 비마이크로 프론트엔드 SPA의 많은 장점과 단점을 공유한다. 예를 들어, SPA의 한 가지 장점은 상호 작용이 부드럽고 몰입감 있게 느껴진다는 것이다. 그러나 SPA는 일반적으로 작동하는 데 훨씬 더 많은 리소스와 JavaScript가 필요하기 때문에 초기 로딩 시간과 부피가 커진다.
모놀리식 SPA의 중요한 차이점 중 하나는 SPA 마이크로 프론트엔드가 디버그하기 훨씬 어렵다는 것이다. 모놀리식 SPA에는 훌륭한 디버깅 도구가 있지만 마이크로 프론트엔드 SPA는 자체적으로 개발하기 어렵다. 대부분의 솔루션은 라이브 인스턴스(때로는 프로덕션 환경에서 실행되는 경우도 있음)에서 일종의 개발 모드를 활성화한다. 대부분의 개발 노력의 경우 이런 방법이 허용될 수 있지만 오프라인 우선 개발 환경의 부족은 때때로 매우 고통스러울 수 있다. 다음 장에서는 이를 즉시 개선할 수 있는 방법을 살펴보자.
다른 마이크로 프론트엔드 패턴과 비교하여 SPA 구성은 서버에서 렌더링하기 가장 어려운 프레임워크 중 하나이다. 이것이 별일 아닌 것처럼 보일 수도 있지만(보통 그렇지 않은) 어떤 상황에서 우리는 이것이 진짜 문제라고 생각할 수도 있다. 거의 확실히 이게 전자상거래 웹사이트나 신문 웹사이트와 같은 정보가 많은 페이지들에서 이 패턴을 배제한다.
결국 SPA 구성 패턴을 사용하는 주요 대상은 개별 부품이 다른 프레임워크를 사용하는 기존 애플리케이션에서 가져온 것이거나 모든 부품이 동일한 프론트엔드 프레임워크를 사용하여 작성될 것이라고 보장할 수 없는 높은 상호 작용을 요구하는 애플리케이션 또는 툴이다.
이러한 장점과 단점을 염두에 두고 SPA 구성 내에서 앱 셸을 구축할 때 고려해야 할 사항에 대해 자세히 살펴보자.
핵심 SPA 셸 구축
클라이언트 측 구성과 마찬가지로 사용자의 브라우저에서 애플리케이션을 부트스트랩하고 구성하기 위해 앱 셸이 필요하다. 상당히 자주 이 셸은 다소 작으며 페이지를 활성화하기 위한 라우팅 메커니즘이나 의존성을 공유하는 메커니즘과 같은 필수 요소를 얻는 데만 초점을 맞춘다.
이 장에서는 대부분의 SPA 쉘에 내재된 두 가지 기본적인 문제를 살펴보겠다. 활성화 메커니즘부터 시작해보자.
페이지 활성화
SPA의 핵심 기능 중 하나는 라우팅이다. 따라서 SPA 셸은 일부 조건에 따라 표시되는 페이지를 결정할 수 있어야한다. 예제에서 라우트 핸들러가 히스토리 객체 주위를 순환하는 표준 DOM API를 기반으로 할 수 있음을 이미 보았다 .
그림 10.3 에서 우리는 대부분의 라우팅 엔진이 따를 표준 패턴을 볼 수 있다. 마이크로 프론트엔드를 등록하거나 등록 취소하는 데 사용할 수 있는 액티베이터 모듈이 전체적으로 설치되어 있다. 경로 변경 시마다 서로 다른 마이크로 프론트엔드를 검사한다.

 
그림 10.3 – 공통 액티베이터는 등록된 모든 마이크로 프론트엔드의 상태를 확인

상태가 변경되는 경우, 즉 활성 마이크로 프론트엔드가 비활성화되거나 그 반대의 경우에만 활성기가 SPA를 마운트하거나 마운트 해제해야 한다. 대부분의 상태 변경은 URL 변경일 뿐이다. 그리고 우리가 알고 있듯이 URL 변경은 라우팅 엔진에 의해 처리된다.
이러한 라우팅 엔진의 인기 있는 선택은 단일 SPA이다. 기본적으로 SPA 액티베이터에 연결된 프레임워크에 구애받지 않는 라우터를 제공한다. 이를 통해 단일 애플리케이션에서 여러 SPA 인스턴스를 오케스트레이션할 수 있다.
중요한 노트

single-spa는 하나의 응용 프로그램 내에서 서로 다른 SPA 프레임워크를 실행하는 데 도움이 되는 작은 도우미 라이브러리로 시작했다. 나중에 이 프로젝트는 약간 선회하여 마이크로 프런트엔드 프레임워크로 위치를 변경했다. 마이크로 프론트엔드 프레임워크가 SPA 구성을 실현하기 위한 많은 중요한 기술적 기반이 제공되지만, 단일 SPA를 선택할 때 전체 솔루션에 필요한 많은 부분이 여전히 구현되어야 한다.

단일 SPA에서 등록 단계는 registerApplication 함수 를 통해 수행된다 . 꽤 자주SPA 셸이 시작될 때 중앙 모듈에서 수행된다. 단일 SPA 용어로 이러한 모듈을 루트 구성 이라고 한다. 단일 SPA에서 루트 구성의 예를 살펴보자.
import { registerApplication, start } from 'single-spa'; 

registerApplication(
  'my-app', // name of the app 
  () => import('my-app'), // loading my-app exporting the 
    // lifecycle
    (location) => location.pathname.startsWith('/my-app')
      // checker
);

start();

보시다시피 그림 10.3에 설명된 패턴을 사용한다 . 먼저 두 가지 중요한 사항을 제공하는 registerApplication 함수를 호출한다.
• 실제 애플리케이션을 지연 로드하는 데 사용되는 기능(애플리케이션의 수명 주기 내보내기)      
• 특정 애플리케이션이 활성화되어야 하는지 여부를 확인하는 데 사용할 수 있는 기능      
애플리케이션이 처음 활성화되어야 하는 경우 오케스트레이터는 애플리케이션을 부트스트랩해야 한다. 단일 SPA에서 이는 애플리케이션을 트리거하고 로드될 때까지 기다린 다음 선택적 부트스트랩 수명 주기 내보내기를 사용하여 완료하는 조합이다. 모든 작업이 완료되면 마운트 수명 주기가 호출된다.

이 작업을 수행하려면 앱 셸의 오케스트레이터가 실제로 로드되거나 계속 로드되거나 마운트되거나 마운트 해제되어야 하는 마이크로 프론트엔드를 추적해야한다. URL의 변경은 모니터링해야 하며 현재 활성화된 마이크로 프론트엔드의 잠재적인 상태 변화로 이어진다.

이 공간에서 또 다른 문제가 발생한다. 세 가지 마이크로 프론트엔드가 있다고 가정해보자. 예를 들어 모두 동일한 라이브러리를 사용하고 세 가지 마이크로 프론트엔드 모두 리액트를 묶어서 스스로 리액트를 시작할 수 있다. 그러나React DOM, 심지어 React Router, 그리고 React Router DOM과 같은 필수 라이브러리와 함께 React의 세 개의 인스턴스를 의미한다. 라이브러리가 정말 많을 것이다. 이러한 상황을 개선하기 위해 우리는 React를 공유하고 한 번만 로드하는 것이 좋을 것이다. 일반적인 SPA 셸은 실제로 이를 허용하는 메커니즘을 제공해야 한다. 하지만 어떻게 할까? 몇 가지 전략을 보자.
종속성 공유
의존성을 공유하기 위한 꽤 인기 있는 메커니즘이 있다. 가장 쉬운 메커니즘은 일부 종속성을 이미 앱 셸에서 공유된 것으로 선언하는 것이다. 이전 예제를 사용하여 마이크로 프론트엔드에서 사용할 앱 셸에 대한 종속성으로 React 및 모든 유용한 도우미 라이브러리를 선언할 수 있다.
이 접근 방식의 문제는 각 마이크로 프론트엔드가 공유되는 라이브러리와 번들 버전 대신 실제로 공유 라이브러리를 얻는 방법을 알아야 한다는 것이다. 웹팩을 번들러로 사용하면 외부 필드를 활용하여 공유 라이브러리를 사용할 수 있다.
webpack.config.js 파일에서는 다음과 비슷하다.
module.exports = {
  externals: ["react", "react-dom", "react-router-dom"],
}; 

앞의 경우 webpack은 출력의 모듈 시스템을 호출하여 런타임에 패키지를 해결한다. 예를 들어, 전역적으로 사용할 수 있는 정의 기능이 없거나 세 개의 패키지가 식별된 모듈 시스템에 등록되지 않은 경우 실패할 수 있다.
다음과 같은 객체를 사용하면 좀 더 명확해질 수 있다.
module.exports = {
  externals: {
    "react": "React",
    "react-dom": "ReactDOM",
    "react-router-dom": "ReactRouterDOM",
  },
};

이 경우 라이브러리는 리액트 또는 ReactDOM 과 같은 전역 변수에서 검색된다 . 여기에서 SPA 셸은 window.React 를 설정하여 React 패키지의 내보내기를 포함한다.
그러나 이러한 전역 변수를 사용하는 것은 좋지 않다. 이상적으로는 배열을 고수하거나 명시적 구성 없이 이 문제를 해결할 수 있는 묵시적 방법을 사용하는 것이 좋다. 배열을 고수하는 한 가지 옵션은 ES 모듈(ESM) 시스템 을 사용하는 것이다. 안타깝게도 이 기능을 지원하려면 상당히 최신 버전의 브라우저가 다시 필요하다. 크롬(79년 이후), 파이어폭스(67년 이후), 엣지(79년 이후) 등이 지원을 제공하지만 인터넷 익스플로러(11개 포함) 등 구식 브라우저가 문제다. 이것에 대한 직접적인 해결책도 없다. 대신 ESM과 매우 완벽하게 유사하면서도 거의 모든 브라우저를 지원하는 대체 모듈 시스템을 사용할 수 있다.

작동하는 모듈 시스템에 적합한 선택은 SystemJS 이다. SystemJS를 사용하면 SPA 셸이 여러 방법으로 공유 종속성을 등록할 수 있다.

한 가지 옵션은 쉘 자체 내에서 이러한 종속성을 직접 선언하는 것이다.

function registerModules(modules) {
  Object.keys(modules).forEach((name) =>
    registerModule(name, modules[name]));
} 
function registerModule(name, resolve) { 
  System.register(name, [], (_exports) => ({ 
    execute() { 
      const content = resolve(); 

      if (content instanceof Promise) {
        return content.then((innerContent) => 
          _exports(innerContent));
      } else { 
        _exports(content);
      } 
    }, 
  })); 
} 

registerModules({
  react: () => require("react"), 
  "react-dom": () => require("react-dom"), 
  "react-router-dom": () => require("react-router-dom"), 
}); 

또 다른 옵션은 가져오기 맵(import maps) 이라는 깔끔한 기능을 활용하는 것이다. 가져오기 맵은 ESM을 사용하는 브라우저에서 직접 지원되지 않지만 SystemJS에 직접 포함되는 떠오르는 공식 표준이다.
가져오기 맵은 일반적으로 셸의 HTML 코드에서 참조된다.
<script type="systemjs-importmap" src="https://example.com/ import-map.json"></script>

이 예시에서 가져오기 맵의 내용은 다음과 같다.
{
  "imports": {
    "react": "https://unpkg.com/react/umd/react.
       production.min.js",
    "react-dom": "https://unpkg.com/react-dom/umd/react-
       dom.production.min.js",
    "react-router-dom": "https://unpkg.com/react-router-
       dom/umd/react-router-dom.min.js"
  }
} 

이 접근 방식의 가장 큰 장점은 이러한 공유 종속성이 셸에 직접 번들로 묶이지 않는다는 것이다. 대신 요청 시 SystemJS에 의해 지연 로드되며, 이는 이를 필요로 하는 마이크로 프론트엔드가 로드될 때 적용된다.
이 경우 마이크로 프론트엔드가 작동하려면 SystemJS도 사용하도록 출력을 설정해야한다. 웹팩에서 이것의 구성을 쉽게 조정할 수 있다.
module.exports = {
  output: {
    libraryTarget: "system",
  },
  externals: ["react", "react-dom", "react-router-dom"],
};

이제 이 경우 가져오기 맵이 이러한 공유 종속성에 대해 이미 알아야 할 수도 있다는 점을 제외하고 모든 것이 예상대로 작동하고 양호한 상태이다. 가져오기 맵에서 공유 종속성이 삭제되면 어떻게 될까? 가져오기 맵의 버전을 사용하지 않으려면 어떻게 해야할까? 번들된 종속성을 가져오기 맵에서 사용 가능한 항목과 항상 정렬하려면 어떻게 해야할까?
이러한 질문 중 일부는 SystemJS 내에서 확실히 해결할 수 있지만 대안을 찾는 것도 좋은 선택이다. 이 장의 범위에서 언급할 수 있는 옵션은 WMF(Webpack Module Federation)를 사용하는 것이다. 실제로 이러한 문제를 해결하고 스테로이드의 외부 요소 로 생각할 수 있는 웹팩용 핵심 플러그인이다 . 웹팩 청크를 직접 공유하고 해당되는 경우 청크를 추가하거나 제거할 수 있다. 간단히 말해서 연합된 독립 모듈에서 애플리케이션을 구축하기 위한 기반을 제공한다.
이제 종속성을 효율적으로 공유할 수 있으므로 이러한 SPA 마이크로 프론트엔드를 통합하는 것이 중요하다.
SPA 마이크로 프론트엔드 통합
단일 SPA의 경우에서 보았듯이, 소위 루트 구성은 최소한 이름, 활성화 기능 및 로더 기능과 같은 마이크로 프론트엔드를 중앙에서 선언하는 데 사용된다. 다른 접근 방식에서는 유사한 개념을 따르며 일반적으로 다른 마이크로 프론트엔드에 대한 일부 정보를 중앙 위치(일반적으로 SPA 셸에 있음)에 유지하면서 일반적으로 마이크로 프론트엔드에 대해 독립적인 배포 파이프라인을 사용할 수 있다.
이것은 여전히 두 가지 문제가 있다. 수명 주기를 어떻게 선언하고 현재 이러한 프레임워크 간 구성 요소를 어떻게 사용하고 있을까? 수명 주기 선언부터 시작하여 두 가지를 모두 살펴보자.
수명 주기 선언
우리는 이미 SPA 마이크로 프론트엔드에서 내보낸 구성 요소의 수명 주기에 대해 간략하게 설명했다. 단일 SPA에서 이것은 네 가지 기능으로 요약된다.
• 부트 스트랩 기능은 환경을 설정하고 애플리케이션 자체를 로드하는 데 사용되다.      
• 마운트 기능는 구성 요소를 마운트하고 렌더링하는 데 사용된다 (예를 들어 검사기가 이전에 비활성이었던 애플리케이션이 현재 활성 상태임을 보여준다).      
• 마운트 해제 (가) 성분을 제거해야 장착 하였을 때 (예를 들어 검사가 애플리케이션이 더 이상 활성화되지 않은 것을 나타내기 때문에) 사용된다.      
• 언로드 기능은 프레임 워크 특정 부분을 중지 선택적으로 사용할 수 있다 - 명시적으로 트리거 될 수 있다.      
이러한 모든 수명 주기 기능은 수명 주기 부분이 완료될 때 신호로 Promise 을 반환해야한다.
리액트와 같은 인기 있는 프레임워크의 경우 핼퍼 라이브러리가 우리를 위해 존재한다. 예를 들어 single-spa-react를 사용하여 다음과 같이 마이크로 프론트엔드의 구성 요소를 노출할 수 있다.
import React from 'react';
import ReactDOM from 'react-dom'; 
import rootComponent from './MyComponent.jsx'; 
import singleSpaReact from 'single-spa-react'; 

const lifecycles = singleSpaReact({ 
  React,
  ReactDOM,
  rootComponent,
});

export const bootstrap = lifecycles.bootstrap;
export const mount = lifecycles.mount;
export const unmount = lifecycles.unmount;


이를 통해 기술 통합에 시간을 할애하는 대신 실제 구성 요소에 집중할 수 있다.
보시다시피 기존 라이브러리를 사용하여 수명 주기를 선언하는 것은 매우 간단하다. 그러나 라이브러리가 없어도 다소 쉬울 수 있다. 공식 라이브러리가 없는 프레임워크인 솔리드(Solid)를 생각해보자.
첫 번째 단계는 프레임워크에 익숙해지는 것이다. 어떻게 작동할까? 수명 주기 도우미가 있는 다른 프레임워크와 비슷한가? 어떤 종속성이 필요할까? 동적으로 시작하고 중지할 수 있는가? 리소스 관리는 어떻게 작동할까?
다행히도 오늘날 대부분의 프레임워크는 적어도 외부에서는 상당히 비슷하게 작동한다. 또한 대부분의 프레임워크는 단일 DOM에서 다른 프레임워크와 공존할 수 있다.
솔리드의 경우, 우리는 마운트할 때 렌더와 createComponent 함수의 조합을 사용해야 하며 마운트 해제에도 렌더를 사용해야한다. 부트스트랩은 solid-js 의존성을 느리게 로드할 수 있다.
import { createComponent, render } from "solid-js/dom";
export const bootstrap = () => Promise.resolve();
export const mount = (props) => Promise.resolve(render(
  () =>  createComponent(rootComponent, props),
  props.domElement
));
export const unmount = (props) => Promise.resolve(render(
  () => undefined,
  props.domElement
));

이는 수명 주기에 대한 최소 요구 사항을 구현한다. 이 간단한 래퍼를 라이브러리로 만들려면 Promise 래퍼로 동기 코드를 제공하는 것뿐만 아니라 완전히 비동기적이어야 한다.
이러한 수명 주기를 갖추고 있으면 프레임워크 호환성 없이 구성 요소를 노출할 수 있다. 모든 곳에서 프레임워크 간 구성 요소를 사용하기 위해 누락된 메커니즘이 하나뿐이다. 그 내용에 대해 알아보자.
프레임워크 간 구성 요소 사용
최상위 마이크로 프론트엔드는 모두 다른 프레임워크를 사용하여 작성할 수 있지만 가장 흥미로운 사용 사례는 아니다. 훨씬 더 흥미로운 사용 사례는 중첩된 구성 요소를 사용하는 경우이다. 예를 들어 페이지는 하나의 마이크로 프론트엔드에서 내보내지만 이 페이지는 다른 프레임워크로 작성된 구성 요소인 다른 마이크로 프론트엔드의 구성 요소를 사용할 수 있다. 다음 React 코드를 살펴보자.
export const ProductPage = ({ sku }) => {
  return (
    <>
      <h1>Model Store</h1>
      <BasketInfo sku={sku} />
      <ProductInfo sku={sku} />
      <BuyButton sku={sku} />
      <Recommendations sku={sku} />
    </>
  );
};

여태까지는 그런대로 잘됐다. 그러나 BasketInfo 와 같은 이러한 구성 요소 중 일부가 다른 마이크로 프론트엔드에서 제공되어야 한다면 어떻게 될까?
한 가지 가능한 전략은 HTML placeholder를 가져와 직접 렌더링하는 것이다.
따라서 코드를 다음과 같이 변경해보자.

export const ProductPage = ({ sku }) => { 
  const basketInfoRef = React.useRef(null); 
  
  React.useEffect(() => { 
    if (basketInfoRef.current) { 
      return renderBasket(basketInfoRef.current, { sku }); 
    } 
  }, []); 
  
  return ( 
    <> 
      <h1>Model Store</h1>
      <slot ref={basketInfoRef} /> 
      {/* ... */} 
    </> 
  ); 
}; 

이제 renderBasket 함수는 렌더링할 구성 요소를 알아야한다. 단일 SPA에서 mountParcel 함수는 애플리케이션 컨텍스트에서 이러한 목적으로 사용될 수 있다. 이 컨텍스트 외부에서 단일 SPA에서 직접 내보낸 mountRootParcel 함수를 항상 사용할 수 있다 .
import { mountRootParcel } from "single-spa"; 

const BasketInfo = () => import("mf-blue/basket-info"); 

function renderBasket(domElement, props) { 
  mountRootParcel(BasketInfo, { ...props, domElement }); 
} 

이 예시에서 BasketInfo 값은 구성 요소의 수명 주기를 나타낸다. React의 특별한 경우에 single-spa-react 유틸리티 라이브러리는 이미 Parcel 이라는 편리한 래퍼를 제공한다. 이렇게 하면 useRef 및 DOM을 직접 사용할 필요가 없다.
일반적으로 프레임워크 간 구성 요소를 처리할 때 mountParcel 과 같은 프레임워크에 구애받지 않는 브로커를 도입하는 것이 좋다 . 가장 큰 장점은 이 브로커가 이러한 임의 구성 요소로 변환하는 단일 방법을 정의한다는 것이다. 그렇게 하면 N 프레임워크에 대해 N² 변환기를 처리하는 대신 2N 변환기(브로커에 대한 N 프레임워크 및 브로커의 N 프레임워크)만 필요하다.
일단 설정되면 크로스 프레임워크 구성 요소는 다른 구성 요소와 마찬가지로 자연스럽다. 업데이트라고 하는 다른 종류의 선택적 수명 주기가 트리거될 수 있는 외부에서만 터치된다 . 그러나 대부분의 변경 사항은 외부 API를 통해 직접 발생하지 않고 일부 통신 패턴을 통해 애플리케이션의 다른 지점에서 발생한다. 다음 섹션에서는 서로 다른 마이크로 프론트엔드의 구성 요소 간에 사용 가능한 통신 패턴을 살펴보자.
커뮤니케이션 패턴 탐색
여러 SPA 프레임워크를 독립적으로 실행하는 것은 좋은 시작이지만 실제 애플리케이션에서 완전히 필요한 것은 아니다. 많은 애플리케이션에서 최소한 어떤 경우에는 이들 사이에 어떤 형태의 통신이 필요하다.
이러한 통신 요청에서 다루어야 하는 세 가지 중요한 측면이 있다.
• 특정 이벤트에 대해 다른 마이크로 프론트엔드에 알리기 위해 일부 메시지 공유      
• 데이터 공유, 예를 들어 공유 도메인 개체에 대한 지식을 효율적으로 전파      
• 다른 도메인의 기능을 더 큰 UI 빌딩 블록으로 가져오기 위한 구성요소 제공      
이 세 가지 측면 모두는 다음 하위 섹션에서 논의되는 아키텍처 패턴에 따라 구현될 수 있다. 이벤트 교환부터 시작해보자.
이벤트 교환
마이크로 프론트엔드의 가장 중요한 커뮤니케이션 패턴은 이벤트의 사용이다. 여기에는 분명한 이유가 있다. 이벤트는 기본적으로 느슨하게 결합되고 매우 안정적이다. 핸들러가 등록되지 않았거나 일반적인 이미터가 없으면 중단되지 않는다. 그들은 또한 엄격하게 시간을 지키지 않으려는 의도를 적절하게 전달한다.
간단히 말해서 마이크로 프론트엔드에 대한 이벤트를 설정하는 방법에는 여러 가지가 있다. 가장 일반적이고 잠재적으로 가장 안정적이며 가장 성능이 좋은 방법은 DOM API를 활용하는 것이다. DOM API는 우리 고유의 이름과 페이로드와 함께 표준 이벤트 리스너 시스템을 사용할 수 있는 기능을 제공하는 소위 사용자 정의 이벤트를 제공한다.
 
그림 10.4 - 표준 DOM 이벤트 인터페이스를 사용하여 이벤트를 교환할 수 있다.
앞의 그림에서 아키텍처를 볼 수 있다. 특정 이벤트를 내보내고 반응하는 마이크로 프론트엔드 사이에는 암시적인 내용이 있다. 결국 느슨하게 결합된 전략에서도 항상 알려진 것이 있을 것이다.
사용자 정의 이벤트 API를 사용하는 것은 매우 간단하다. 이벤트 이미터의 경우 다음과 같다.
window.dispatchEvent(new CustomEvent("my-event", {
  detail: {
    message: "Hello!",
  },
}));

사용자 지정 이벤트를 수신하려면 약간의 코드만 추가하면 된다.
window.addEventListener("my-event", e => {
  // use e.detail.message
});
상세 속성은 사용자 지정 데이터가 첨부되는 위치이다. 경우에 따라 사용자 정의 API를 사용자 정의 이벤트 위에 배치하는 것이 유용할 수 있다. 실제로DOM API가 전송 메커니즘으로만 사용될 수 있도록 재생될 수 있으며, 사용자 정의 API는 수신기를 추가하거나 제거하고 이벤트를 내보내는 데 사용된다.

이벤트가 잘 다루지 못하는 것 중 하나는 공유 데이터에 대한 액세스가 보장된다는 것이다.

데이터 공유
이벤트만큼 중요하지 않을 수 있지만 많은 시나리오에서 올바른 호출은 동일한 데이터 세트를 읽고 쓰는 방법을 정의하는 것이다.
이전과 마찬가지로 공유 정보에 액세스할 수 있는 중앙 위치를 제공해야한다. 이것은 윈도우 (window) 개체, 공유 종속성 또는 다른 도달 가능한 개체에서 제공하는 핸들일 수 있다.
 
그림 10.5 - 중앙 API는 공유 데이터에 대한 읽기 및 쓰기 액세스를 제공
이 통신 패턴의 아키텍처는 그림 10.5에 나와 있다. 중요한 것은 새 데이터를 쓰기 위한 API와 기존 데이터를 읽는 API의 두 가지 개별 API가 필요하다는 것이다. 이 API는 다른 종류의 액세스 권한과 함께 사용할 수 있는 소유권 개념을 정의할 수 있다. 예를 들어 일부 데이터의 소유자만 쓰기를 허용할 수 있다. 이 설정에서는 모든 마이크로 프론트엔드에서 읽기를 수행할 수 있다.
대부분의 경우 공유 데이터 저장소는 근본적인 문제의 지표일 가능성이 크다. 도메인이 제대로 분할되지 않는 경우가 많다. 대부분의 경우 그 이유는 느슨하게 결합된 형태로 다른 마이크로 프론트엔드의 UI 조각으로 구성 요소를 확장할 수 있는 기술적 능력이 부족하기 때문이다.
확장 구성 요소
거의 가장 중요한 통신 패턴은 기존 구성 요소가 다른 마이크로 프론트엔드에서 제공되는 더 많은 기능으로 확장되는 방법을 정의하는 것이다. 일반적으로 이것은 큰 문제이다. 예시에서 본 트랜잭션 테이블과 같이 하나의 마이크로 프론트엔드에서 가져온 데이터가 있는 테이블을 고려해보자. 하나의 마이크로 프론트엔드가 어떻게 이 테이블에 추가적인 가치를 더할 수 있을까?

예를 들어 마이크로 프론트엔드가 세금 공제 가능한 거래를 추론할 수 있다고 가정해보자. 그 테이블의 일부가 되어야 하는 좋은 정보가 아닐까? 분명히 기존 테이블 내에 이 정보(선택 사항)가 있으면 좋을 것이다. 한 가지 빠진 것은 그것을 적용하는 방법이다. 명백한 방법은 이를 트랜잭션 테이블에 직접 통합하거나 다른 마이크로 프론트엔드에서 구성 요소를 가져오는 것이다. 두 옵션 모두 이상적이지 않다.
첫 번째 옵션에서는 도메인 분해를 위반한다. 기술적으로는 괜찮지만 팀 지식 및 유지 관리 측면에서 문제가 될 것이다. 그러나 다른 옵션은 훨씬 더 안좋다. 여기서 우리는 도메인 분해를 위반할 뿐만 아니라 다른 마이크로 프론트엔드에 대한 강력한 결합도 도입한다.
이 문제를 해결하기 위해 소위 확장 슬롯을 만들 수 있다. 이를 통해 모든 마이크로 프론트엔드의 추가 구성 요소가 기존 구성 요소에 들어갈 수 있다. 다음 그림에는 일반적인 흐름이 설명되어 있다.
 
그림 10.6 - 확장 슬롯의 모든 구성 요소를 렌더링하기 위해 중립 집계 구성 요소 사용
확장 슬롯은 특수 집계 구성 요소로 표시된다. 이 구성 요소의 책임은 슬롯에 등록된 구성 요소를 표시하는 것이다. 이런 식으로 전체 패턴은 UI 구성 요소에 대한 이벤트와 비슷하다.
이벤트가 이미터 및 여러 핸들러와 함께 작동하여 방출된 이벤트를 수신하는 반면 확장 슬롯은 렌더러(확장 슬롯) 및 렌더링될 때 표시되는 여러 구성 요소와 함께 작동한다. 이벤트와 마찬가지로 현재 렌더링을 설명하는 속성이 있는 개체가 구성 요소에 전달된다.

 
요약
이 장에서는 여러 SPA를 하나의 일관된 웹 애플리케이션으로 구성하는 방법을 배웠다. 사용자 상호 작용이 상당히 높아야 하지만 훌륭한 사용자 경험을 달성하려면 많은 기술적 문제를 해결해야 한다는 것을 알았다.
이 장에서 배운 통신 패턴을 적용하여 느슨한 결합을 보장할 수 있다. 이렇게 하면 애플리케이션을 확장하는 데 도움이 된다. 결국 목표는 항상 통합에 필요한 최소한의 요구사항만 교환하는 것이다.
다음 장에서는 이 패턴을 조금 더 발전시켜 UI 구성을 위해 서버리스 기능을 미러링하는 시스템을 만들 것이다. 훌륭하고 일관된 사용자 경험을 유지하면서 매우 유연하고 개발하기 쉬운 시스템을 제공해야 한다.
 
11 사이트리스 UI
이전 장에서는 SPA 구성 패턴을 사용하여 여러 SPA를 하나의 통일된 애플리케이션으로 결합하는 방법에 대해 알아봤다. 이러한 패턴은 다양한 비즈니스 및 기술적 요인 때문에 매력적이지만 그와 동시에 관련된 도전과제를 관찰할 수 있을 만큼 충분히 깊이 파고들었다.
SPA 구성 위에 직접 구축되는 패턴은 사이트리스 UI를 만드는 것이다. 이 패턴에서는 서버리스 기능의 아날로지와 아이디어가 프론트엔드에 적용된다. 이를 바탕으로 많은 장점과 유연성을 제공하는 런타임 기반 마이크로 프론트엔드를 활용할 수 있다.
이 장에서는 사이트리스 UI 패턴을 사용하는 차세대 마이크로 프론트엔드에 대해 자세히 살펴보고 다양한 마이크로 프론트엔드 패턴에 대한 설명을 마무리한다.
이번 장은 아래와 같이 구성되어 있다.
	사이트리스 UI의 기본 사항
	장점과 단점
	서버리스와의 비교
	런타임 생성하기
	모듈 작성하기
이를 통해 사이트리스 UI 패턴이 언제 적합한지 그리고 실제로 구현할 수 있는 방법을 이해하는 데 도움이 될 것이다.

기술 요구사항
이 장의 예제 구현을 위해 Node.js, 웹 팩 및 DOM에 대한 지식이 필요하다. 코드는 GitHub에서 찾을 수 있으며 여러 레포지토리에 분산되어 있다. 각 코드에 대한 설명 전에 레포지토리 URL이 명시되어져 있다.
위 코드를 사용하는 방법은 설명한 비디오는 아래 링크에서 확인할 수 있다.
https://bit.ly/2SStQeM

사이트리스 UI의 기본 사항
사이트리스 UI 패턴은 SPA 구성 위에 직접 구축된다. 일관성을 유지하면서 유연성을 제공하는 플러그인 아키텍처를 활용한다.
이전 장과 마찬가지로 표준 구조를 사용하여 이 패턴을 소개할 것이다. 간단한 예제 구현을 하기전에 아키텍처에 대해 자세히 살펴보고 잠재적인 개선 사항에 대해 논의할 것이다.
먼저 아키텍처에 대해 자세히 살펴보자.

아키텍처
SPA 구성 패턴의 문제 중 하나는 앱 셸이 모든 마이크로 프론트엔드가 어디에 있고 통합되는 방법을 알고 있을 가능성이 높다는 점에서 앱 셸이 다소 제한적이었다는 것이다.
이와는 대조적으로 개선된 버전에서는 앱 셸 자체가 마이크로 프론트엔드에 대해 알지 못할 것이다. 대신 어떤 마이크로 프론트엔드를 사용하고 통합할 것인지를 식별하기 위해 다른 부분에 의존할 것이다. 통합 자체는 마이크로 프론트엔드가 담당하게 된다.
다음 다이어그램은 사이트리스 UI 패턴의 핵심 아키텍처 원리를 보여준다.
 
그림 11.1 – 사이트리스 UI는 마이크로 프론트엔드 피드와 런타임의 조합을 사용하여 구축된다

그림 11.1에서는 SPA 구성과 유사한 점도 볼 수 있다. 사이트리스 UI 패턴을 독특하게 만드는 것은 피드가 개별 마이크로 프론트엔드의 데이터 소스와는 다른 서버에서 제공되어야 한다는 것이다. 더욱이 마이크로 프론트엔드는 완전히 자율적이기보다는 앱 셸의 실행 컨텍스트 내에서 실행되는 모듈이다.
이러한 모듈을 제공하기 위해 플러그인 아키텍처를 사용할 수 있다. 플러그인 아키텍처를 도입하는 한 가지 방법은 다음 두 가지를 정의하는 것이다.
	기능을 통해 노출된 모듈의 일반적인 수명 주기
	플러그인으로 넘겨줄 API - 플러그인의 수명 주기 동안 액세스 가능해야 한다
가장 간단한 접근법은 수명 주기를 플러그인 설정이라는 한단계로 단축하는 것이다. 이 경우 각 모듈은 설정이라고 하는 단일 기능을 의미한다. 앱 셸은 이제 API 객체를 제공하는 이러한 설정 함수를 함수의 인수로 호출할 수 있다. 개체의 컨텍스트가 앱 셸 소유자에게 넘어간다. 여기에 탐색 또는 콘텐츠 영역과 같은 UI의 특정 부분에 대한 구성 요소를 등록할 수 있는 전용 방법을 제공하는 것을 권장한다.
스크립트의 내보내기를 사용하는 것은 SPA 구성과 비교했을 때 방향의 분명한 변화가 있다. 이제 글로벌 변수를 사용하는 대신 모듈에서만 작업을 한다. 예를 들어 글로벌 변수는 싱글톤 동작을 얻거나 일부 종속성을 공유하기 위해 여전히 은닉한 어딘가에 사용될 수 있지만 이러한 전역 변수를 직접 사용하거나 상호 작용이 되어서는 안 된다.
이전 장의 예제를 수정하여 사이트리스 UI 패턴을 구현해보자.

예제 구현
이 패턴의 작동 방식을 가장 극단적인 설정으로 설명하기 위해 솔루션의 모든 부분을 배포할 것이다. 즉 5개의 레포지토리가 생성된다.
	피드를 제공하는 피드 서비스를 위한 레포지토리
	마이크로 프론트엔드를 조정하는 앱 셸에 대한 레포지토리
	잔액표(또는 기타 관심 있는 마이크로 프론트엔드)를 위한 세금 공제 정보 구성요소를 제공하는 "세금" 마이크로 프론트엔드용 레포지토리
	사용자 설정 페이지를 제공하는 "설정" 마이크로 프론트엔드용 레포지토리
	대시보드 페이지에 대차대조표를 제공하는 "균형 조정" 마이크로 프론트엔드를 위한 레포지토리
통화 처리, 애플리케이션 레이아웃 및 메뉴 구조와 같은 모든 교차 명세는 SPA 쉘에 배치된다. SPA에는 총 세 개의 전용 페이지가 제공된다.
	대차대조표 (대차대조 마이크로 프론트엔드)
	항목 세부 정보 (잔액 마이크로 프론트엔드)
	현재 설정 (설정 마이크로 프론트엔드)
다음 섹션에서는 각 레포지토리를 설명한다. 피드 서버부터 시작할 것이다.

피드 서버
이 섹션의 코드는 다음에서 찾을 수 있다. https://github.com/%20ArtOfMicrofrontends/11-service-feed.
피드 서버는 Express를 사용하여 간단한 Node.js 응용 프로그램으로 구현할 수 있고 서버의 핵심 부분은 다음과 같이 정의할 수 있는 세 개의 서로 다른 경로 핸들러로 구성된다.
app.get("/modules", getLatestModules());
app.post("/modules", publishModule(host));
app.get("/files(/@:org)?/:name/:version/:file?",
getFiles());

첫 번째 경로는 사용 가능한 모듈을 검색하기 위한 모든 요청을 처리하고 최신 모듈로 응답한다.
피드 서버가 각 마이크로 프론트엔드에 대해 여러 버전을 저장할 수 있지만 예제의 최신 버전만 제공할 것이다. 추가 API 또는 변경을 통해 다음과 같이 빠른 롤백 또는 A/B 테스트 시나리오가 가능하다.
  exports.getLatestModules = () => async (_, res) => {
const modules = await getAllModulesFromDatabase();
const unique = modules.reduce((prev, curr) => {
prev[curr.meta.name] = curr.meta;
return prev;
}, {});
      
      const items = Object.keys(unique).map((name) =>
unique[name]);
return res.json(items);
};

모듈을 게시하는 방법에는 여러 가지가 있다. 한 가지 방법은 개인 npm 레지스트리를 제공하여 다른 서비스와 결합하는 것이다.
좀 더 통합된 방법은 파일 항목이 있는 양식을 사용하여 업로드를 허용하는 것이다. 이 접근법의 구현 방법은 다음과 같다.

exports.publishModule = (rootUrl) => (req, res) => {
const bb = req.busboy;
req.pipe(bb);

bb.on("file", async (_, file) => {
try {
const content = await getModuleContent(file,
rootUrl);
await setModuleData(content);
res.sendStatus(200);
} catch (err) {
res.sendStatus(400);
}
});
};

getModuleContent 함수는 제공된 파일에서 콘텐츠를 추출하는 데 사용된다. 이번 예시에서는 tgz 파일인 npm 패키지를 사용한다. 왜 이것이 좋은 선택인지에 대해서는 나중에 Publishing 모듈 섹션에서 논의할 것이다.
마지막으로 파일을 가져올 방법이 필요하다. 이상적으로는 이 서비스의 일부가 아니다. 그러나 이 이상적인 시나리오에서는 매우 빠른 스토리지에 액세스할 수 있는 CDN(Content Delivery Network)과 같은 또 다른 서비스가 필요하다. 따라서 이전에 업로드한 마이크로 프론트엔드의 일부였다면 어떤 종류의 요구 파일도 처리할 수 있는 엔드포인트를 제공할 것이다.
이제 이러한 파일에 대한 요청 핸들러를 만드는 기능에 대해 알아보겠다. 가장 주의해야 할 것은 패키지의 잠재적인 이름을 선언하는 것이다. npm 패키지의 범위를 지정할 수 있으므로 패키지 이름을 나타내는 단일 경로 구분 기호가 URL 부분에 보여질 수 있다. 다음 코드에 나와 있는 이 부분을 올바르게 식별하려면 몇 가지 논리를 적용해야 한다.
exports.getFiles = () => async (req, res) => {
const { name, version, org, file } = req.params;
const id = org ? `@${org}/${name}` : name;
const moduleData = await getModuleData(id, version);

if (moduleData && file) {
const path = path.join(moduleData.root, file);
const content = Buffer.from(moduleData.files[path]);

if (content) {
const tenYears = 24 * 60 * 60 * 365 * 10;
return res
.header("Cache-Control", `public, max-
age=${tenYears}`)
.contentType(mime.lookup(file) ||
"application/octet-stream")
.status(200)
.send(content);
}
}
res.status(404).send("File not found!");
};

이러한 핸들러가 구현되면 서버를 시작하고 모든 것이 제대로 작동하는지 확인할 수 있다. 다른 부품과의 통합을 테스트하기 위해 당분간 이 시스템을 계속 실행할 것이며 개별 마이크로 프론트엔드를 계속하기 전에 앱 셸을 구현해 보자.

앱 쉘
이 섹션의 코드는 다음에서 찾을 수 있다. https://github.com/%20ArtOfMicrofrontends/11-app-shell.
앱 셸의 중심에는 기존 모듈을 검색하는 기능이 있다. 이는 SPA 구성 예제(10장, SPA 구성)에서 로드한 스크립트와 매우 유사하다.
그러나 10장 SPA 구성에서 수행한 예제와 달리 정적 파일은 로드하지 않는다. 또한 이전보다 조금 더 많은 것을 수행해야한다. 각 마이크로 프론트엔드가 일부 기능에 사용되는 SPA 구성 패턴과는 달리 잘 정의된 인터페이스에서 일련의 API를 제공해야 한다.
다음 예제에서는 각 마이크로 프론트엔드가 내보내기를 글로벌 변수형태로 보여지는 것을 가정한다. 이 내보내기에서는 설정 기능을 찾아볼 것이다. 해당 기능은 마이크로 프론트엔드에서 사용할 API 객체를 제공하는 앱 셸에 의해 다음과 같이 최종적으로 호출된다.

const feedUrl = "http://localhost:9000/modules";

fetch(feedUrl).then(res => res.json()).then((modules) =>
modules.forEach((moduleData) => {
const script = document.createElement("script");
script.src = moduleData.link;
script.onload = () => {
const nsName = moduleData.name;
const { setup } = window[nsName] || {};

if (typeof setup === "function") {
const api = createApi(nsName);
setup(api);
}
};
document.body.appendChild(script);
})
);

피드 서버의 URL은 예시에 알맞게 변경되어야 한다. 예제를 로컬에서 실행하는 경우 지정된 URL을 그대로 사용해도 된다. 그러나 일반적으로 프로덕션 환경에 다른 URL을 사용할 수 있도록 이 기능을 구성해야 한다.
마이크로 프론트엔드당 API 객체를 만들어야 한다. 이러한 접근법의 장점은 서로 다른 마이크로 프론트엔드 간의 잠재적 충돌과 조작을 피할 수 있다.
해당 예제는 이전과 거의 동일한 기능을 제공하고 단순하면서도 효과적인 API를 제공할 것이다.
마이크로 프론트엔드마다 API 객체를 만들 때 얻을 수 있는 한 가지 이점은 모든 API에서 마이크로 프론트엔드 이름을 지정할 필요가 없다는 것을 즉시 알 수 있다는 것이다. API를 만들 때 확인할 수 있다. 마이크로 프론트엔드당 이 작업을 수행하므로 마이크로 프론트엔드별 정보도 확인할 수 있다.
API 생성에 대한 일반적인 개요는 다음과 같이 요약할 수 있다.
function createApi(nsName) {
return {
registerPage(route, lifecycle) {
// ...
},
registerExtension(id, lifecycle) {
// ...
},
on(eventName, handler) {
// ...
},
off(eventName, handler) {
// ...
},
renderExtension(container, id, props) {
// ...
},
};
}
	
예를 들어 registerPage API는 registerComponent와 activateOnUrlChange 기능을 조합하여 사용할 수 있다. 해당 기능은 SPA 구성 예제에서 확인할 수 있다.
캡처된 정보를 적용하면 구현은 다음과 같이 간단할 수 있다.
registerComponent(nsName, route, lifecycle);
activateOnUrlChange(
nsName,
route,
(location) => location.pathname === route
);


빌드 프로세스를 변경할 필요는 없다. 이전과 마찬가지로 원하는 도구를 자유롭게 선택할 수 있고. 이 경우 아키텍처와 개발을 위해 Parcel 번들러를 보관한다.
앱쉘이 준비되고 실행되면 다른 마이크로 프론트엔드에 초점을 맞추고 세금 정보와 관련된 마이크로 프론트엔드부터 시작해볼것이다.	

마이크로 프론트엔드 – 세금
이 섹션의 코드는 https://github.com/ ArtOfMicrofrontends/11-frontend-tax에서 확인할 수 있다.
세금 마이크로 프론트엔드는 많은 변화가 필요하지 않고 Info 구성 요소 자체는 여전히 Svelte 구성 요소로 제공될 수 있다. 해당 구성 요소를 변경할 필요가 없다.
마이크로 프론트엔드의 루트 모듈을 일부 변경해야 한다. 자세한 내용은 아래와 같다.
let Info = undefined;

export function setup(api) {
api.registerExtension("balance-info", {
bootstrap: () =>
import("./Info.svelte").then((content) => {
Info = content.default;
}),
mount: (target, props) =>
new Info({
target,
props,
}),
unmount: (_, info) => info.$destroy(),
});
}

앱 셸에서 초기에 정의된 수명 주기를 새로운 방식으로 전송했다. 해당 방법은 앱 셸의 API가 포함된 개체를 수신하여 내보낸 설정 함수를 활용한다.
여기서 확인할 것은 registerExtension 함수를 호출할 때 마이크로 프론트엔드의 이름이 언급될 필요가 없다는 것이다. 여기서 바꾼 것은 좀 더 적절한 이름을 사용하는 것이다. 마이크로 프론트 엔드의 이름을 통해 구성 요소를 직접 얻는 대신 확장 슬롯에 세심한 이름을 붙이는 느슨한 커플링 요구 사항을 확인할 수 있다.
마이크로 프론트엔드의 설정을 살펴보고 적용에 필요한 변경 사항을 더 살펴보도록 하자.

마이크로 프론트엔드 - 설정
이번 세션의 코드는 여기서 확인할 수 있다.
https://github.com/%20ArtOfMicrofrontends/11-frontend-settings.
여기서 중요한 점은 주요 변경 사항은 루트 모듈 내에 있다는 것이다. 하지만 package.json 파일을 주의 깊게 살펴봐야한다. 이 파일에 저장된 정보를 피드 서버에서 사용하기 때문에 거기에 정확한 정보가 있어야 한다
이전에는 메인 필드에 대한 메타 정보를 정확하게 유지하지 않았지만 빌드 아티팩트가 배치되는 위치를 반영해야 한다. 이번 예시의 경우 dist/index.js를 선택하고 이를 완전히 수용하려면 웹팩의 구성도 수정해야 한다.
마이크로 프론트엔드 설정의 경우 웹팩 구성은 다음과 같다.
const { name } = require("./package.json");

module.exports = {
entry: {
[name]: "./src/index.js",
},
output: {
filename: "index.js",
library: name,
path: dirname + "/dist",
},
// ... as beforehand
};

package.json의 정보를 재사용하여 일관되고 재사용 가능한 구성 파일을 만든다. 출력 파일 이름은 이제 index.js로 고정되고 동일한 이름의 라이브러리 대상을 사용한다. 이는 앱 셸에서 이전에 설정된 규칙을 따르는 것이다.
결과적으로 빌드 프로세스는 매우 유사하지만 전역 변수를 통해 내보내기를 처리한다. 필요한 wrapper는 웹팩에 의해 사용된다.
이러한 변경 사항을 염두에 두고 대차 대조표를 호스팅하는 가장 중요한 마이크로 프론트엔드를 살펴보자.

마이크로 프론트엔드 – 대차 대조
이번 세션 코드는 여기서 확인할 수 있다.
https://github.com/%20ArtOfMicrofrontends/11-frontend-balance.
Balance 마이크로 프론트엔드도 메타데이터, 웹팩 구성 및 루트 모듈을 수정해야 하고 앱 셸에 등록된 확장 구성 요소를 렌더링하는 새로운 방식도 적용해야 한다.
먼저 할 일은 BalanceSheet 구성 요소에 renderExtension API를 제공하는 것이다. 루트 모듈은 다음과 같다. 
export function setup(api) {
api.registerPage("/", {
mount: (target) => render(<BalanceSheet
onRender={api.renderExtension} />, target),
// ... as beforehand
});
}

이런 식으로 구성 요소를 renderExtension API로 사용할 수 있다. 이 경우에는 관계가 있는 하위 계층에 onRender prop을 제공하면 된다.

 중요한 노트
리액트에서 값을 전달하는 데 사용되는 두 가지 방법이 있다. 하나는 props을 통한 것이고 다른 하나는 context를 통한 것이다. 일반적으로 props을 사용해야한다. 그러나 특정 상황에서는 컨텍스트가 더 나을 수 있다. 컨텍스트가 빛나는 한 가지 상황은 "props drilling"으로 알려진 현상이 나타날 때이다. 이것은 상당히 먼 하위 요소에 props을 제공하기 위해 동일한 props을 여러 수준 아래로 전달해야 할 때 보여진다.

이제 이러한 모든 마이크로 프론트엔드를 변환했고 피드 서버에 게시할 차례이다. 즉, 먼저 다음과 같이 빌드하고 패키징해야 한다.
npm run build
npm pack

실제 업로드를 위해 Postman과 같은 그래픽 도구나 cURL과 같은 명령어를 사용하면 된다.

예를 들어 버전 1.0.0의 밸런스 마이크로 프론트엔드는 다음 명령어로 실행된다.
curl -F 'file=@./balance-1.0.0.tgz' http://localhost:9000/ 
modules


모든 마이크로 프론트엔드가 게시된 후에는 피드 서버의 응답이 더 이상 비어 있지 않다. 다음 스니펫과 유사한 응답이 표시되어져야 한다.
[
{
"name": "balance",
"version": "1.0.0",
"link": "http://localhost:9000/files/balance/
1.0.0/index.js"
},
{
"name":"tax",
"version": "1.0.0",
"link": "http://localhost:9000/files/tax/
1.0.0/index.js"
},
{
"name": "settings",
"version": "1.0.0",
"link": "http://localhost:9000/files/settings/
1.0.0/index.js"
}
]

지금까지 잘 따라왔다면 다음으로 고민해야할 것은 어떤 점을 더 개선할 수 있을까하는 부분이다.

잠재적인 개선 사항
솔루션이 이미 잘 작동하더라도 이 특정 예제에서 지정한 경계 내에서만 사용할 수 있게 구성되어있다. 그 이유 중 하나는 오류 처리가 거의 없기 때문이다. 그러한 애플리케이션이 더 많은 청중에게 배포될 때 발생하는 한 가지 문제는 문제가 발생한다는 것이다. HTTP 응답이 차단되고 요청이 실패하며 오래되었거나 회사 정책 또는 설치된 확장 프로그램에 의해 수정된 브라우저가 사이트 접근을 방해한다. 이러한 예기치 못한 행동에 대비하고 적절하게 대처해야 한다.
주의해야 할 또 다른 점은 전용 도구가 없다는 것이다. 마이크로 프론트엔드당 어떤 도구를 사용할지 결정할 수 있다는 것은 확실히 감사한 일이지만 여전히 몇 가지 사항을 변경할 수 있다면 좋을 것이다. 한 가지 예는 피드 서버에 업로드하는 것이다. cURL을 사용하는 것은 macOS 및 리눅스에서 적절한 솔루션일 수 있지만 Windows에서는 이상적이지 않다.
또한 현재 예제는 마이크로 프론트엔드가 게시될 때까지 버그를 볼 수 없다. 이것은 마치 어둠 속에서 일하는 것과 같다. 물론 이 예제이 SPA 구성 예제의 예시이기도 하지만 가장 먼저 변경해야 할 사항 중 하나이다.
고려해야 할 또 다른 사항은 피드 서버의 표시된 구현이 광범위하게 열려 있다는 것이다. 너무 크거나 신뢰할 수 없는 소스에서 가져온 파일의 업로드를 중지하는 데 제한이 없다. 또한 기존 업로드를 덮어쓸 수도 있다. 이는 긴 캐싱이 필요로 할 때 큰 문제될 수 있다.
확실히, 해당 예제 구현이 개선해야 할 점이 더러 있지만 일반적인 방향에서는 훌륭하다. SPA 구성의 예제 구현과 비교하여 느슨한 결합만으로도 솔루션이 훨씬 더 탄력적이다. 그럼에도 불구하고 실제로 사용할 수 있는 최종 본을 제공하려면 더 많은 것이 필요하다. 이 장의 뒷부분에서 이러한 누락된 부분을 처리하기 위한 프레임워크를 소개할 것이다.
이제 이 패턴의 일반적인 장점과 단점을 살펴보자.

장점과 단점
다른 패턴과 마찬가지로 이 스타일을 선택하거나 피해야 하는 분명한 이유가 있다. 주로 사이트리스 UI는 고도의 대화형 SPA에서 사용된다. 따라서 SPA 구성의 많은 장점과 단점이 공유된다. 그러나 개발자 경험과 느슨한 결합에 초점을 맞추기 때문에 개별 모듈의 개발이 훨씬 간단하다. 단점은 앱 셸 개발이 훨씬 더 복잡하다는 것이다. 이것은 표준 절충안이다. 즉, 모든 팀의 약간의 복잡성이 단일 팀의 훨씬 더 복잡한 것으로 교환된다는 것이다.
이 패턴의 가장 큰 단점은 앱 셸에서 제공하는 API에 대한 모듈의 묵시적이고 강력한 종속성이다. API 중 하나만 변경해도 해당 API를 사용하는 모든 모듈이 충돌할 수 있다. 설상가상으로 업데이트된 앱 셸을 출시할 때까지 이 문제를 인식하지 못할 수도 있다. 모듈이 독립적으로 배포되기 때문에 전체 시스템은 런타임에만 함께 제공된다. 컴파일 타임에 이러한 문제는 발견하기 쉽지 않으며 일반적으로 놓치기 쉽다.
대부분의 단점은 사이트리스 UI 패턴과 관련이 적고 일반적으로 느슨한 결합 문제와 관련이 있다고 볼 수 있다. 이것이 사실이지만 패턴이 느슨한 결합을 수용하기 때문에 이러한 모든 문제는 이제 사이트리스 UI 구현에서도 찾을 수 있다. 다른 한편으로 느슨한 결합과 함께 제공되는 모든 이점도 확인할 수 있다.
잠재적으로 사이트리스 UI 패턴의 가장 큰 장점은 기본적으로 일관된 애플리케이션을 거의 보장한다는 것이다. 필수 앱 기능에 액세스할 수 있는 API를 제공하면 모든 모듈이 동일한 인터페이스를 통과하는 것이다. 당연히 이 경계에서 동일한 패턴과 관행이 이미 완전히 결정되어 있다. UX는 레이아웃을 중심으로 형성되며 API를 통해 적절하게 전달된다. 여기에서 이 아키텍처 스타일은 자율성을 너무 많이 손상시키지 않으면서 모든 마이크로 프론트엔드를 하나로 묶는다.
Microsoft와 같은 대형 기술 회사는 이미 사이트리스 UI를 여러 가지 형태로 사용하고 있지만 이러한 패턴은 디지털 혁신을 추진하기만 하기 보다는 고전적인 회사에도 적용된다. 이에 대한 한 가지 예는 패턴을 사용하여 새로운 고객 대면 포털을 구축한 ZEISS 이다. 또한 나중에 실제 사이트리스 UI 구현에 대해 더 자세히 논의할 것이다. (16장, 사례 연구 참조).
프론트엔드의 사이트리스 UI 패턴이 도입한 접근 방식은 백엔드의 서버리스 기능 아키텍처와 매우 유사하다. 이 두 접근 방식이 유사한 이유와 공유할 수 있는 장단점을 완전히 이해하려면 세부적으로 비교하는 것이 필요하다.

서버리스와 비교
백엔드에 마이크로서비스가 구축된 후 서버리스 또는 FaaS(Function as a Service)로 대중화된 새로운 종류의 아키텍처가 도입되었다. 간단히 말해서 이 아키텍처는 백엔드 서비스를 단일 기능으로 축소했으며, 여기에서 모든 필수 요소는 통합 런타임에서 처리된다.
초기에 서버리스는 주로 클라우드 제공업체의 판매 포인트였다. 그들은 적은 비용으로 새로운 패턴을 옹호했고 결국 이러한 함수는 공유 및 제공 런타임을 사용하기 때문에 전용 리소스가 필요한 사용자 지정 컨테이너에서 실행할 필요가 없다. 대신 그저 유휴 상태로 앉아서 필요할 때만 호출되는 요청을 기다릴 수 있다. 런타임은 다양한 테넌트에서 다양한 기능을 제공할 수 있게 되었다.
다음 섹션에서는 로컬 개발이 작동하는 방식과 모듈이 게시되는 방식이라는 두 가지 주요 측면에 대한 비교에 중점을 둘 것이다. 로컬 개발을 위한 설정부터 시작하자.

로컬에서 개발
대부분의 FaaS 솔루션이 전용 온라인 IDE를 제공하더라도 표준 IDE를 사용하여 거의 모든 FaaS 솔루션을 개발할 수 있다. 때때로 클라우드 공급자는 서버리스 기능에 대한 코드를 조작하는 직접적인 방법을 제공한다. 예를 들어 마이크로소프트의 Azure는 인기 있는 비주얼 스튜디오 코드 텍스트 편집기의 기반이 되는 Monaco 편집기를 직접 통합한 최초의 사용자 중 하나였다.
서버리스 프로젝트의 주요 원칙 중 하나는 로컬 개발이 가능할 뿐만 아니라 표준 프로젝트의 개발만큼 간단하다는 것이다. 따라서 개발자는 FaaS 프로젝트를 복제하여 로컬 시스템에서 빌드, 디버그 및 게시할 수 있어야 한다.
사이트리스 UI를 통해 동일한 경험을 제공하는 것을 목표로 한다. 새로운 개발자는 단일 마이크로 프론트엔드의 코드를 복제하고 로컬 디버깅 세션을 시작할 수 있어야 한다. 특별한 개발 환경에서 실행되는 인스턴스에 모듈을 삽입하기 위해 URL이나 특별한 트릭을 알 필요는 없다. 대신 전체 경험이 가능한 한 지역적이어야 한다.
에뮬레이터 패키지를 사용하면 가능하다. 에뮬레이터는 일반적으로 앱 셸 내에서 제공되는 런타임의 특별한 개발 빌드이다. 동일한 코드를 실행하기 때문에 원본과 동일하게 작동한다. 이 접근 방식의 단점은 에뮬레이터에 약간의 설치가 필요하다는 것이다. npm 인프라가 여기에서 도움이 되지만 설치에서는 특정 버전이 선택되었다고 가정한다. 결과적으로 오래된 버전의 에뮬레이터를 다룰 가능성이 상당히 높다는 것이다.
오래된 버전의 에뮬레이터를 사용하는 것은 처음에는 문제처럼 들리지 않는다. 그러나 오래된 버전 설치로 인해 발생하는 몇 가지 즉각적인 문제가 있다. 첫째, 기능이 변경되어 잘못된 입력 정보를 제공하고 나중에 런타임 오류가 발생할 수 있다. 둘째, 화면에 보이는 디자인도 변경되어 출시 시 디자인 불일치가 발생할 수 있다.
대부분의 문제에 대한 수정은 배포 후 적절한 종단 간 테스트가 수행되도록 하는 것이다. 또한 보다 광범위한 통합 검사를 수행해야 한다고 주장하는 것도 솔루션의 일부이다. 일반적으로 이들 중 어느 것도 새로운 것이어서는 안된다. 높은 품질 보증과 허용 기준의 상세한 검증은 많은 프로젝트에서 개발 프로세스의 필수적인 부분이다.
결국 대부분의 검사는 실제로 모듈을 게시할 때 수행할 수 있다.

모듈 게시
모든 FaaS 플랫폼에는 기존 기능을 빠르게 업데이트하거나 새로운 기능을 추가할 수 있는 방법이 필요하다. 마이크로서비스는 도커와 같은 컨테이너 형식을 활용하지만 FaaS는 일반적으로 tar 파일과 같은 간단한 아카이브 형식을 활용한다.
마이크로 프론트엔드의 경우 상황이 비슷하다. 백엔드 기반 마이크로 프론트엔드는 일반적으로 컨테이너 형식으로 제공되지만 클라이언트 측에서 구성된 변형도 그런 방식으로 출시될 수 있다. 사이트리스 UI의 경우 간단한 아카이브 형식으로 충분하고 인기 있는 선택은 tgz 확장자를 사용하는 압축된 tarball일 수 도 있다.
tgz 파일을 패키지 형식으로 사용하면 여러 가지 이점이 있다. 가장 중요한 점은 형식이 이미 npm 도구 자체에서 생성되고 사용된다는 것이다. 가장 중요한 개발 도구를 준수하는 것은 개발자 생산성과 관련하여 매우 중요하다. 사용자 지정 도구에 의존하는 대신 표준 응용 프로그램을 재사용할 수 있다.
npm 패키지 형식은 메타데이터에 대해 미리 정의된 위치인 패키지도 제공한다. .json 파일과 같은 파일은 또 다른 패키지에 포함된 파일에 대한 정보를 얻는 데 도움이 된다. 예를 들어, 메인 필드의 값은 패키지를 나타내는 엔트리 모듈의 위치를 알려준다.
클라우드 제공업체의 FaaS 오퍼링은 새로운 기능을 수용하는 통합 방식과 함께 제공되지만 맞춤형 사이트리스 UI 솔루션에서는 이를 처리할 서비스를 제공해야 한다. 일반적으로 이 책임은 피드 서버에 있다.

중요한 사항
피드 서버의 오픈 소스 구현은 Piral Feed Service이다. 사용 가능한 소스 코드는 npm 패키지에서 제공되는 게시 및 프로비저닝 모듈을 허용한다. 서비스의 클라우드 버전은 무료 커뮤니티 에디션과 상용 엔터프라이즈 오퍼링으로 존재한다. 이러한 버전에는 동적 모듈 프로비저닝과 같은 더 많은 기능이 있고 자세한 내용은 https://www.piral.cloud/에서 확인할 수 있다.

따라서 피드 서버는 배포 대상과 같은 핵심 인프라를 관리하지 않고도 마이크로 프론트엔드를 작성하는 방법을 제공하는 핵심 인프라 조각이다. 기존 SaaS 제품에서 가져온 경우 인프라가 전혀 필요하지 않은 프론트엔드 솔루션을 구축할 수 있다. 모든 것이 일부 정적 스토리지에서 호스팅되거나 타사 클라우드 서비스를 통해 제공될 수 있기 때문이다.
이 모든 것이 사이트리스 UI를 서버리스 기능과 매우 유사하게 만든다. 백엔드 대신 프론트엔드 단계에서 작동한다. 이전에 보았듯이 이 구성에서 가장 중요한 부분은 런타임이다. 구현할 때 고려해야 할 사항에 대해 좀 더 자세히 살펴보자.

런타임 생성하기
이미 런타임이 사이트리스 UI 구현의 중심을 형성한다는 것을 확인했다. 런타임이 출시되어 프로덕션 환경에서 실행될 때 오케스트레이터로 형성되지만 새 모듈의 로컬 개발을 허용하는 에뮬레이터도 제공한다.
이렇게 하면 자동 프로비저닝, 캐싱 규칙 및 런타임 최적화와 같은 기능을 모두 프로덕션 환경에서 사용할 수 있지만 개발 중에 개발자 효율성이 떨어지지는 않는다.
런타임에 중요한 결정에 집중하려면 기술 기반을 제공할 확립된 프레임워크를 선택해야 한다. 한 가지 가능한 옵션은 Piral이다.

중요한 사항
완전한 사이트리스UI 구현을 구상하는 것은 어렵다. 로컬 개발을 강조하는 앱 셸용 모델이 필요할 뿐만 아니라 피드 서비스와 마이크로 프론트엔드 패키징을 정의하고 구현하면서 마이크로 프론트엔드에 대한 신뢰성을 갖춘 맞춤형 API를 추가해야 한다. 이를 우회하는 빠른 방법은 본질적으로 플러그인 기반 UI를 생성하여 사이트리스UI 구현에 필요한 모든 것을 제공하는 도구인 Piral 프레임워크이다.

다음 섹션에서는 Piral을 사용하여 앱 셸을 만들고 배포하는 방법을 살펴볼 것이다. 실제로 배포하기 전에 먼저 런타임을 빌드한다.

Piral로 런타임 빌드
다른 많은 프레임워크와 마찬가지로 Piral은 빠르게 시작할 수 있도록 많은 템플릿, 상용구 생성기 및 자습서와 함께 제공된다. 표준 템플릿을 사용하지 않고 대신 처음부터 새 프로젝트를 만드는 것으로 시작한다.
첫 번째 명령은 npm 명령줄 도구를 사용하여 새 package.json 파일을 만드는 것이다.
npm init -y

그런 다음 종속성을 설치할 수 있다. 이 경우 piral 패키지와 piral-lazy 플러그인을 사용하여 런타임을 보여주고 piral-cli 및 piral-cli-webpack 패키지를 사용하여 실제로 빌드한다.
이러한 종속성을 설치하는 명령어는 다음과 같다.
npm i piral piral-lazy –save
npm i piral-cli piral-cli-webpack –save-dev

앱 셸은 HTML 파일 형식으로 클라이언트에 전송된다. HTML 파일이 있는 위치를 Piral CLI에 알리려면 package.json을 변경해야 한다. 이것을 추가할 것이다.
{
... // previous properties
"app": "src/index.html"
}

HTML 파일은 다음과 같이 간단하고 기본적으로 사용된다.
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>My Siteless UI App</title>
</head>
<body>
<div id="app"></div>
<script src="./index.jsx"></script>
</body>
</html>

표준 HTML 템플릿 외에도 로더 스크립트에 대한 참조가 배치된다. 이것은 툴링에서 번들러의 진입점을 정의하는 데 사용된다. HTML은 소스를 식별하는 데만 사용되므로 여기서 TypeScript 파일을 직접 참조할 수도 있다. 소스는 빌드 아티팩트에서 생성된 파일 이름으로 대체된다.
그런 다음 로더 스크립트는 다음과 같이 간단한 구조를 염두에 두고 작성할 수 있다.
import { renderInstance } from 'piral';
import { createLazyApi } from 'piral-lazy';
import { createCustomApi } from './api';
import { errors, layout } from './components';

const feedUrl = 'https://feed.piral.cloud/api/v1/
pilet/<feed-name>';

function requestPilets() {
return fetch(feedUrl)
.then(res => res.json())
.then(res => res.items);
}

renderInstance({
errors,
layout,
requestPilets,
plugins: [createCustomApi(), createLazyApi()],
});

Piral의 용어로 모듈을 파일렛(Pilet)이라고 한다. 로더에서 Piral에 pilet 목록으로 응답하는 피드 서버에 연결할 수 있는 기능을 제공해야 한다. 이를 지정하는 함수를 requestPilets라고 한다. 이 예에서는 공식 Piral Feed Service를 사용하여 파일렛을 호스팅한다. feed-name 자리 표시자를 피드 이름으로 바꿔야 한다.
piral-lazy 플러그인 패키지의 통합은 제공하는 플러그인에 createLazyApi 설정 함수를 호출한 결과를 추가하여 이루어져있다. 오류 및 레이아웃 개체는 UI의 일반적인 레이아웃 및 오류 부분에 대한 표시 요소를 정의하는 구성 요소로 채워진다.
api 모듈은 다음과 같이 정의된다.
export function createCustomApi() {
return context => ({
myApiFn() {
    console.log(‘Hello from the API!’);
},
    }),
  }




이렇게 하면 모듈에서 사용 가능한 API에 myApiFn 함수가 추가된다. 현재 Piral CLI를 사용하여 런타임을 번들로 사용하고 배포할 수 있다.

Piral로 런타임 배포
앱 셸 빌드는 이미 Piral CLI에 통합되어 있다. build 명령어는 현재 폴더의 package.json 파일을 자동으로 처리하고 그 안에 있는 HTML 파일을 처리한다.
예를 들어 다음과 같이 npx 작업 실행기를 통해 명령을 실행하기만 하면 된다.
npx piral build

이렇게 하면 두 개의 아티팩트가 생성된다. 하나는 일부 정적 저장소에 업로드할 수 있는 파일을 포함하는 dist/release 폴더이다. 이것이 앱 셸의 프로덕션 빌드이다. dist/emulator 폴더에는 tgz 파일만 있다. npm 패키지에 함께 번들로 제공되는 에뮬레이터로 이제 공식 레지스트리 또는 일부 사설 npm 레지스트리에 게시할 수 있다.
GitHub를 런타임 기반으로 사용하여 정적 웹 사이트의 단순화된 호스팅을 위해 GitHub 페이지를 활용할 수도 있다. 올바른 단계를 수행하는 가장 간단한 방법은 다음과 같이 gh-pages 패키지를 설치하는 것이다.
npx gh-pages -d dist/release

이렇게 하면 dist/release 폴더에서 모든 파일을 가져와서 gh-pages 분기의 루트 디렉터리에 넣는다. 일반적으로 이것은 다른 분기를 기반으로 하지 않고 자체 변경 이력을 포함하는 분기를 의미하는 orphan 분기이다.
이 분기를 푸시하면 https://<username>.github에서 사용할 수 있는 새 사이트로 연결된다. io/<project>, 여기서 username은 GitHub 사용자 이름을 나타내고 프로젝트는 레포지토리 이름을 보여준다. 웹사이트는 몇 초 안에 활성화되어야 한다.
그런 다음 에뮬레이터를 나타내는 npm 패키지를 게시할 수 있다. 가장 쉬운 방법은 다음과 같이 npm 명령어를 사용하는 것이다.
npm publish dist/release/<package-name>.<package-version>.tgz

이제 라이브 및 온라인일 뿐만 아니라 에뮬레이터 형태로 사용할 수 있는 런타임이 있으므로 이를 위한 몇 가지 모듈을 작성할 차례이다.

 
모듈 작성
Piral로 만든 앱 셸용 모듈을 파일렛(Pilet)이라고 부른다. 파일렛은 대부분의 프론트엔드 애플리케이션과 같이 개발된다. 작은 예외는 파일렛이 독립적인 애플리케이션이 아니라 독립 라이브러리에 더 가깝다는 점이다.
새 파일렛을 시작하려는 경우 두 가지 옵션이 있다. 통합 도구를 사용하여 올바른 설정으로 새 프로젝트를 스캐폴딩하거나 앱 셸에서 했던 것처럼 처음부터 시작할 수 있다. 에뮬레이터를 게시하면 명령어에서 새 프로젝트를 스캐폴딩할 수 있다.
npm init pilet –source <package-name> --builder webpack –registry https://registry.npmjs.org/ --defaults 


해당 명령어가 파일렛을 나타내는 package.json 파일로 새 npm 프로젝트를 초기화한다. 파일렛은 이전에 게시된 에뮬레이터 패키지를 대상으로 한다. 번들링을 위해 웹팩을 다시 사용한다. 에뮬레이터 게시에 개인 npm 레지스트리가 사용된 경우 명령의 URL도 조정해야 한다.
새 파일렛을 스케폴드하면 바로 개발을 시작할 수 있다. 이러한 설정에서 프레임워크에 국한되지 않는 구성 요소를 구현하는 방법을 알아보기 전에 먼저 파일렛의 수명 주기에 대한 세부 정보로 이동하여 살펴본다.

파일렛의 수명 주기
파일렛의 수명 주기를 논의할 때 두 가지 다른 종류의 수명 주기를 고려해야 한다.
	마이크로 프론트엔드의 소프트웨어 개발 수명 주기 – 초기 생성에서 유지 관리, 단계적 제거에 이르기까지
	파일렛의 기능적 수명 주기 – 로딩에서 설치, 제거까지
여기서 두 가지를 모두 다루도록 하고 파일렛이 어떻게 작동하는지 완전히 이해하기 위해 후자에 초점을 맞추도록 하자.
이미 파일렛을 (이전 섹션에서) 스캐폴딩 했으므로 이 작업이 완료되면 원하는 기능의 개발을 시작할 수 있다. 디버깅 프로세스를 시작하기 위해 Piral CLI를 사용하여 다음과 같이 라이브 다시 로드로 개발 서버를 시작할 수 있다.
npx pilet debug

어느 시점에서 마이크로 프론트엔드는 첫 번째 배포를 위한 완전한 기능이 될 것이다. 이제 먼저 빌드를 진행해보자.
npx pilet build

또는 이미 어딘가에서 실행 중인 피드 서버가 있는 경우 직접 게시할 수도 있다. 이것이 생성된 npm 패키지에 대해 또는 하나의 명령어로 모든 작업을 수행하여 작동한다.
npx pilet publish –fresh -api-key <your-api-key> --url https://feed.piral.cloud/api/v1/pilet/<feed-name>

대상 피드로 최종 앱 셸 내 모든 파일렛의 소스로 사용된 동일한 피드를 선택한다.
이 마이크로 프론트엔드에 대한 업데이트는 동일한 세 가지 명령으로 개발 및 출시된다. 먼저 문제를 디버깅하고 수정한 다음 빌드를 시도한다. 모든 것이 잘되면 업데이트된 파일렛을 게시할 수 있다. 확인해야 할 유일한 것은 package.json 내에서 버전을 변경하는 것이다. 일반 npm 패키지와 마찬가지로 모든 파일렛을 버전당 한 번만 게시할 수 있다. 그 이유 중 하나는 파일렛을 무기한으로 캐시할 수 있도록 하여 실제로 효율적인 프론트엔드 리소스가 되도록 하는 것이다.
효율성을 위해 실제 게시 단계는 CI/CD 파이프라인에 맡겨야 한다. 앱 셸에 GitHub를 사용했기 때문에 GitHub 레포지토리에서 이 파일을 호스팅할 수도 있다. 따라서 GitHub Actions를 사용하는 것은 파이프라인을 빠르게 설정하는 간단한 방법이다.
파일렛의 .github/workflows/publish.yml 파일은 publish-pilet-action을 사용하여 Piral CLI를 활용한다. 게시용 API 키는 다음과 같이 GitHub 비밀을 통해 제공된다.
name: CI

on:
push:
branches:
- master

jobs:
publish-pilet:
name: Build and Deploy
runs-on: [ubuntu-16.04]
steps:
- uses: actions/checkout@master
- name: Publish Pilet
uses: smapiot/publish-pilet-action@v2
with:
    feed: <feed-name>
    api-key: ${{ secrets.apiKey }}

이제 파일렛이 성공적으로 게시되었다고 가정해 보자. 사용자가 앱 셸에 액세스하면 어떻게 됩니까? 이전과 마찬가지로 로더 스크립트가 초기화될 때 피드 서버가 호출된다. 그러나 이와 대조적으로 응답은 비어 있지 않고 게시된 파일렛을 포함한다.

이제 피드 서버의 응답이 다음과 유사하게 보인다.
{
"items": [
{
"name": "<pilet-name>",
"version": "1.0.0",
"link": "https://assets.piral.io/pilets/<feed>
/mario5-sample-pilet/1.2.0/index.js"
}
]
}

해당 링크 속성에 언급된 URL에서 로드되어야 하는 단일 마이크로 프론트엔드가 있음을 앱 셸에 알려준다
스크립트가 평가되면 Piral 프레임워크는 스크립트에서 내보낸 특수 기능인 setup을 찾는다. 이 기능은 통합을 위해 필요하다. API 개체를 유일한 인수로 사용하여 Piral에서 호출된다. Piral은 각 마이크로 프론트엔드에 대해 세 단계를 나눠진다.

• 평가(마이크로 프론트엔드가 로드됨).
• 설정(마이크로 프론트엔드가 통합됨).
• 분해(마이크로 프론트엔드가 제거됨). 

첫 번째 단계는 암시적이지만 두 번째 단계는 스크립트가 마이크로 프론트엔드로 인식되는 데 필요한다. 스크립트가 설정 기능을 내보내지 않으면 더 이상 통합할 수 없다. 반면에 분해 기능은 선택 사항이며 실제로는 필요하지 않다.

해제 기능이 유용한 이유 중 하나는 설정 기능이 두 번 실행되는 경우 충돌을 일으킬 수 있는 일부 리소스를 정리하는 것이다. 잠재적으로 동일한 설정 기능을 다시 실행하는 것은 개발 중에만 보여진다. 또는 앱 셸은 파일렛의 실시간 업데이트를 허용하는 방식으로 생성되어야 한다. 

이제 마이크로 프론트엔드 솔루션에서 실제로 구성 요소를 만들고 사용할 때이다.

프레임워크에 국한되지 않는 구성 요소 구현
파일렛의 index.jsx 파일은 다음과 같이 시작한다.
 export function setup(api) {
// ...
 }

새 페이지를 등록하려면 API에서 제공하는 registerPage 함수를 사용할 수 있다. 이 함수는 탐색을 트리거하는 경로와 콘텐츠로 표시할 구성 요소의 두 가지 인수를 예상한다.
export function setup(api) {
    api.registerPage(‘/example-page’, PageComponent);
}

구성 요소 자체는 인라인으로 정의하거나 다른 모듈에서 참조할 수 있다. 이상적으로는 일종의 지연 로딩을 사용하여 구성 요소가 렌더링되어야 할 때만 해당 코드를 로드한다
리액트를 사용하면 이러한 지연 로딩 메커니즘이 매우 간단하다 이 경우 다음과 같이 정의할 수 있다.
import * as React from 'react';
const PageComponent = React.lazy(() => import('./Page'));


Piral은 리액트에 대한 최고 수준의 지원을 제공하므로 이 경우에는 다른 조치가 없다. 그냥 작동한다. 그러나 Svelte와 같은 다른 프레임워크에서 가져온 구성 요소는 어떤가? 
Svelte 모듈을 처리하도록 웹팩을 이미 구성했고 Svelte에서 PageComponent를 이미 생성했다고 가정해보자.
import PageComponent from ‘./Page.svelte’;
Svelte에서 직접 오는 구성 요소의 등록은 불가능하다. 대신 일반 라이프 사이클을 사용하여 랩핑해야 한다.
export function setup(api) {
api.registerPage('/example-page', {
type: 'html',
component: {
mount(container, data) {
container.$svelte = new PageComponent({
target: container,
props: {...data},
});
},
update(container, data) {
Object.keys(data).forEach((key) => {
container.$svelte[key] = data[key];
});
},
unmount(container) {
container.$svelte.$destroy();
container.innerHTML = '';
},
},
});
}

이것은 구성 요소의 전체 DOM 수명 주기를 정의한다. 코드가 상당히 길기 때문에 이를 전용 함수로 추출하는 것이 합리적일 수 있다. 다행히도 이를 수행하는 Piral 플러그인이 이미 있으며 파일렛에서 직접 사용할 수도 있다. 
piral-svelte를 파일렛에 종속성으로 설치하면 다음과 같은 코드가 가능하다.
import { fromSvelte } from 'piral-svelte/convert';
import PageComponent from './Page.svelte';

export function setup(api) {
    api.registerPage('/example-page',
    fromSvelte(PageComponent));
}


마찬가지로 다른 프레임워크는 기존 플러그인을 사용하거나 명시적 라이프 사이클 정의가 있는 일반 HTML 구성 요소를 기반으로 구축하여 간단히 통합할 수 있다.

 
요약
이 장에서는 하나의 일관된 웹 애플리케이션으로 병합되는 개별 플러그인을 사용하여 매력적인 SPA를 만드는 방법을 배웠다. 클래식 플러그인 아키텍처와 달리 이러한 모듈은 애플리케이션 수준의 권한과 책임을 가질 수 있다.
이전의 SPA 구성과 마찬가지로 사용자 상호 작용이 상당히 높다는 것을 보았지만 SPA 구성과 달리 사용자 경험과 개발자 경험은 원활해야 한다. 내부 복잡성과 도구 의존성은 증가했지만 주요 단점은 앱 셸에 정의된 API에 대한 모듈의 종속성이다.
다음 장에서 앱 셸 업데이트를 효율적으로 처리하는 방법을 살펴보자. 공통의 기반을 구축하기 위해 거버넌스와 디자인 인식이 필요하다는 것을 알게 될 것이다.
다음 장에서는 주요 이해 관계자가 참여하는 준비 단계로 개발자뿐 아니라 모든 사람을 온보딩하는 여정을 시작할 것이다. 모든 사람이 기술 원칙을 인식하도록 하여 기대치를 높이고 요구 사항을 보다 명확하게 정의하는 방법에 대해 논의할 것이다.

 
섹션 3: “바쁘게 움직이는 꿀벌들” – 조직 크기 조정
이 섹션에서는 일반적인 함정, 커뮤니케이션 전략, UX/UI에 대한 영향 및 타인에게서 배운 교훈을 포함하여 조직의 관점에서 마이크로 프론트엔드를 성공적으로 관리하는 방법을 독자들에게 가르칠 것이다.

이 섹션에서 다룰 내용은 다음과 같다.
•	제 12장, 팀과 관계자 준비하기
•	제 13장, 종속성 관리, 거버넌스 및 보안
•	제 14장, UX와 스크린 디자인의 영향
•	제 15장, 개발자 경험
•	제 16장, 사례 연구




 
 
12 팀과 관계자 준비하기
이전 장에서 마이크로 프론트엔드를 구현하기 위한 기존 패턴에 대해 많이 배웠다. 올바른 패턴을 선택하는 것은 쉬운 일이 아니다. 올바른 아키텍처를 결정하려면 문제 설명을 잘 이해해야 한다. 

모든 기술적 결정이 올바르게 이루어지더라도 프로젝트가 실패할 수 있다. 이 장에서는 기술적이지 않은 문제로 인해 프로젝트가 실패할 수 있는 이유를 알아본다. 특히 팀과 이해관계자가 불일치 및 의사 소통 문제를 피하기 위해 준비할 수 있는 작업을 식별한다.

이 장에서는 다음 내용을 다룬다.

•	고위급 이해관계자와의 커뮤니케이션
•	프로덕트 오너 및 운영 위원회 처리
•	팀 구성

이 장의 모든 섹션이 귀하에게 적용되는 것은 아니다. 회사 및 프로젝트에 따라 팀 구성 또는 프로덕트 오너 커뮤니케이션의 책임이 다른 사람에게 주어질 수 있다. 프로젝트에 관련된 모든 사람이 같은 페이지에 있고 마이크로 프론트엔드를 활용하는 설정에서 자신의 역할을 수행하는 방법을 알고 있는 한 괜찮다.

그러나 이제 주제에 대해 자세히 알아보도록 하자.

고위급 이해관계자와의 커뮤니케이션
가정해야 할 한 가지는 고위급 이해 관계자가 마이크로 프론트엔드에 관심이 없다는 것이다. 그들은 또한 마이크로서비스나 기술적 실현의 다른 부분에 대해서는 신경 쓰지 않는다. 대신 그들은 자신의 비즈니스와 기술 구현이 비즈니스에 미치는 영향에 관심을 갖는다. 경영진 수준이 기술 구현에 신경 쓰지 않는 상황에서는 마이크로 프론트엔드를 언급해서는 안 된다고 생각하기 쉽다. "마이크로 프론트엔드"라는 이름이 이러한 이해관계자에게 종소리를 울리지 않을 수도 있지만, 여전히 당면한 시스템의 실제 이점과 함정에 대해 상기시켜야 한다.
다음 두 하위 섹션에서 우리는 경영진 수준을 다룰 때 기대 관리와 요약 작성이라는 두 가지 중요한 작업을 다룰 것이다. 기대 관리에 대한 간략한 설명으로 시작해보자.

기대치 관리
경영진 요약을 작성하거나 고위급 커뮤니케이션을 수행할 때 거의 가장 중요한 것은 기대 관리의 기술이다. 기대 관리는 관련 당사자가 주어진 기회를 놓치거나 실제로 주어진 것보다 더 많은 가능성이 있을 것이라고 믿는 함정에 빠지지 않도록 진행 상황과 전망이 명확하게 표현되는 방식이다. 두 경우 모두 결과는 실패한 프로젝트 또는 목표이다. 어느 쪽이든 공동 실망이 있다.

 
그림 12.1 – 기대의 피라미드

그림 12.1에서 볼 수 있듯이 기대치를 다룰 때 여러 수준이 있다. 많은 사람들이 기대를 충족시키는 것을 목표로 하지만, 청중을 놀라게 하는 것이 더 나을 수 있다. 더 나아가, 당신은 이것을 넘어 관객들이 경험을 기대하는 일종의 서스펜스를 구축할 수도 있다.

기대치 관리는 이해관계자와의 커뮤니케이션뿐만 아니라 다른 당사자 및 프로젝트 팀 자체와의 커뮤니케이션에 국한된다. 또한 적절한 기대 관리가 필요한 여러 가지가 있다. 그 중 다음을 찾을 수 있다.

•	회사 비전
•	사업 목표
•	프로젝트 목표
•	기능 의도

확실히, 그들 대부분은 특정 프로젝트와 아무 관련이 없지만 일반적으로 적어도 프로젝트와 약간 정렬되어야 한다.

중요한 노트

이 비유는 기대 관리에 대해 내가 가장 좋아하는 설명 중 하나이다.
Blake Basset 는 Microsoft Azure의 제품 관리자이다. 그는 기대 관리를 "다자간 업무로, 여러분이 어디로 가고 있는지, 어떻게 거기에 도달할 계획이며, 무엇을 제공할 것인지에 대해 팀 및 이해관계자 간에 공유된 이해를 시켜야 하는 업무이다. 그리고 그것은 시작에 불과하다. . 일단 확립된 기대치는 지속적으로 강화되고 필요할 때 조정되어야 한다." 라고 말한다. 매우 중요한 것은 그는 지속적인 노력을 강조한다.

실행 당사자와 개발 당사자 간의 단절을 방지하려면 시스템의 경계를 강조 표시해야 한다. 예를 들어 마이크로 프론트엔드를 사용하면 새로운 기능을 더 빠르게 구현하고 출시할 수 있다. 그럼에도 불구하고 소프트웨어에 버그가 없거나 즉시 구현된다는 의미는 아니다. 이는 구현이 더 적은 제약 조건으로 수행될 수 있고 작업이 승인된 후 기능을 온전히 릴리스할 수 있다.
마이크로 프론트엔드, 분산 개발, 프론트엔드 모듈 또는 이식 가능한 구성 요소와 같은 용어를 언급하면 경영진 이해관계자를 혼란스럽게 할 수 있다. 대신 우리는 시스템의 안팎을 강조하는 비유를 사용해야 한다. 예를 들어, 분산 개발을 호출하는 대신 독립 작업이라고 부를 수 있다. "각 방을 독립적으로 병렬로 수행할 수 있는 집의 인테리어 작업"과 같은 비유를 사용하면 너무 전문적이지 않고 용어를 지정하는 데 도움이 된다.
고위급 관계자와의 대부분 의사 소통은 간단한 서면 요약으로 이루어지므로 가장 효율적으로 요약할 수 있는 방법도 검토하는 것이 좋다.

보고용 요약 문서 작성하기
고위급 이해관계자는 대체로 두 가지 측면이 있다.
•	시간이 부족한 것으로 악명 높다.
•	그들은 심오한 기술적 세부 사항에 대해 걱정하고 싶어하지 않는다.

따라서 의사 소통을 효율적으로 수행해야 한다. 기술적인 세부 사항으로 그들을 괴롭히지 않고 가능한 한 빨리 현재 상황의 요점을 포착해야 한다.
운 좋게도 마이크로 프론트엔드는 없는 것보다 실제로 더 간단하다. 마이크로 프론트엔드를 사용하면 기술적으로 통합보다 기능에 개발 시간을 할애할 수 있으므로 차단 요소나 기술적 장애를 보고할 필요가 없다. 그러나 일단 기술적인 문제가 발생하면 문제보다 솔루션에 집중하는 것이 중요하다.
훌륭한 보고용 요약 문서를 통해 앞으로 나아가는 데 필요한 내용을 빠르게 소화할 수 있다. 더 많은 사람들이 필요한가? 외부 컨설팅? 혹은 도움이 되는 소프트웨어를 구입해야 할까? 이러한 결정을 내리기 위해 문제를 이해해야 하는 경우 전체 보고서가 도움이 된다. 전체 보고서가 누락된 경우 누군가가 보고서를 요청할 것이다.
전체 마이크로 프론트엔드 솔루션의 기술 책임자로서 실제 진행 상황을 파악하기 어려울 수 있다. 결국, 독립적인 개발이 진행되는 여러 스트림이 있을 것이다. 여기에서 개발이 분산되더라도 전체 비즈니스(적어도 보고해야 하는 비즈니스)는 여전히 단일체라는 사실을 잊어서는 안 된다.
분산 개발 상태를 수집하기 위한 두 가지 솔루션이 있다.
•	각 팀의 상태를 요청한다. 즉, 각 팀에서 실행 요약/보고서를 받는다.
•	수평적 팀 또는 모든 개발 팀에 관련된 사람에게 보고서 작성 책임을 부여한다.

후자는 팀 간에 공유되는 스크럼 마스터 또는 애자일 코치 길드가 있는 경우 가장 합리적이다. 그러면 이 길드가 모여 진행 상황을 논의하고 보고서를 작성할 수 있다. 그렇지 않으면 고전적인 배포 및 집계 접근 방식을 사용할 수 있다.
비즈니스 프로세스와 관련하여 임원 수준이 가장 중요한 것일 수 있지만 그보다 더 중요한 것은 프로젝트를 직접 담당하는 실무자이다. 이러한 프로젝트 리더와 프로덕트 오너는 종종 "운영 위원회"로 분류되는 추가 책임 범위를 도입할 수도 있다. 따라서 이러한 당사자를 다루는 것은 적어도 전반적인 기대 관리 만큼 중요하다. 그들에 대해 무엇을 해야 하는지 살펴보자.

프로덕트 오너 및 운영 위원회 처리
역할에 따라 프로덕트 오너 및 운영 위원회와 같은 관련 주체를 다루어야 한다. 아마도 당신은 프로덕트 오너 자신이다. 어떤 경우든 고위급 이해관계자와 마찬가지로 존중해야 하는 특정 의사 소통 규칙이 있다.
프로덕트 오너에게 프로젝트의 가장 중요한 측면 중 하나는 누가 무엇을 담당하는지 아는 것이다. 결국 적절한 사람에게 업무가 맡겨져야 효율적으로 수행할 수 있다. 모놀리식 환경에서 역할과 책임은 분산된 조직에서보다 훨씬 쉽게 알 수 있다. 따라서 우리는 분산된 환경에서 투명성을 가져올 방법이 필요하다.
마이크로 프론트엔드 솔루션에서 더 투명해지는 한 가지 방법은 RACI 매트릭스와 같은 기술을 활용하는 것이다. 각 개발 팀은 RACI 매트릭스를 작성하고 유지 관리할 책임이 있는 한 사람을 할당한다.

 
그림 12.2 – 업무마다 네 가지 레벨 중 하나의 역할을 부여하도록 하는 RACI 모델


그림 12.2와 같이 작업 별로 할당할 수 있는 4가지 수준이 있다. 작업 마이크로 프론트엔드 공간은 피처 영역과도 관련될 수 있다. 따라서 마이크로 프론트엔드의 균형 잡힌 유지보수 등의 작업이 가능하다. 모든 사람이 이 네 가지 수준 중 하나를 할당 받을 필요는 없다. 역할에 레벨을 할당해서는 안 되는 경우가 많다.

최근에 더욱 인기를 얻고 있는 또 다른 접근 방식은 스워밍(swarming)이다. 스워밍은 협업 네트워크 기반 접근 방식을 사용하여 작동하므로 분산 개발에 이상적이다. 또한 활동으로 측정되는 보수적인 계층적 지원과 비교하여 스워밍은 가치 창출로 측정한다.
보수적 모델은 일반적으로 사일로와 계층 구조를 만드는 경향이 있다. 명확한 방향과 이해하기 쉬운 선형 파이프라인과 같은 몇 가지 이점이 분명히 있지만 현대 프로젝트에서는 그 역할을 제대로 포착하지 못한다.
스워밍은 경영진 수준의 동의가 완전히 제공된 경우에만 작동한다. 스워밍은 급여 등급을  혼재하는 것과 같은 즉각적인 단점을 제공하기 때문에 첫 번째로 보일 반응은 반발일 수 있다. 고위급 관계자는 이익이 아닌 비용만 보게 될 가능성이 크다. 또한 워크플로우가 더 혼란스러워 보일 것이다. 한편으로는 스워밍은 사람들이 동적으로 모여 페어 프로그래밍 및 기타 기술을 사용하여 당면한 문제를 해결할 수 있다.
혼란 속에서 길을 잃지 않으려면 더 많은 스크럼 마스터나 애자일 코치가 필요하다. 결과적으로 즉시 비용이 다시 한 번 증가한다. 그러나 결국에는 프로덕트 오너와 개발 팀 간의 상호 작용도 더 높아져야 한다. 이것이 처음에는 문제처럼 보일 수 있지만 더 나은 소프트웨어로 이어질 것이다. 요구 사항이 완전히 이해됐을 뿐만 아니라 개발자가 잠재적으로 개선, 형성 또는 질문하는 경우 결과 소프트웨어의 품질이 더 좋다.
불행히도, 특히 기업에서 시작하는 대규모 프로젝트의 경우 다른 주체가 운영위원회를 돌봐야 하는 경우도 있다. 운영위원회는 프로젝트에 지침, 방향 및 제어를 제공하는 사람들의 모임이다. 일부 운영 위원회는 프로젝트 리더의 책임을 경감하기 위해 구성되는 반면, 일부 위원회는 모든 작업을 수행하기 전에, 특히 돈을 쓰기 전에 모든 업무를 협의하는 완전한 통제 기관이다.
운영 위원회는 스워밍 접근 방식 같은 환경에서 수행되는 비계층적 작업의 천부적인 반대자이다. 그러나 목표가 모든 수준에서 운영 위원회와 싸우는 것이 되어서는 안 된다. 그것이 옳은 일처럼 보일지 모르지만 실제로는 반대의 결과를 초래할 것이다. 그 대신에 이는 프로젝트에 더 많은 거버넌스 수준이 필요함을 의미한다. 우리는 다음 장에서 거버넌스의 전체 주제를 자세히 다룰 것이다. 현재로서는 운영 위원회를 처리하고 모든 프로젝트 집계 업무를 처리하기 위해 하나의 중앙 팀이 필요하다는 사실만 알면 된다. 일반적으로 이 팀은 앱 셸도 담당한다.
마이크로 프론트엔드 또는 모든 종류의 모듈식 솔루션 시스템의 성공에 위험하지만 운영 위원회도 올바르게 처리되면 가치를 제공할 수 있다. 다양한 패턴에서 보았듯이 더 많은 자유를 가능하게 하는 아키텍처 스타일과 이미 앱 셸에서 더 많은 결정을 내리는 아키텍처 스타일이 있다.
예를 들어 사이트리스 UI 패턴을 사용하면 개별 모듈이 수행할 수 있는 작업을 제한하기 위해 여러 경계를 정의할 수 있다. 프로젝트 및 조직에 따라 더 많거나 적은 자유를 주기 위해 사용될 수 있다. 이론적으로 해당 도메인별 기능을 제외한 대부분의 결정을 미리 결정하는 데 사용할 수 있다.
결국, 이것은 모두 올바른 팀 구성의 문제이다. 어떤 팀 구성이 가능하고 기존 조직을 어떻게 변경할 수 있는지 조사해 보자.

팀 구성
종종 마이크로 프론트엔드를 채택하는 것은 기술적인 문제가 아니라 조직의 변화에 관한 것이다. 마이크로서비스와 마찬가지로 조직은 아키텍처를 수용하고 팀 구조에 반영해야 한다. 제품과 프로젝트에 기업의 조직 구조가 반영되는 것을 콘웨이(Conway)의 법칙이라고 한다.

 
중요한 노트

컴퓨터 프로그래머 Melvin E. Conway는 1960년대 후반에 중요한 깨달음을 얻었다. 그는 "시스템(광범위하게 정의됨)을 설계하는 모든 조직은 그 구조가 조직의 커뮤니케이션 구조의 사본인 디자인을 생성할 것"을 발견했다. 그의 아이디어는 시스템의 다른 부분이 다른 팀이나 다른 사람에 의해 수행될 것이라는 관찰에서 비롯되었지만 이러한 모든 것은 서로 소통이 필요하다. 그러므로 처음 시작할 때 이미 알고 있는 조직적인 셋업을 미러링해라. 

결과적으로 모놀리식 기업 문화는 마이크로 프론트엔드 솔루션의 분산 작업을 완전히 수용하지 못할 것이다. 가장 쉬운 방법은 기존 팀 설정을 근본적으로 변경하는 것이지만 경험상 거의 작동하지 않는다. 그것이 효과가 있었다면 마이크로 프론트엔드가 도입되기 전에 팀의 설정이 이미 변경되었을 것이다.
먼저 마이크로 프론트엔드 덕분에 가능한 팀 설정을 이해해보자. 그런 다음 기존 팀 조직이 어떻게 변경될 수 있는지 알아볼 것이다.

가능한 팀 설정 이해
마이크로 프론트엔드의 가장 좋은 점 중 하나는 이 아키텍처를 활용하면 거의 모든 팀 구성이 가능하다는 것이다. 그러나 아시다시피 큰 힘에는 큰 책임이 따른다. 올바른 팀 구성을 선택하는 것은 그 자체로 힘든 일이다.
가장 인기 있는 설정은 무엇일까? 지금까지 가장 인기 있는 설정은 마이크로 프론트엔드당 하나의 전담 팀을 배치하는 것이다. 수직 팀 설정이라고도 한다.


 
그림 12.3 – 수직적 팀 설정

그림 12.3은 수직적 팀 구성을 보여준다. 각 팀은 완전히 독립적이며 각 역할을 포함한다. 따라서 예를 들어 UX 디자인이 누락된 팀은 차단되지 않는다. 그림에서 백엔드는 하나의 블록으로 표시되지만 자리 표시자로만 간주되어야 한다. 백엔드도 프론트엔드와 매우 유사하게 설계되어 여러 팀을 호스팅할 수 있다.
조금 더 나아가서 백엔드와 프론트엔드 사이의 겹침을 상상할 수도 있다. 이렇게 하면 실제 풀스택 팀을 만들 수 있다. 풀스택 팀은 프론트엔드와 백엔드 코드 모두에서 책임을 지는 팀이다.


 
그림 12.4 – 풀 스택 팀 설정

그림 12.4에서 볼 수 있듯이 풀스택 팀이 있다고 해서 백엔드를 처리하지 않는 프론트엔드 팀이 있거나 백엔드의 일부만 전담하는 팀이 있다는 것은 배제되지 않는다.
당연히 앱 셸은 반드시 전체 스택 팀을 생성하지 않는 프론트엔드 구성 요소이다. 종종 풀스택 팀은 도메인 중심이므로 풀스택 팀은 문제 도메인에 할당된 프론트엔드 및 백엔드 모듈을 소유한다.
한 단계 더 나아가 각 팀의 모든 역할을 복제하고 싶지 않을 수도 있다. 품질 보증 또는 UX 디자인과 같은 일부 교차 문제는 공유 리소스로 수행할 수 있다. 그런 다음 이 사람들은 다른 팀에서 일하게 된다.

 
그림 12.5 – 공유된 팀 설정

공유 팀 설정의 다이어그램은 그림 12.5에 나와 있다. 공유 리소스는 처음에는 더 저렴한 접근 방식이지만 일부 개발 시간을 적극적으로 차단하여 일부 비용을 낭비하게 된다.

전반적으로 일관성에 대한 요구가 상당히 높을 때 공유 설정이 가장 적합하다. 종종 전담 역할을 맡을 수 있는 사람의 수는 이 접근 방식을 선호하는 결정적인 요소가 아니다.
다른 극단은 확실히 모든 개발 리소스를 공유하는 것이다. 이것은 모든 마이크로 프론트엔드가 기본적으로 모든 사람에 의해 개발되는 수평 설정을 만든다. 실제로 이 접근 방식은 덜 일반적으로 보일 수 있지만 실제로는 꽤 인기가 있다. 그러나 불행히도 일반적인 문제가 있다.

 
그림 12.6 – 수평적인 팀 설정

이 설정을 선택해야 하는 충분한 이유가 있을 수 있지만, 마이크로 프론트엔드로의 이동이 시기상조이고 도메인 분해가 충분하지 않거나 개발자 사고 방식이 여전히 모놀리식 접근 방식을 따르고 있다는 것을 의미할 수도 있다. 그림 12.6에서 도식적으로 표시된 수평 분할을 볼 수 있다. 실제로 모든 개발자가 모든 모듈에서 작업하는 것을 볼 수는 없지만 요점은 알 수 있다.
마지막으로 이상적인 솔루션은 제시된 솔루션의 조합일 수 있음을 잊지 말아야 한다. 이러한 "하이브리드 팀 설정"은 여러 철학이 팀 조직을 정의하는 데 사용할 수 있다는 것을 말한다.


 
그림 12.7 – 하이브리드 팀 설정

그림 12.7에서 하이브리드 팀 설정에 대한 한 가지 예를 볼 수 있다. 일부 팀은 전체 스택 책임을 받지만 응용 프로그램의 다른 부분은 전체 팀이 작업하는 것을 정당화하기에는 너무 작을 수 있다. 여기에서 두 부분 중 하나는 수평적 팀에서 처리하거나 실제로 공유 리소스의 도움을 받는다. 다른 부분은 자율 수직 팀을 활용할 수 있다.
종종 하이브리드 접근 방식의 문제는 실제 솔루션에 적합하지 않다는 것이 아니라 너무 많은 사용자 지정 설정을 효율적으로 고려하기 어렵다는 것이다. 표준의 경우 특정 팀 구성을 지원하는 방식으로 도메인 분해가 이미 수행됐다.
결국 실제 팀 구성은 그렇게 중요하지 않다. 중요한 부분은 팀원들이 자신의 업무에 대해 권한을 부여 받고 책임감을 느끼는 것이다. 팀 설정이 이러한 사고 방식을 가능하게 하면 올바른 길로 가고 있다.
시작하기 전에 올바른 팀 설정을 찾는 경우는 많지 않다. 그러나 특정 팀 설정을 결정한 후에도 더 많은 최적화의 여지를 찾을 것이다. 원하는 조직 원칙을 반영할 수 있도록 팀 설정을 변경하는 방법을 살펴보자.

팀 조직 변경
기존 팀의 설정을 변경하는 것은 어렵다. 종종 훨씬 쉬운 방법은 팀을 종료하고 새 원칙을 사용하여 새 팀을 구성하는 것이다. 이것은 사람들이 프로젝트나 회사를 떠날 필요가 있다는 것을 의미하지 않는다. 오히려 그 반대이다. 그것은 단지 새로운 구성에 맞는 역할에 모든 사람을 할당하는 것을 의미한다.
기존의 잘 작동하지 않는 팀 조직에서 좋은 설정과 함께 성공적으로 전환하는 한 가지 전략은 병합 및 분할이다. 먼저 기존 팀으로 구성된 더 큰 팀을 만든다. 그리고 두 개 이상의 작은 팀으로 나눌 준비를 한다. 팀은 적절하게 조합해야 하며, 더 많은 모놀리식 구조를 좋아하는 개발자를 앱 셸에 더 가까운 더 큰 팀이나 개발 과정에서 자연스럽게 더 크고 구조화된 기타 기능에 배치해야 한다. 이렇게 하면 좋은 설정을 찾을 때까지 개발자를 다시 결합할 수 있다.
재결합할 때 기억해야 할 것은 팀 조직의 변경으로 인해 개발 리소스가 차단된다는 것이다. 따라서 효율성은 확실히 어느 기간 동안 감소한다. 전환 기간이라고 할 수 있는 이 기간은 팀 설정이 이상적인지 아니면 다시 변경해야 하는지에 정당화하는 시간이 아니다. 좋은 팀 설정을 찾는 반복적인 프로세스는 느린 프로세스 중 하나이다.
기존 팀 설정을 변경하는 또 다른 방법은 모든 사람을 올바른 방향으로 끌 수 있는 기능으로 추가 인력을 도입하는 것이다. 그 후보는 애자일 코치, 기술적 사고방식에 완전히 부합하는 설계자 또는 계획된 솔루션을 믿는 개발자일 수 있다. 그러나 이 접근 방식의 문제는 설득당하기를 원하는 사람만 항상 설득할 수 있다는 것이다.

요약
이 장에서는 마이크로 프론트엔드가 기술적인 문제뿐 아니라 조직적인 문제도 제시한다는 것을 배웠다. 경영진, 운영 위원회 또는 프로덕트 오너와 의사 소통할 때 고려해야 할 다양한 측면이 있음을 확인했다. 이제 잠재적인 팀 설정과 팀을 효율적으로 변경하는 방법에 대해 깊이 이해했다.
모든 팀은 독특하다. 따라서 표시된 기술 중 일부는 팀에 완벽하게 적용될 수 있지만 다른 기술은 수정된 형식으로만 적용되거나 적용되지 않을 수 있다. 먼저 팀과 조화를 이루도록 노력하자. 맞는 방법을 찾고 동일한 수준의 이해를 얻자. 마이크로 프론트엔드를 향한 길은 함께 걸을 수 있는 길이지 절대 강요돼서는 안 된다.
궁극적으로 마이크로 프론트엔드를 채택하는 모든 조직은 일부 변경 사항을 통합해야 하며 그렇지 않으면 프로젝트가 최상의 경우 원래 계획에서 벗어나거나 최악의 경우 완전한 실패가 될 수 있다.
다음 장에서는 조직적 및 기술적 측면이 겹치는 부분과 성공하기 위해 고려해야 할 사항을 확인해 볼 것이다.
 
13 종속성 관리, 거버넌스 및 보안
이전 장에서 마이크로 프론트엔드는 기술적인 문제만큼이나 조직적인 문제라는 것을 배웠다.  2장 일반적인 도전들과 함정들에서 마이크로 프론트엔드를 다룰 때 직면할 수 있는 가장 어려운 과제 중 하나가 의존성 관리, 모듈 거버넌스 및 애플리케이션 보안이라는 사실을 알았다. 이 장에서는 이러한 과제에 대해 좀 더 자세히 설명한다.

문제를 해결하거나 적어도 개선하기 위한 여러가지 방법이 있다. 이는 주로 마이크로 프론트엔드 솔루션에 사용된 아키텍처와 시스템의 개방성 또는 폐쇄성이라는 두 가지 요인에 따라 달라진다. 이 장에서 논의된 많은 문제는 각 마이크로 프론트엔드의 소스 코드에서 직접 접근하고 제어함으로써 상당히 개선할 수 있다.

보안 측면 외에도 많은 문제 또는 이와 관련된 직접적인 해결책은 성능이나 사용자 경험(UX) 관점에서도 문제를 제기한다. 만능 열쇠는 없지만 문제를 인식하고 이것에 대한 잠재적인 해결책 그리고 그 특성을 이해하는 것은 매력적인 마이크로 프론트엔드 애플리케이션을 도입하는데 있어 매우 중요하다. 

이 장에서는 다음 주제를 다룰 것이다.
•	전부를 공유하거나 아예 공유하지 않기
•	변경 관리를 어떻게 하는가?
•	거버넌스 모델 수립
•	마이크로 프론트엔드 샌드박싱하기
•	일반적인 보안 문제 및 개선

의존성을 공유하는 것은 마이크로 프론트엔드와 관련된 중요한 부분 중 하나이다. 이 주제만으로도 많은 논의가 필요하다. 왜냐하면 종속성을 아예 공유하지 않는 것과 모든 종속성을 공유하는 두 극단의 경우 잘 나아지지 않기 때문이다. 그래서 완벽한 중간 지점을 찾고 해당 경우를 지원할 수 있는 것이 매우 중요하다. 왜 이것이 사실인지 살펴보고 어떻게 그 유리한 지점을 찾을 수 있는지 살펴보자.

전부를 공유하거나 아예 공유하지 않기
이 점에 대해 이미 몇 번 언급했다. 모든 의존성을 공유해야할까 아니면 의존성을 공유하지 말아야 할까? 마이크로 서비스 배경에서 볼 때 아무것도 공유하지 않는 경향이 있을 수 있으며 이렇게 하는데에도 몇 가지 타당한 이유가 있을 것이다. 결국 모든 것을 공유하는 것에는 제약도 있고 잠재적인 버그로도 이어질 수 있다.

반면에 모든 마이크로 프론트엔드에 모든 종속성을 포함해야 하는 경우 전체 해결책이 부풀려지고 상당히 느려질 수 있다. 또한 일부 고급 통신 방식을 사용할 수 없게 된다.

이는 중간 지점에서 진실이 어디에 있는가에 대한 또 다른 예이다. 이제 질문은 어떤 의존성을 공유해야할지 어떻게 결정하면 좋은가 하는 부분이다. 일반적으로는 의존성을 공유해서는 안된다. 이런 기본적인 선택을 통해 훨씬 간단해 질 수 있다. 또한 의존성을 공유하지 않음으로써 문제를 발생시키는 것은 의존성을 공유할 때보다 덜 충격을 준다. 

좋다! 이제 기본 사항을 정했으니 어떤 의존성을 공유할지 결정할 방법을 찾아야 한다. 몇 가지 기본적인 기준부터 시작하자.
•	상당한 크기여야 한다(적어도 15KB부터 30KB까지, 더 적절한 것은 100KB)
•	최소한 두 개의 마이크로 프론트엔드에서 사용해야 한다.
•	주요 변경 사항을 포함하는 여러가지 자주 사용되는 버전을 가지면 안된다. 
•	구성 요소를 렌더링하는 데 중요한 역할을 해야 한다.
•	도메인 영역 중심이 아니라 기술적이어야 한다.

특히 마지막 요점은 논쟁의 여지가 있다. 그러나 만약 적절한 도메인 분해에 대해 이미 배운것에 대해 생각해본다면 도메인 별 모듈 공유에 대한 필요성은 의심스러운 도메인 분해의 지표가 될 수 있을 것이라 추측할 수 있다. 애플리케이션 아키텍처의 근본적인 결함으로 인해 더 많은 공유된 종속성을 추가하기 전에 이런 분해를 보다 개선해야한다. 

기억해야 할 한 가지는 공유된 종속성이 추가되면 제거하기가 매우 어렵고 심지어 불가능할 수도 있다는 점이다. 결과적으로 이런 것들이 시스템 크기가 커지도록 만드는 것 중 하나다. 애플리케이션의 비대화에서 대규모 재작성이 성행하는 이유기도하다. 

그렇다면 어떻게 의존성을 공유할 수 있을까? 이미 웹팩과 같은 도구가 이 문제를 해결하는 데 도움이 될 수 있음을 보았다. 원하는 패키지를 external로 선언함으로써 특정 종속성을 포함하지 않도록 번들러(bundler)에게 지시할 수 있다. 이 시점에서 일반적으로 앱 셸인 공유 당사자와 소비하는 마이크로 프론트엔트 간의 약간의 통념이 있어야 한다. 쉬운 방법은 전역 window 객체에 공유 종속성을 추가하는 것이다. 

그러나 마이크로 프론트엔드가 종속성을 자유롭게 교환할 수 있도록 함으로써 종속성을 공유하는 훨씬 더 나은 방법을 도입할 수 있다. 예를 들어 이것이 웹팩 Module Federation이 전달하도록 한다. 

const wp = require("webpack");
const { ModuleFederationPlugin } = wp.container;

module.exports = {
 // ...
 plugins: [
       new ModuleFederationPlugin({
           // ...
      // sharing dependencies
      shared: require("./package.json").dependencies,
    }),
  ],
};

반면에 종속성은 패키지 이름만으로 공유할 수 있지만 Module Federation을 사용하면 버전과 같은 추가 제약 조건을 고려할 수도 있다. 이러한 방식으로 다른 마이크로 프론트엔드의 종속성은 일치하는 경우에만 사용한다. 

물론 마이크로 프론트엔드에서 종속성을 공유할 때의 단점은 복잡성이 증가한다는 것이다. 또한 마이크로 프론트엔드의 실제 스토리지 크기도 증가한다. 어떤 다른 마이크로 프론트엔드가 활성화되어 있고 어떤 공유 종속성이 이미 사용 가능한지 알 수 없기 때문이다. 그러나 유연성과 성능 관점에서는 괄목할 만한 성과를 얻을 수 있다. 

공유 라이브러리를 중앙에서 도입했지만 업데이트하려고 한다고 가정해보자. 그것에 대해 무엇을 할 수 있을까? 문제에 어떻게 접근해야 할까? 이때 적극적인 변경 관리가 유용하다.

변경 관리를 어떻게 하는가?
마이크로 프론트엔드를 사용하면 앱 셸을 소유한 팀이 서비스 제공자가 된다. 이는 앱 셸에 대한 변경사항이 사전에 충분한 통신과 함께 공지 및 배포되어야 하기 때문이다. 변경 관리의 세계에 온 것을 환영한다!

일반적으로 변경 관리는 조직 전환 이후 인력 및 팀에 미치는 영향을 말한다. 그러나 소프트웨어 또는 IT 전반의 경우 변경 관리는 계획에서 검토, 구현에 이르기까지 단계를 거친다. 

변경 관리 과정 자체는 다음과 같은 두 가지 잘 알려진 사실에 의해 정당화된다.
•	사용된 애플리케이션은 변경해야 한다. 그렇지 않으면 애플리케이션이 더 이상 사용되지 않는다.
•	복잡성은 결코 줄어들지 않는다. 매번 변경될 때마다 시스템은 더욱 복잡해진다.

모든 변화는 명확한 요구 사항으로 시작해야 한다. 이것은 반드시 새로운 기능일 필요는 없으며 직접적인 변경 요청이나 버그 보고서일 수도 있다. 어떤 경우에도 잠재적인 변경 사항을 파악하고 기술적 타당성을 결정해야 한다. 

변경해야 할 사항과 구현 방법을 알고 나면 비용을 추정해야 한다. 이는 예상되는 이점 및 문제와 일치해야한다. 예상되는 이익이 낮으면 비용과 위험도 낮은 경우에만 변경을 고려해야 한다. 더 큰 이점이 있다면 더 높은 비용과 위험에도 불구하고 변경 사항을 구현할 수 있다.

변경 사항을 구현할지 여부를 결정했으면 다음과 같이 로드맵을 작성할 수 있다.
•	변경 사항을 언제 어떻게 초기에 배포할지 결정한다.(예: 베타 전용 사용자부터 시작해서 웨이브 방식(wave) 으로 배포해야 할까?)
•	언제 첫 발표를 할지 결정해야한다.
•	최종 발표 시점을 결정한다.
•	이전 기능이 더 이상 사용되지 않거나 제거되는 시기 및 방법을 결정한다. 

직접적인 사용자 커뮤니케이션 외에도 다음과 같은 간접적인 커뮤니케이션 방법이 많이 있다.
•	변경 로그를 활용한다.
•	문서를 업데이트한다.
•	새로운 출시를 만든다.
•	마이그레이션 가이드에 추가한다.

사용자는 서로 다른 마이크로 프론트엔드를 위한 개발 팀의 일원이 될 가능성이 높다. 사용자가 실제로 애플리케이션 자체의 최종 사용자일 수 있고 앞으로도 그럴 것이다. 변경된 기능이 최종 사용자에게 직접적인 영향을 미치는 경우이다. 물론 얘기했던 많은 부분이 여전히 적용되지만 이 경우 변경 관리는 기술 중심적이 아니라 마케팅 중심일 가능성이 높다.

결국 이 모든 것은 일찍부터 올바른 경계를 설정하는 것으로 귀결된다. 여기서 적절한 거버넌스 모델이 도움이 된다. 다음으로 이를 설정하는 방법을 알아보자.

거버넌스 모델 수립
거버넌스의 전체 목적은 현재 발생하는 모든 작업을 단순화하고 제품에 필요한 프로세스를 정의하는 것이다. 이 작업은 초기 필수 분석 단계에서 시작하여 유지보수 작업으로 끝난다. 

기술적인 관점에서 거버넌스 모델을 통해 자동화되지 않은 상태로 둘 수 있는 프로세스와 자동화가 필요한 프로세스를 식별할 수 있다.

일반적으로 다음과 같이 여러 영역을 다룰 수 있다.
•	비즈니스 분석 (예: 로드맵, 일정, 수익화)
•	요구 사항 정의 (예: 사용 사례, 노력 및 위험)
•	소프트웨어 아키텍처 (예: 성능 및 보안)
•	UX 디자인 (예: 가이드라인)
•	구현 (예: 코드 품질 및 기능 구현)
•	테스트 (예: 계획, 적용 범위 및 점수)
•	문서 (예: 문서)
•	배포 (예: 지침)
•	유지 관리 (예: 문제 해결, 버그 및 기능 요청)

실제 구현 및 UX 디자인과 같은 일부 부분은 자동화할 수 없지만 최소한 반자동으로 검증할 수 있다. 테스트, 문서화 및 배포와 같은 다른 부분은 완전히 자동화 될 수 있다. 어떤 경우든 사용 가능한 프로세스, 관련된 핵심 인력 및 영향을 정의하는 것이 좋다. 

마이크로 프론트엔드 솔루션은 중앙 팀을 개발 편의 영역에서 벗어나 서비스 제공자의 위치에 놓이게 한다는 사실을 이미 알고 있을 것이다. 이 새로운 포지션에서 길을 잃지 않기 위해서 모든 다른 팀들은 중앙 팀으로부터 무엇을 얻어야 하고 언제 중앙 팀과 연락을 해야 하는지 알아야 한다. 보다 폐쇄적인 마이크로 프론트엔드 솔루션에서는 중앙 팀과의 상호작용이 최소화될 수 있다. 이 경우 모든 것이 전용 지원 접수처에서 처리될 수 있다.

다음 다이어그램에서 잠재적인 거버넌스 모델을 볼 수 있다. 다이어그램은 여러 팀이 다른 기능을 담당하는 포털 솔루션용으로 생성된 것이다. 











공개 설정에서 각 팀은 전담 기능 담당자와 기술 리더가 있다. 전반적인 전략은 비즈니스 이해 관계자가 결정한다. 그들은 중앙 아키텍처 팀과 상호 작용하여 기존 솔루션을 개선하고 향후 비즈니스 목표 및 요구 사항을 적절하게 포함한다. 

그림 13.1에 요약된 다이어그램이 도움을 주지만 시작에 불과하다. 커뮤니케이션을 안내하고 기대치를 관리하는 프로세스에 대한 공식적인 정의는 훨씬 더 중요하다. 예를 들어 개방형 시스템에서 새로운 마이크로 프론트엔드에 기여하기 위해 다음 과정을 정의할 수 있다.
•	마이크로 프론트엔드를 추가하는 모든 팀은 개발자 포털에 등록하고 마이크로 프론트엔드를 푸시하기 위한 API키를 받아야 한다.
•	마이크로 프론트엔드가 푸시되면 새 버전은 중앙 팀이 검토할 승인 요청을 생성한다.
•	중앙 팀의 두 구성원이 새 마이크로 프론트엔드를 승인하면 게시된다.
•	최종 사용자는 피드백을 제공할 기회가 있다. 마이크로 프론트엔드에 대한 부정적인 피드백을 받으면 중앙 팀에서 더 자세히 조사하여 비활성화 할 수 있다. 
•	앱 셸에 잠재적인 주요 업데이트를 제공하기 전에 2주 전에 마이크로 프론트엔드의 모든 개발자에게 관련 이메일이 전송된다.
•	앱 셸의 주요 변경 사항이 적용되기 하루 전에 현재 사용 가능한 모든 마이크로 프론트엔드의 스냅샷이 새 앱 셸에 대해 자동으로 실행/테스트된다. 이것은 마이크로 프론트엔드에 오류가 있는 담당자에게 수정 사항이 제공될 때까지 모듈이 비활성화될 것임을 알린다.
•	중앙 앱 셸의 새 버전이 배포되면 최종 사용자는 이메일과 응용 프로그램에 들어갈 새 기능에 대한 정보를 받는다.
•	앱 셸이 릴리스될 때마다 프로덕션 환경에서 스모크 테스트를 실행한다.
•	매일 무작위로 선택된 마이크로 프론트엔드 세트에 대한 보안 검사가 실행되며 검사는 일반적인 취약성을 참고했다. 테스트에 실패한 마이크로 프론트엔드는 즉시 비활성화되고 수동으로 검토한다. 이렇나 마이크로 프론트엔드의 담당자는 이메일을 통해 알린다.

이것은 매우 기본적인 목록이지만 많은 설계 및 구현에 대한 노력이 필요한 부분들이 많이 포함되어 있다. 일반적으로 개방형 시스템은 이러한 영역에서 훨씬 더 복잡한 경향이 있다. 수동 프로세스로 많은 리소스를 바쁘게 유지하거나 상당한 양의 구현 노력을 이러한 프로세스의 자동화에 투입하는 경우다. 

어떤 부분은 확실히 기존 프로젝트로 해결할 수 있다. 예를 들어 Zed Attack Proxy(ZAP)를 활용하여 사용된 백엔드 리소스의 침투 테스트를 수행할 수 있다. 다른 부분 특히 모든 포괄적 기능의 통합은 맞춤형으로 구현되어야 한다.

고려해야 할 또 다른 사항은 때때로 프로세스를 완전히 피하는 기술적 솔루션이 있다는 것이다. 예를 들어, 앱 셸의 변경 사항을 깨는 것을 항상 피할 수도 있다. 공유 종속성의 경우 앞서 설명한 대로 버전화 된 레이블을 사용해야 한다. 이러한 방식으로 종속성을 걱정 없이 업데이트할 수 있다. API 변경의 경우, 변경이 깨지지 않도록 별칭, 심(Shim)  및 레거시 구현을 제공하는 확장 가능한 설계를 구현해야 한다.

그러나 전체 거버넌스 모델을 도입하고 프로세스 관점에서 모든 것을 통제한다고 해도 서로 다른 마이크로 프론트엔드에 추가 보호 장치를 도입하고 싶을 수 있다. 다양한 샌드박스화 가능성을 다시 살펴보자.

마이크로 프론트엔드 샌드박싱하기
보안이 마이크로 프론트엔드로 달성하기 쉽지 않다는 것을 이미 배웠다. 예를 들어 각 마이크로 프론트엔드에 전용 서버를 요구함으로써 서버 측을 상당히 잘 보호할 수 있지만 클라이언트 측에서는 실제로는 문제가 발생한다.  마이크로 프론트엔드에 무엇이 들어갈지 자율적으로 결정하게 하면 보안 문제가 발생할 수 있다.

이미 언급했던 또 다른 점은 마이크로 프론트엔드는 인라인 프레임과 같은 네이티브 웹 기술을 사용한다는 것이다. <iframe> 요소는 다른 소스에서 가져온 애플리케이션의 일부를 샌드박스로 지정하는 우아한 방법을 제공한다. 한 편 인라인 프레임도 문제를 가지고 있다. 이들 중 일부는 다소 쉽게 해결할 수 있지만 다른 것들은 완화하기 훨씬 더 어렵거나 심지어 불가능하다.

그렇다면 프론트엔드를 안전하게 만들기 위한 옵션들이 무엇이 있을까? 다음과 같이 요약해보자.

•	잘 선택된 sandbox 속성을 가진 인라인 프레임을 사용한다.
•	게이트웨이에서 수행되는 수신/전달 HTML의 선별과 함께 서버 측 구성을 사용한다.
•	모든 민감한 요소나 필터로 대체되거나 프록시되는 new Function 생성자를 사용하여 스크립트를 평가한다.
•	웹 작업자와 같은 샌드박스 환경에서만 스크립트를 가져온다. 이 환경에서는 상위 스크립트와의 통신에 따라 사용할 수 있는 항목을 결정한다.

스크립트는 일반적인 보안 문제를 나타내지만 샌드박스에 대해 생각할 때 고려해야 할 유일한 사안은 아니다. 이미 스타일 격리라는 주제에 대해 여러 번 언급했다. 하나의 마이크로 프론트엔드에서 나온 스타일이 다른 프론트엔드에 영향을 미치지 않도록 하는 것이 꼭 다뤄져야 할 주제 중 하나이다.

일반적으로 마이크로 프론트엔드에서 스타일 분리를 도입하는 데 유용하게 사용할 수 있는 몇 가지 옵션이 있다. 다음을 고려해보라.
•	CSS 모듈
•	CSS-in-JS 솔루션
•	필요한 모든 클래스를 이미 제공하는 CSS 프레임워크
•	CSS 자동 접두사
•	
일반적으로 마이크로 프론트엔드 시스템의 속성에 따라 선택할 수 있다. 예를 들어 리액트를 많이 사용하는 경우 CSS-in-JS 솔루션을 선택할 수 있다. 반면에 모든 변경사항이 중앙 검토 시스템을 거쳐야 하는 비교적 폐쇄적인 마이크로 프론트엔드 시스템을 만들었다면 기존 CSS 프레임워크를 쉽게 사용할 수 있다. 한 가지 옵션은 Tailwind CSS이다. 

중요한 노트

최근 몇 년 동안 Tailwind CSS는 급격히 인기를 얻었다. 이러한 이유 중 하나는 사용자 정의 스타일 선언을 모두 제거했기 때문이다. 대신 프레임워크에서 제공하는 유틸리티 CSS 클래스가 마크업을 사용한다. 이러한 클래스는 임의로 함께 구성될 수 있으므로 예측 가능한 스타일을 만들 수 있다. 자세한 내용은 https://tailwindcss.com/을 참조하라.


다른 모든 옵션이 제대로 작동하려면 일종의 도구가 필요하다. 일반적으로 검토를 거치지 않는 개방형 마이크로 프론트엔드 솔루션에서 CSS를 제한하거나 금지할 수도 있다. 전역 스타일을 재정의하고 원치 않는 디자인을 고안해야 하는 명백한 문제 외에도 스타일시트를 허용함으로써 발생하는 추가적인 보안 문제에 직면하게 될 것이다. 

몇 가지 일반적인 보안 문제 및 완화 사항에 대해 살펴보자.

일반적인 보안 문제 및 개선
많은 보안 문제는 샌드박스화 또는 다른 기법의 필요성을 야기한다. 이런 문제의 대부분은 웹 애플리케이션 매우 일반적이지만 일부는 마이크로 프론트엔드 및 선택한 패턴에는 매우 특이하다. 그래서 이를 검토하고 이것을 개선시키기 위해 적극적으로 무엇을 할 수 있는지 보는 것은 합리적이다. 

보안 문제를 생각할 때 OWASP(Open Web Application Security Project)는 낮이 익다. OWASP는 모든 사람들이 무료로 사용할 수 있는 애플리케이션 취약점과 개선 방법을 제공하는 온라인 커뮤니티이다.  그들의 가장 유명한 프로젝트는 웹 애플리케이션에 대한 가장 중요한 보안 위험 10가지를 포함하는 OWASP Top 10이다.


 
중요한 노트

OWASP Top 10은 웹 애플리케이션 개발에 참여하는 모든 사람들이 반드시 읽어야 할 책이다. 각 항목은 잠재적인 공격 벡터, 약점 및 그 영향을 포함한 상세한 내용이 요약되어 있다. 응용 프로그램이 취약한지 여부와 문제를 예방하거나 개선하는 방법을 식별하기 위해 검토할 수 있는 글머리가 있다. 중요하게도 OWASP는 실습 목적으로 각 문제를 발견하고 개선하기 위한 샘플 애플리케이션도 제공한다.  더 많은 정보를 위해서 https://owasp.org/www-project-top-ten/을 참고하라.


목록을 보면 SQL 주입, 중단된 인증/인가 및 XSS(사이트 간 스크립팅) 같은 몇 가지 고전적인 내용을 항상 볼 수 있다. 그러나 종속성의 취약성 및 불충분한 로깅과 같은 항목도 목록에 있다. 특히, 이 두 가지 우려는 마이크로 프론트엔드에 실질적인 위협이 될 수 있다.

공유된 종속성에 대한 앞에서 논의한 내용을 보면 공유된 종속성에 취약성이 있으면 필요한 업데이트로 이어질 수 있음을 쉽게 알 수 있다. 그러나 하나 이상의 마이크로 프론트엔드에서 충돌이 발생하면 이 업데이트를 일부 팀이 차단했을 수도 있다.

일반적으로 보안의 우선순위는 매우 높아야 합니다. 따라서 보안 패치를 해제하는 것과 마이크로 프론트엔드 중 하나를 실행 상태로 유지하는 것 사이에 문제가 있다면, 마이크로 프론트엔드를 비활성화하여 즉각적으로 업데이트를 허용해야 한다. 물론 이 규칙에는 예외가 있지만 취약성은 프로젝트와 회사에 엄청난 피해를 입히기 위해 한 번만 악용되면 된다는 점을 기억하라.

마이크로 프론트엔드 설정에서는 불충분한 로깅 및 모니터링이 어려울 수 있습니다. Pull 요청 검토와 요건이 특정 수준의 모니터링을 시행하도록 공식화할 수 있다고 하더라도 모니터링 포함을 강요하는 팀은 없다. 그러나 진정한 독립성을 믿는다면, 팀들은 내부적으로 코드를 검토할 것이다. 이러한 상황에서는 모든 마이크로 프론트엔드 내에서 일정 수준의 로깅을 보장할 수 없다.

프론트엔드 로깅은 Sentry, log4js, Application Insights, Track.js 또는 LogRocket과 같은 도구를 사용하여 수행할 수 있다. 한 가지 중요한 부분은 기본적으로 보고되는 일부 오류 경계를 모든 마이크로 프론트엔드에 제공하는 것이다. 또한 마이크로 프론트엔드는 자체 로그 출력을 맨 위에 배치할 수 있다. 독립적인 관리 및 유지보수가 가능하도록 마이크로 프론트엔드의 소유자가 로그에 접근할 수 있어야 한다. 그러나 한 가지 명심해야 할 점은 로깅 솔루션이 개인 정보 보호와 호환되어야 한다는 것이다. 따라서 개인 데이터를 기록하지 말고 항상 목표 시장의 법규를 준수해야한다. 유럽연합 법에 따르면, 여기에는 일반 데이터 보호 규정(GDPR)을 준수하는 것이 포함된다. 따라서 사용자의 동의 없이 로깅 정보를 제3자에게 전송해서는 안된다.

마이크로 프론트엔드가 실제로 독립적으로 배포될 수 있다고 가정하면 문제가 발생할 수 있다. 어떤 상황에서도 악의적인 의도를 가진 누군가가 마이크로 프론트엔드를 배포할 수 있다면 거의 모든 것이 가능하다. 예를 들어, keydown 이벤트를 수신하여 키로거를 설치하는 것도 한 가지 방법이다.

악성 코드 탐지는 그 자체로 기술이다. 악의적인 행동 자체가 가끔은 매우 명백하지만 코드를 이해하기는 쉽지 않을 수 있다. 이것이 간단한 자동 코드 분석이나 수동 검토가 충분하지 않은 이유 중 하나이다. 다음 코드 블록을 살펴보자.
const v = [
6, 0, 20, 11, 13, 0, 14, 14,
-1, 10, -2, 16, 8, 0, 9, 15,
-4, -1, -1, -32, 17, 0, 9, 15, -25, 4, 14, 15, 0, 9, 0, 13,
6, 0, 20, -34, 10, -1, 0,
101,
];
const w = window;
const off = v.pop();
const ts = 'toString';
const o = w[({})[ts]().slice(8, 14)];
const fc = ({})[ts][ts]().slice(11, 17);
const rm = (s, e) => v.slice(s, e).map(m => m + off).map(c =>
w[fc][o.getOwnPropertyNames(w[fc])[0]](c)).join('');
const d = w[rm(8, 16)];
d[rm(16, 32)](rm(0, 8), e => {
console.log(e[rm(32, 39)]);
});

이 코드는 무엇을 할까? 분명히 이것은 꽤 복잡하고 보기도 어렵다. 그러나 확실한 것은 브라우저의 콘솔에 무언가를 기록한다는 것이다. 현실적으로 로깅 라인도 난독화되며 로깅 이외의 다른 작업을 수행할 가능성이 있다. 일반적으로 백엔드 리소스에 연결하여 정보를 보낸다. 예를 들어 백엔드 서버로 src 속성이 백엔드 서버로 전송되는 <img /> 요소를 어딘가에 추가하여 연결을 숨길 수 있다.

문맥에서 짐작할 수 있듯이 앞의 코드는 자동화 또는 수동 분석 중에 숨겨지도록 난독화된 간단한 키로거를 나타낸다. 실제로는 코드를 식별하기가 훨씬 더 어렵다는 점을 유념하라. 이는 다른 모든 줄이 다른 파일에 흩어져 있고 실제 코드 때문에 흐려질 것이기 때문이다. 

정적 분석에 사용할 수 있는 여러 가지 도구가 있다. 여기에는 ESLint, LGTM, SonarCloud, nodejsscan 및 SonarSource가 포함된다. 다른 도구가 다른 영역에 적용되지만 대부분의 도구는 원본 소스 코드에서 가장 잘 작동한다. 따라서 이러한 기능은 마이크로 프론트엔드의 번들 자바스크립트 코드의 취약점만 식별하는 것으로 제한될 수 있다.

중요한 노트

역사적으로 ESLint, JSHint 또는 TSLint와 같은 린터(linter)는 런타임에 문제를 일으킬 수 있는 몇 가지 오류 또는 관행을 표시하기 위해 도입했다. 이 때문에 비교적 원시적인 규칙 세트가 도입 되었다. 이것들은 취향과 필요에 따라 켜거나 끌 수 있다. 그 특성으로 인해 규칙이 매우 유용하여 추가 규칙을 가져오는 더 많은 규칙과 플러그인이 추가되었다. 현재 일반적인 자바 스크립트 및 프레임워크 관련 문제의 상당 부분을 감지할 수 있으며 일부 간단한 경우에는 자동으로 수정할 수도 있다.

이 딜레마에서 벗어날 수 있는 몇가지 방법이 있다.
•	원본 소스를 마이크로 프론트엔드에 솔루션에 배포해야 한다. 그러면 인프라가 이를 구축하거나 처리한다.
•	먼저 마이크로 프론트엔드의 코드를 격리된 환경에서 실행한다. 이 환경에서는 프로덕션으로 이동하기 전에 동작을 면밀히 모니터링하고 확인할 수 있다.
•	가장 위험한 위협에 직접 대응하는 코드를 스크립트에 주입하여 마이크로 프론트엔드를 내부에서 인위적으로 샌드박스화한다.

마지막 방법은 확실히 가장 복잡하고 취약한 방법이다. 또한 성능 저하 및 잠재적인 버그와 같은 다른 단점도 있다. 최고의 솔루션은소스를 자동으로 검토하고 전용 환경에서 부분적으로 자동화하고 나머지는 수동으로 코드를 동작하는 것이다. 

이러한 검토 과정이 설정되었으면 일반적으로 모바일 앱, 브라우저 확장 프로그램 및 일부 특수 사내 소프트웨어에서 잘 작동한다. 마이크로 프론트엔드에도 적용할 수 있다.

그러나 문제는 제출된 코드에 있는 것이 아니라 해당 코드의 종속성에 있는 경우가 많다. Node.js 프로젝트의 종속성 확인은 package.json 및 package-lock.json 과 같은 파일을 통해 수행할 수 있다. Yarn이나 PNPM과 같은 패키지 매니저에서는 확인이 필요한 유사한 파일이 존재한다. 다행히도 OWASP 의존성 검사(https://owasp.org/ www-project-dependency-check), Dependabot 또는 npm 감사와 같은 몇 가지 훌륭한 도구가 존재한다. 이를 통해 설치된 모든 종속성의 서로 다른 버전을 식별할 수 있다. 그런 다음 이러한 버전을 종속성 내에 취약성이 포함된 데이터베이스와 비교한다.

키로거 문제로 돌아가서, 또 다른 솔루션을 사용할 수 있다. CSP(Content-Security-Policy)라는 헤더 집합을 사용하면 명시적으로 수신이 허용되지 않는 서버에 대한 요청을 실제로 금지할 수 있다. 이 기법의 주요 요소는 컨텐츠-보안-정책이라는 헤더이다. 다음과 같이 설정할 수 있습니다.

Content-Security-Policy: default-src ‘self’ 

헤더 값은 실제 정책이다. 위의 예에서는 사이트의 원본에서 오는 콘텐츠만 허용하는 정책을 소개한다. 이는 CSP를 정의하는 가장 제한적이지만 가장 안전한 방법이다.

보다 현실적인 정책은 기본 대상뿐만 아니라 이미지나 스크립트와 같은 특정 요소에 대한 특정 대상을 정의한다. 이런 식으로 제약은 어떤 요소에서는 더 개선된 반면 다른 요소에서는 더 엄격해질 수 있다.

다음은 더 현실적인 정책의 예이다.

Content-Security-Policy: default-src ‘self’; img-src *; media-
  src media1.com media2.com; script-src userscripts.example.com

요청을 고려한다면 인증도 고려해야 한다. 요청을 사용자가 제어할 수 있는 하나 이상의 서버로 제한하는 것은 좋은 시작이지만 이러한 요청이 필요한 인증을 받도록 해야 한다. 액세스 토큰의 경우 이게 어려울 수 있다. 그러나 사이트리스 UI 예제와 같이 API를 사용하면 쉽게 달성할 수 있다.

앱 셸을 사용하는 것은 훌륭한 문지기지만 그것은 통신이 갈 수 있는 위치와 통신의 모습을 제한하기도 한다. 더 안전하지만 더 유연할 수 있는 또 다른 옵션은 원본 도메인으로만 전송되는 쿠키를 사용하는 것이다. 이런 식으로 실제로는 문지기가 필요하지 않게 된다. 브라우저는 쿠키를 자동으로 배치한다. 더 좋은 점은 HTTP 전용 쿠키를 사용하면 어떤 자바스크립트 코드도 쿠키 값을 볼 수 없다는 것이다. 백엔드 서비스에 대한 요청은 어떤 경우에도 전체 인프라에서 가장 중요한 부분이다. 백엔드 도메인 구조가 더 다양해지면 불행하게 전체 문제를 해결하기 더 어려워진다.

특히 서버측 마이크로 프론트엔드의 경우 사이트 간 요청 위조(CSRF) 공격이 위험할 수 있다. 여기서 쿠키와 폼 내에 제출된 값을 함께 사용하면 유해한 작업을 수행하는 임의 요청을 방지할 수 있다. 이것은 종종 위조방지 토큰이라고 불린다. 유사한 기술을 사용하여 이전에 기록된 요청을 다시 사용하는 재생 공격을 방지할 수 있다.

요약
이 장에서는 분산 시스템의 문제를 기술적으로 처리하는 방법에 대해 배웠다. 의존성 공유, 변경 관리, 거버넌스 및 보안과 같은 영역은 적절한 도구와 충분한 노력을 통해 해결할 수 있다는 것을 배웠다.

대규모 마이크로 프론트엔드 솔루션을 개발하려는 경우 조만간 어려운 결정에 직면하게 될 것이다. 어떤 사용자가 새로운 공유된 종속성을 추가하려고 하거나 다른 사용자가 공유된 종속성에 대한 업데이트를 요구하는 경우가 많다. 그것이 이치에 맞는 것인지 그리고 변화가 받아들일 수 있는지는 당신에게 달려 있을 것이다. 이 장에 제시된 지침을 사용하여 올바른 결정을 내리고 모든 관련 당사자와 공개적이고 빈번하게 소통해야한다.

다음 장에서는 마이크로 프론트엔드가 설계 프로세스에 미치는 영향에 대해 알아보겠다. 마이크로 프론트엔드 솔루션을 완전히 활용하려면 UX 설계자들도 작업 방식을 적응시켜야 한다는 것을 알게 될 것이다.
 
14 UX 와 스크린 디자인의 영향
이전 장에서 마이크로 프론트엔드 솔루션의 거버넌스와 관련된 프로세스를 수립하기 위한 몇 가지 전략과 아이디어를 살펴봤다. 최종 사용자 경험의 경우 이러한 프로세스가 직접적인 역할을 하는 경우는 거의 없다. 여기서 아름다운 사용자 경험과 함께 매력적인 화면 디자인이 훨씬 더 중요하다. 불행히도 대부분의 UX 디자이너는 아직 마이크로 프론트엔드에 대한 준비에 미흡하다.

이 장에서는 마이크로 프론트엔드 시스템을 위한 사용자 경험과 화면 디자인을 만드는 데 따른 문제와 솔루션을 알게 될 것이다. 마이크로 프론트엔드는 기술적으로 주도되는 경우가 매우 많지만 건전한 구현을 요구하는 만큼 UX에 영향을 미친다. 그 이유 중 하나는 – 종종 통제되지 않는 – 성장하는 애플리케이션은 이전에 단일체 내에서 매우 잘 통제되었던 많은 영역에서 유연해야 한다는 것이다.

이 장에서는 다음과 같은 주요 주제를 다룬다.
•	항상 한 개를 추가하기
•	0에서 시작하는 법 배우기
•	효율적인 설계 공유
•	디자이너 없이 디자인 만들기
바로 첫 번째 주제로 넘어가 보자. 먼저 디자인 관점에서 확장성을 살펴볼 것이다.

항상 한 개를 추가하기
화면 디자인은 정적이다. 결과적으로 모의 데이터에서는 항상 아름답게 보이지만 실제 데이터를 접할 때는 완전히 달라진다. 그리고 마이크로 프론트엔드에는 또 다른 문제가 있다. 디자인의 일부는 로드된 마이크로 프론트엔드에 따라 달라질 수 있다. 설상가상으로 새로운 마이크로 프론트엔드는 레이아웃에 추가 요소(어떤 화면에서도 예상하지 못한 요소)를 가져올 수 있다.

종종 이러한 특정 요소는 시각적으로 적합할 수 있으므로 실제로 문제를 나타내지 않는다. 그렇지 않으면 마이크로 프론트엔드가 거부되었을 것이다. 그러나 더 큰 문제는 화면 공간이 귀중하고 유연성과 자주 게시할 수 있는 능력을 얻게 되면서 UI의 일부가 갑자기 심하게 과부하될 수 있다는 것이다.


중요한 노트

UX 및 화면 디자인을 전달하기 위한 많은 도구가 있다. Figma, Adobe XD, Sketch 및 Photoshop과 같은 응용 프로그램은 디자이너들 사이에서 정말 인기가 있지만 대부분의 엔지니어링 작업에 필수적인 기능이 부족하다. 제플린(Zeplin)은 디자이너와 엔지니어 사이의 격차를 좁히려는 애플리케이션 중 하나다. 다양한 디자인 도구에서 가져올 수 있으며 코드 조각, 디자인 사양 및 관련 자산을 생성할 수 있다. 자세한 내용은 https://zeplin.io/에서 확인할 수 있다.

엔지니어에게 UX 작업을 넘겨주는 데 널리 사용되는 도구인 제플린에서 제공하는 응용 프로그램의 화면 디자인 예를 살펴보자.

 
그림 14.1 – UX 프로페셔녈에 의해 그려진 예시 스크린 디자인

여기에서 디자인은 디자이너가 화면에 표시할 것에 초점을 맞추지만 화면에서 무엇을 어디에 배치할 지 관심을 두지 않는다. 물론 시각적으로 디자인 배치를 할 수 있긴 하지만 더 많은 UI 조각이 필요한 확장 지점은 어디에 그리고 어떻게 처리할까?

다음과 같이 더 많은 안내 프레임이 있는 동일한 화면 디자인을 살펴보자.


 
그림 14.2 – 확장성은 디자인 안에서 외부적으로 통신 돼야 한다

여기에 확장성을 위한 슬롯이 명확하게 표시되어 있다. 이를 통해 개발자는 설계자가 응용 프로그램의 유연성을 예상한 부분을 확인할 수 있다. 그러나 이 시점에서 설계자는 무엇이 가능하고 무엇이 타당한지 알기 위해 확실히 약간의 도움이 필요하다. 이러한 슬롯은 마이크로 프론트엔드를 나타내지 않지만 이미 배웠듯이 마이크로 프론트엔드는 추가 조각을 가져올 수 있다.

앞의 스크린샷에 표시된 예를 보면 확장성을 위한 영역을 표시하는 것만으로는 충분하지 않다는 것도 알 수 있다. 대신 설계자는 확장성을 처리하는 방법에 대한 세부 정보를 포함해야 한다. 예를 들어, navbar 작업 공간은 이미 완전히 채워져 있다. 다른 마이크로 프론트엔드가 여기에 버튼을 등록하려면 최소한 모의에서 공간이 충분하지 않다.

물론 이러한 모든 세부 사항을 단일 화면 디자인으로 전달할 수는 없다. 대신 개별 구성 요소 디자인을 통해 생성된 여러 화면 디자인의 조합을 사용해야 한다. 개별 구성 요소 디자인에서는 다음을 포함하되 이에 국한되지 않는 모든 예상 상태의 구성 요소를 표시해야 한다.

• 사용 크기에 대해 준수해야 하는 차원 확장 측면
• 특히 계속 증가하는 목록을 고려하면서 콘텐츠 확장 측면
• 터치, 마우스, 키보드 등 다양한 입력 방식
• 포함된 애니메이션 또는 전환과 같은 모션 속성

무한히 증가할 가능성이 있는 항목을 처리하는 방법을 배우는 것으로 돌아가 보자. 여기서 경계를 정의해야 한다. 이러한 경계는 표시된 항목의 수 또는 사용 가능한 화면 공간에 영향을 줄 수 있다. 예를 들어 디자이너는 다음을 정의할 수 있다.

• 0 요소의 경우 일부 자리 표시자를 표시할 수 있다.
• 3개 이상의 요소에 대해 다른 요소를 포함하는 팝업 메뉴를 열기 위해 후행 "..." 버튼을 표시할 수 있다.
• 팝업 메뉴 내에서 팝업 메뉴의 경계는 존중되어야 한다.
• 항목은 표시된 도구 설명 문자열(알파벳 순)에 따라 정렬된다.

마찬가지로 디자이너는 모바일, 태블릿 및 데스크톱과 같은 장치 범주에 대해 정의된 중단점에 종속된 규칙을 만들 수 있다.

설계자와 엔지니어 간의 단절을 방지하는 좋은 전략은 요구 사항과 함께 확장성을 위한 슬롯을 정의하는 것이다. 이렇게 하면 디자이너는 기능적 관점에서 화면이 어떻게 보여야 하는지 뿐만 아니라 기술적인 관점에서 전달해야 하는 내용도 알아야 한다. 확장 가능성(예: 추가 작업 버튼, 추가 오버레이 또는 패널)이 실제로 예상된다는 사실을 확인하는 것이 중요하다. 이제 이것이 어디에 배치되어야 하고 어떻게 시각적으로 작동해야 하는지를 결정하는 것은 디자이너의 몫이다.

일반적으로 수직으로 스크롤할 수 없는 모든 것이 문제가 될 수 있다. 세로로 스크롤되는 목록도 일정 크기를 초과하면 문제가 될 수 있다. 후자는 내부 검색 필터 또는 페이지 매김과 같은 다른 차원을 사용하여 쉽게 해결할 수 있지만 전자는 확실히 문제가 된다. 종종 팝업 메뉴("...")와 관련된 대체가 일반적인 솔루션으로 간주된다. 탭과 같은 일부 구성 요소는 스태킹과 같은 다른 중간 솔루션을 제공할 수 있다. 반면에, 아주 실용적으로 주어진 한도 내에서 유지하기 위해 요소를 버리는 전략을 항상 선택할 수 있다. 덜 유용한 요소를 버리기 위해 요소를 정렬하는 방법에 대한 주제가 다시 나온다.

구성 요소의 순서를 결정하는 방법에는 여러 가지가 있다. 예를 들어 메뉴 슬롯에는 다음이 있을 수 있다.

• 순서를 결정하는 구성 요소를 제공하는 마이크로 프론트엔드는 CSS의 z-색인과 매우 유사하다(높은 숫자가 먼저 옴).
• 호스팅 구성 요소(일반적으로 응용 프로그램 셸)는 암시적 정보를 통해 순서를 지정한다(예: 요소를 하드코딩하거나 순서를 계산하기 위한 기준으로 사용할 수 있는 각 구성 요소의 속성을 알고 있음).
• 순서를 명시적으로 정의하는 일부 구성이 로드된다(예: 백엔드에서).

이러한 모든 옵션에는 장단점이 있지만 첫 번째 옵션이 가장 적합하지 않다고 주장한다. 일반적으로 이것은 더 높은 수를 위한 싸움으로 이어지며, 이는 매우 유연하지 않고 불투명한 결과로 이어질 것이다. 마지막 옵션이 가장 많은 노력을 필요로 하지만 궁극적으로 최상의 솔루션이 될 수 있다. 그것은 요구 사항의 변화를 수용하기 위해 코딩 없이 신속하게 주문을 채택하기 위해 허용하는 유일한 솔루션이다.

목록을 주문하고 무한정 증가하는 것에 대해 생각하기 전에 마이크로 프론트엔드에서 더 자주 나타나는 또 다른 누락된 컴포넌트 같은 문제를 처리해야 한다. 

 
0에서 시작하는 법 배우기
앞서 언급했듯이 대부분의 마이크로 프론트엔드 솔루션은 실제로 애플리케이션 셸과 다른 마이크로 프론트엔드의 두 부분으로 나뉜다. 사이트리스 UI 또는 서버 측 구성과 같은 패턴에 대해 생각하면 응용 프로그램 셸이 일반 오케스트레이터 또는 에뮬레이터 형태로 개발에도 사용된다는 것을 알 수 있다.

마이크로 프론트엔드 개발은 일반적으로 빈 애플리케이션 셸에서 시작된다. 구현에 따라 몇 가지 일반적인 레이아웃 요소가 표시되지만 콘텐츠 측면에서는 아무것도 없다. 이는 콘텐츠가 이미 존재하고 새로운 화면 디자인을 구현하는 데 상상력이 덜 필요한 모놀리스 개발과 상당한 대조를 이룬다.

마이크로 프론트엔드는 별도로 개발할 필요가 없지만(개발 중에 다른 마이크로 프론트엔드도 로드될 수 있음) 대부분의 시나리오에 적합합니다. 또한 처음에는 다른 마이크로 프론트엔드가 없으므로 진공 상태에서 시작해야 한다.

이는 실제 UX 디자인에서 과소 평가되거나 최소한 과소 표현되는 경우가 많다. 예를 들어 빈 셸을 요청하면 다음과 같이 화면 디자인을 받을 수 있다.


 
그림 14.3 – UX 전문가들에 의해 건네진 빈 스크린 디자인의 예시

앞의 화면 디자인의 문제점은 비어 있지 않다는 것이다. navbar 헤더 및 navbar 작업에 대해 이전에 정의된 슬롯은 여전히 채워져 있다. 운 좋게도 이 화면 디자인의 긍정적인 결과도 있다. 먼저 구현할 수 있는 것에 대한 아이디어를 얻을 수 있다. 화면 디자인에 표시된 부분은 매우 중요하므로 일부 마이크로 프론트엔드에 흩어져 있으면 안 됩니다.

좋은 전략은 애플리케이션 셸 내부에 첫 번째 마이크로 프론트엔드를 구현하는 것이다. 이렇게 하면 화면 디자인이 밀접하게 따르고 전체 디자인에서 먼저 빈 캔버스를 처리할 필요가 없다. 첫 번째 부분이 정착되면 초기 마이크로 프론트엔드를 추출할 수 있다.

빈 애플리케이션 셸은 또한 폴백을 처리하는 방법을 알려준다. 때때로 이런저런 이유로 최종 사용자는 빈 셸을 받게 된다. 이런 일이 일어나서는 안되지만 그렇게 될 가능성이 있다. 대비책과 안전망이 있어야 한다. 이것들도 디자인으로 다루어야 한다.

구현 목록에 다음과 같은 대체 항목이 있을 수 있다.

• 구성 요소의 오류(예: 특히 전체 페이지에 대한 백엔드 리소스에 액세스할 때).
• 마이크로 프론트엔드를 로드할 때 오류가 발생한다.
• 페이지를 찾을 수 없다.
• 불충분한 권한(특히 이러한 UI 조각이 없는 사이트리스 UI의 경우 클라이언트 측에서 구성된 마이크로 프론트엔드에서 까다로울 수 있음)
배달도 됨).
• 채워져야 하는데도 비어 있는 확장 슬롯.

디자인 관점에서 이러한 폴백은 다른 디자인과 마찬가지로 취급되어야 한다. 고려해야 할 유일한 것은 이러한 폴백이 존재한다는 것입니다. 예를 들어, 확장 슬롯의 개념은 마이크로 프론트엔드에 매우 고유하다. 다음 섹션에서는 만든 디자인을 효율적으로 공유하여 모든 팀에게 시각적 방향을 알리는 방법을 알아보자.

효율적으로 디자인 공유하기
이미 제플린과 같은 도구가 디자이너와 엔지니어 사이의 격차를 해소하는 데 중요한 역할을 하는 것을 봤다. 마이크로 프론트엔드의 경우 여러 팀과 공유할 필요가 있는 디자인도 고려해야 한다. 팀은 제공된 UX 디자인과 완전히 다른 배경이나 기대치를 가질 수 있다. 일부 상황(특히 개방형 마이크로 프론트엔드 솔루션)에서는 상담할 화면 디자인이 전혀 없을 수 있다. 그러나 여전히 일관되고 매력적인 UX를 원한다. 이를 어떻게 달성할 수 있을까?

답은 원자적인 디자인을 만드는 데 있다. 이들은 가능한 가장 작은 빌딩 블록, 즉 이상적으로는 필요에 따라 함께 구성할 수 있는 블록만을 다루는 디자인이다. 이러한 구성 요소의 크기에 대해 많은 논쟁이 있지만 주어진 구성 요소가 목적을 달성할 때 적절한 크기를 찾을 수 있다고 주장한다. 이렇게 하면 자신과 팀에 적합한 세부 수준을 찾을 때까지 솔루션을 반복적으로 개선할 수 있다.

 이러한 빌딩 블록은 또한 재사용성 수준을 제공하며 일반적으로 구성 요소라고 알려져 있다. 일단 설계되면 일반 HTML에서 또는 리액트와 같은 일부 JS 프레임워크를 통해 사용할 수 있도록 구현해야 한다. 이미 설명했듯이 구성 요소를 공유하는 가장 쉬운 방법은 설계 사양을 제공하는 것이다. 그러나 이는 잠재적으로 일관되지 않은 구현 문제를 초래할 수 있다. 따라서 이러한 컴포넌트는 이미 구현된 형식 자체로 공유하는 것이 좋다.

이러한 컴포넌트는 여러 형태로 공유할 수 있다. 몇 가지 예를 살펴보자.

• NPM과 같은 일부 패키지 배포 메커니즘을 통해 제공
• 일부 CDN 링크를 통해 직접 가져오기 가능
• 모든 구성 요소를 나열하는 웹 사이트를 통해 액세스할 수 있는 개발 지침

세번째 방법을 종종 키친싱크(kitchen sink)라고 한다. 다음과 같이 개발된 모든 컴포넌트를 보여주고 쉽게 액세스할 수 있으며 사용 가능한 많은 옵션을 제공한다.

 
그림 14.4 - Styleguidist를 사용하면 표시된 컴포넌트를 사용하여 키친싱크를 만들 수 있다

이러한 키친싱크를 실현하기 위한 많은 솔루션이 있다. 가장 인기 있는 옵션은 Storybook, Vuepress, Docz 및 (리액트) Styleguidist이다. 내부적으로는 컴포넌트를 적절하게 문서화하고 표시하거나 일반적으로 시스템을 설계할 수 있도록 하는 정적 사이트 생성기이다.

앞의 스크린샷은 키친싱크의 예를 보여준다. 이 키친싱크는 전시된 라이브러리의 구성 요소로 이미 설계됐다. 이러한 유연성은 Styleguidist의 장점 중 하나다. 구성 요소를 찾고 문서화하는 작업을 담당하는 반면 디자이너는 구성 요소를 최대한 아름답게 표현하는 작업을 담당한다.

하나의 응용 프로그램을 넘어 디자인 시스템은 트위터가 부트 스트랩을 만들기 오래 전부터 시작된 추세이다. 그러나 확실히 이러한 시스템을 사용하려는 경향은 증가했다. 오늘날 거의 모든 대기업에는 최소한 하나의 디자인 시스템이 있다. 때때로 이들은 실제로 마이크로 프론트엔드 또는 마이크로 프론트엔드와 유사한 애플리케이션을 만드는 데 사용된다. Fluent UI라는 디자인 시스템을 공개한 마이크로소프트를 예로 들어 보자. 이를 이용하여 웹 또는 네이티브UI 같은 오피스 어플리케이션 내에서 실행되는 플러그인을 개발하는 데 사용할 수 있다.

이제 훌륭한 구성 요소를 가지고 있으므로 모든 화면에 대한 디자인을 제공하는 것이 불가능한 개방형 시스템을 확장할 수 있는 방법에 대해 생각할 필요가 있다.

디자이너 없이 디자인 만들기
이상적으로는 화면 디자인이 더 이상 작업되지 않는다. 대신 기술 구현을 위해 작업을 넘겨줄 필요가 없는 UX 엔지니어가 구성 요소를 직접 제작한다. 이러한 시나리오에서 이러한 구성 요소의 기술 구현은 이미 수행되었다.

이러한 설정의 결과는 모든 팀에서 사용할 수 있는 패턴 라이브러리다. 이 라이브러리는 HTML 프래그먼트 및 자바스크립트 스니펫(때로는 웹 구성 요소로 패키지화되기도 함)이 포함된 CSS 클래스 세트만큼 낮은 수준이거나 특정 프레임워크에 대해 이미 제공될 수 있다. 예를 들어, 이것들은 리액트 컴포넌트 라이브러리로 배송될 수 있다.

프레임워크별 라이브러리의 장점 중 하나는 해당 프레임워크 내에서 매우 쉽게 사용할 수 있으며 일반적으로 추가 포함이 필요한 일반 라이브러리보다 더 효율적이라는 것이다. 후자의 비효율성은 일반 자바스크립트에서 비롯된 것이 아니라 프레임워크별 최적화나 방법을 사용할 수 없기 때문이다.

구성 요소는 확실히 디자인 일관성을 가져오는 한 가지 방법이다. 그러나 종종 특정 규칙에 따라 더 큰 빌딩 블록을 구성해야 한다. 이를 위해 몇 가지 전략이 도움이 될 수 있다.

• 주의 깊게 사용할 패턴 문서화
• 더 큰 구성 요소를 반영하는 구성 요소 제공
• 기술적으로 특정 구성 요소 조합만 허용
• 원하는 구성 요소 조합만 제공하는 코드 생성기 만들기

실제 프론트엔드에 대해 DSL(Digital Subscriber Line) 방향으로 더 나아가는 것은 과한 것처럼 들리지만 때로는 과소평가해서는 안 되는 장점이 있다. 하지만 DSL을 작성, 문서화 및 유지 관리하기 위해 많은 노력이 필요하기 때문에 자주 선택되지 않는다.

좋은 절충안은 런타임 코드 생성기처럼 여겨지는 DSL에 일부 코드만 배치하는 것이다. 매우 자주, 이에 대한 최상의 대상은 form 엔진이다. Form 엔진을 사용하면 입력 양식에 대한 설명을 얻을 수 있다. 유효성 검사, 수명 주기 처리 및 렌더링과 같은 다른 모든 작업은 form 엔진에서 수행된다. 이것의 가장 큰 장점은 양식을 구현하기가 더 쉬울 뿐만 아니라 정확하고 일관성 있게 보인다는 것이다. 양식 엔진도 처음부터 개발할 수 있지만 종종 기존 엔진을 사용하는 것이 합리적이다. 이렇게 하면 유지 관리가 약간 절약되고 개발자가 더 빨리 생산성을 높일 수 있다.

요약
이 장에서는 UX 디자인을 만들 때 마이크로 프론트엔드를 약간 다르게 처리해야 하는 이유를 배웠다. 확장성은 또한 처음부터 설계 고려 사항의 일부가 되어야 한다는 것을 보았다.

이 장에서 설명하는 기술을 통해 화면 디자인이 마이크로 프론트엔드 시스템에도 유용하다. 확장성을 제공해야 하는 위치와 엣지 케이스를 처리하는 방법을 아는 것은 멋진 사용자 경험을 보장하는 데 중요하다. 결국, 애플리케이션의 기술적 구현이 아무리 훌륭하더라도 견고한 UX가 없으면 상당한 사용자 채택을 얻지 못할 것이다.

다음 장에서는 마이크로 프론트엔드 솔루션을 개발자 친화적으로 만들기 위해 고려해야 할 사항에 대해 알아본다. 이것은 많은 사람들에게 선택 사항으로 간주될 수 있지만 개발자들 사이에서 채택될 뿐만 아니라 높은 개발 효율성과 자율성을 보장하기 위한 핵심 요소 중 하나이다.
 
15 개발자 경험
이전 장에서 UX와 화면 디자인이 많은 영향을 받는 것을 보았다. 커뮤니케이션 및 구현 문화의 이러한 변화는 개발뿐만 아니라 모든 영역에 영향을 미친다. 그럼에도 불구하고 개발 팀은 마이크로 프론트엔드 솔루션을 성공적으로 포함하기 위한 기반을 형성한다.
이 장에서는 뛰어난 개발자 경험을 제공하기 위해 무엇이 필요한지 배우게 된다. 보시다시피 마이크로 프론트엔드 솔루션은 기술 수준에서 모듈식이어야 하지만 개발 관점에서는 단일 부품처럼 느껴진다. 개발자는 좋은 마이크로 프론트엔드 솔루션을 다룰 때 마이크로 프론트엔드에 대해 생각할 필요가 없다. 대신 그들의 분야에만 집중할 수 있어야 한다.
마이크로 프론트엔드는 사용자 경험을 생성하기 위한 가장 복잡한 기술 중 하나이다. 종종 이 복잡함은 실제로 길들여지지 않았으므로 개발 팀이 조치를 취해야 한다. 그런 일이 발생하면 여러 문제에 직면하게 된다. 마이크로 프론트엔드의 수용이 어려울 뿐만 아니라 솔루션 자체가 나빠질 수도 있다. 마지막으로 효율성이 떨어지는 비즈니스 라인은 궁극적으로 프로젝트를 중단하기로 결정할 수도 있다.
이번 장은 아래와 같이 구성되어 있다.
	최소한의 개발자 경험 제공
	적절한 개발자 경험 구축
	최고의 개발자 경험 달성
모든 섹션에서 개발자 경험(DX)을 향상시키기 위해 솔루션에 더 많은 레이어를 추가할 것이다. 괜찮은 DX를 위한 최소한의 것부터 시작해보자.

최소한의 개발자 경험 제공
기본 DX의 경우 마이크로 프론트엔드 솔루션의 개발이 이전에 생성한 다른 솔루션의 개발과 완전히 다르게 작동하지 않는지 확인해야 한다. 내부적으로 많은 것이 다를 수 있지만 마이크로 프론트엔드 개발자가 모든 것을 다시 배워야 하는 경우 수용률은 예상보다 훨씬 낮을 것이다.
개발자가 마이크로 프론트엔드 설정을 잘 할 수 있도록 하는 첫 번째 단계는 표준 통합 개발 환경(IDE)에서 원활한 개발 흐름을 지원하는 것이다.

표준 IDE에서 개발 지원
개발은 텍스트 편집기를 통해 코드를 공유하거나 사용할 수 있지만 거의 모든 개발자는 VS Code, Atom 또는 WebStorm과 같은 IDE에서 독점적으로 코드를 작성하는 데 익숙할 것이다. 대부분이 이런 방식을 사용한다. 결국 IDE를 통해서 코드 완성, 언어별 스니펫 또는 통합 디버깅과 같은 기능을 쉽게 사용할 수 있다. 해당 기능들은 많은 가치를 제공하고 효율성의 증가는 실제로 그 자체로 확인할 수 있다.
마이크로 프론트엔드 솔루션을 위해 무엇을 하든 사용 가능한 IDE 또는 표준 편집기와 함께 사용하기 쉽게 만들어져야 한다. 처음에는 IDE를 사용하는 게 쉬워 보이지만 실제로 그렇지 않다는 것을 알게 될 것이다. 표준 도구와 함께 작동하지 않는 것을 고안하는 것은 실제로 매우 간단하다.
7장 "서버측 구성"에서 제공한 예제를 보면 다음과 같은 ESI 태그를 ejs 파일에 사용했다.
<esi:include src=”<%= page %>” /> 

어떤 IDE를 선택하든 문제가 될 수 있다. 첫째, IDE는 올바른 피드백을 제공하고 src와 같은 속성에 대한 자동 완성을 제공하는 esi:include 태그가 있음을 알아야 한다. 둘째, 속성 값은 템플릿 구문을 사용하여 작성된다. 속성 값이 완전히 인식되지 않을 수 있다. ejs 구문을 사용하는 파일이 직접 지원되지 않는 경우 선택한 편집기에는 ejs용 통합 플러그인 시스템이 있어야 한다. 그렇지 않으면 개발자는 바닥부터 코드를 작성해야 한다.
위와 같은 문제는 확실히 문제가 되지만, 큰 문제이거나 새로운 것은 아니다. 템플릿 엔진과 사용자 지정 태그는 새로운 것이 아니며 플러그인을 통해 이를 지원할 수 있다. 거의 모든 IDE가 이러한 사용자 지정을 제공하기 위해 확장될 준비가 되어 있다. 그럼에도 불구하고 ejs와 같은 인기 있는 템플릿 엔진을 선택하지 않고, 예를 들어, 자신만의 템플릿 엔진을 개발한다면 이에 대한 에디터 통합을 제공해야 한다.
자체 에디터 통합을 작성하는 것은 복잡하지 않지만 확실히 시간이 많이 걸린다. 설상가상으로 여러 에디터를 지원해야 할 수도 있다. 즉, 통합 개발에 더 많은 시간을 할애해야 하지만 여기서 유지 보수는 제외가 된다.
결과적으로 마이크로 프론트엔드 솔루션의 개발 에코시스템과 개발자 지원에 대해 실제로 더 관심을 갖고 싶지 않다면 가장 인기 있는 편집자가 직접 또는 플러그인을 통해 이미 지원하는 확립된 솔루션만 사용하는 것이 좋다. – 마이크로 프론트엔드를 만들기 위한 새로운 프레임워크를 만들고 싶다면 분명히 실행 가능할 것이다.
확립된 프레임워크가 도움이 될 수 있는 또 다른 방법은 프로젝트 템플릿을 제공하는 것이다. 에디터 통합만큼 중요한 것은 아니지만 표준 템플릿을 사용하면 팀이 새로운 마이크로 프론트엔드를 신속하게 만들 수 있다. 다음 섹션에서 표준 템플릿을 사용하여 스캐폴딩 환경을 개선하는 방법에 대해 알아보자.

스케폴딩 경험 개선
표준 템플릿을 제공하기 위한 가장 쉬운 방법 중 하나는 마이크로 프론트엔드 중 하나에서 기대할 수 있는 모든 것이 포함된 저장소를 호스팅하는 것이다. 해당 접근 방식의 문제는 더 많은 문서가 필요할 뿐만 아니라 사용자의 수동 변경도 필요하다는 것이다. 예를 들어 Node.js 프로젝트는 일반적으로 이름을 정의하고 package.json 파일에서 찾을 수 있는 이 필드는 변경되어야 한다.
따라서 더 나은 옵션은 Yeoman과 같은 스캐폴딩 도구를 사용하는 것이다. 이렇게 하면 모든 템플릿 변수의 이름이 올바르게 지정되며 프로젝트 생성 후 식별 및 변경할 필요가 없다. 이러한 작업들이 완료되었다면 수행해야 할 모든 작업이 완료된 것이다.

중요한 노트
Yeoman은 명령줄 인터페이스 형태로 제공되는 스캐폴딩 도구이다. 특정 사용 사례에 맞게 조정된 것으로 Node.js 프로젝트를 만들 수 있도록 대화형 애플리케이션을 쉽게 만들 수 있다. 스캐폴딩 외에도 이 도구는 린트와 같은 다른 일반적인 작업에도 사용할 수 있다. 자세한 내용은 https://yeoman.io/에서 확인할 수 있다. 

때때로 스캐폴딩은 프로젝트를 설정하는 데만 사용되는 것이 아니라 반복되는 작업을 돕는 데에도 사용된다. 예를 들어 앵귤러 CLI에는 표준 규칙을 충족하는 세 개의 파일이 있는 새 폴더를 생성하기 위한 새 구성 요소에 대한 스캐폴딩이 포함되어 있다. 소규모 단일 파일 작업 에디터의 경우 VS Code용 teamchilla Blueprint와 같은 스니펫 또는 고급 플러그인도 도움이 될 수 있다.
CLI 도구를 사용하는 스캐폴딩 세션의 예는 다음과 같다.
$ npm init pilet
? Sets the source package (potentially incl. its tag/version) containing a Piral instance for templating the scaffold
process.
> sample-piral
? Sets the target directory for scaffolding. By default, the
current directory.
>.
? Sets the package registry to use for resolving the specified
Piral app.
> https://registry.npmjs.org/
  ? Already performs the installation of its NPM dependencies.
> Yes
  ? Determines if files should be overwritten by the scaffolding.
> No
  ? Determines the programming language for the new pilet.
> js
? Sets the boilerplate template package to be used when
scaffolding.
> empty
  ? Sets the NPM client to be used when scaffolding.
> npm
? Sets the default bundler to install.
> webpack5

답은 자유 텍스트 값 또는 목록에서 선택하는 것이다. 기본값을 직접 사용할 수 있는 경우가 많다. 이 예는 프로젝트 스캐폴딩을 CLI를 통해 직접 제공하는 Piral에서 가져온 것이다. 따라서, 스캐폴딩은 프레임워크 레벨에서 이미 해결되었으며 템플링 세부 사항과 옵션만 앱 셸 소유자에게 맡기면 된다.

Piral이 도입되었을 때 11장, Siteless UI에서 이전 명령과 매우 유사한 명령을 사용했다는 것을 눈치채셨을 것이다.
중요한 노트
npm 이니셜라이저는 매우 편리하다. 이를 통해 npm init를 사용하여 새 Node.js 프로젝트를 생성하는 경험을 모든 종류의 프레임워크 또는 도구로 일반화할 수 있다. "create-"가 접두사로 붙은 모든 NPM 패키지는 이니셜라이저로 사용할 수 있다. 유일한 다른 요구 사항은 패키지가 package.json 파일의 bin 속성을 통해 패키지 자체와 동일한 이름을 사용하는 유틸리티를 노출한다는 것이다.

그럼에도 불구하고 스캐폴딩과 에디터 통합 도구만으로는 충분하지 않다. 해당 도구들이 좋은 개발자 경험의 기초가 될 수 있다. 실제로 괜찮은 DX를 얻으려면 다른 몇 가지 사항도 고려해야 한다.

적절한 개발자 경험 구축
이전 섹션에서는 최소한의 DX에 도달했는지 확인하는 방법을 배웠다. 이것이 마이크로 프론트엔드를 실행될 수 있게 제공되어야 하는 생산성 수준이다. 이제 새로운 개발자를 위한 원활한 온보딩, 모든 개발자를 위한 더 쉬운 개발 및 버그 수정, 관련된 모든 사람을 위한 시스템에 대한 좋은 개요를 보장하기 위한 경험을 향상시켜야 한다.

코드 문서 중앙 집중화
분산 시스템의 문제 중 하나는 사물이 상당히 단편적이라는 것이다. 예를 들어, 확장 슬롯의 사전적 의미로 하나의 마이크로 프론트엔드에 존재할 수 있지만 해당 슬롯으로 들어가는 두 확장자는 두 개의 다른 마이크로 프론트엔드에 의해 정의된다. 세 개의 저장소 사이를 이동하는 것은 번거롭고 가시성에 영향을 미치고 결국 이런 것들이 어디에 쓰여져 있는지 누가 알 수 있을까?
모노리스가 가시성 문제에 덜 직면하는 이유는 모든 정보가 중앙 집중화되기 때문이다. 그러나 앱 셸 모델에 대한 경험은 분산 시스템에서도 중앙 집중화를 달성할 수 있다는 것을 보여준다. DX를 개선하기 위해 유사한 기술을 적용할 수 있을까?
유사한 기술을 적용시키는 것은 매우 간단하다. 모든 마이크로 프론트엔드가 통과해야 하는 중앙 게이트만 있으면 된다. 닫힌계에서 쉽게 수행할 수 있다. 예를 들어 모든 마이크로 프론트엔드가 동일한 CI/CD 시스템을 사용해야 하는 경우 모든 리포지토리가 사용가능하다 그렇지 않으면 개방형 시스템에서 모듈을 배포할 때 유형 선언이나 문서와 같은 특정 메타데이터가 제공되도록 요구할 수 있다.
그런 다음 이러한 정보의 집계는 여러 형태로 보여줄 수 있다. 문서화의 경우 정적 PDF 문서의 형태로 보여줄 수 있고 더 나은 방법으로는 일종의 문서 포털에서 문서를 호스팅하는 것이다. 이러한 포털은 생성된 정적 웹 사이트로 구성할 수 있다. 이를 도와줄 수 있는 도구가 시중에 많이 나와 있다. 그 중 하나가 Docusaurus(https://docusaurus.io/)이다.
다음 다이어그램은 중앙 집중식 문서 시스템을 아키텍처적으로 배치할 수 있는 방법을 보여준다.
 
그림 15.1 – 중앙화된 문서 시스템의 아키텍쳐

해당 아키텍처는 Siteless UI 패턴을 사용하여 마이크로 프론트엔드를 구축하는 데 필요한 피드 서버와 같은 중앙 레이어에 분산되지만 게시 및 집계되는 모든 마이크로 프론트엔드 시스템에서 작동한다.
그러나 다음 수준의 DX를 달성하려면 분산된 지식을 중앙 집중화하는 것뿐만 아니라 고려해야할 사항이 있다. 개선해야 할 또 다른 사항은 솔루션 자체에 대한 문서이다. 예를 들어 비디오나 대화형 튜토리얼을 활용하는 것이다.

동영상으로 문서화
최근 몇 년 동안 문서화를 위해 동영상을 사용하는 경향이 많이 증가했다. 고대역폭 인터넷 연결의 광범위한 가용성과 향상된 멀티미디어 플랫폼이 이러한 추세를 뒷받침한다. 그러나 문서화를 위해 동영상을 실제로 사용하려면 다음 사항을 알아야 한다.

	5분짜리 동영상을 만드는 데 평균 30분에서 3시간이 걸린다.
	동영상은 항상 링크, 문서 내용, 코드 저장소 등의 형태로 약간의 뒷받침이 필요하다.
	긴 동영상은 자주 활용되지 않는다.

특히 마지막 요점이 중요하다. 동영상으로 문서화를 시작해서는 안 된다. 마찬가지로 솔루션의 모든 부분을 동영상으로 문서화해서는 안된다. 안정적이고 곧 변경되지 않을 것 같은 핵심 부품을 목표로 진행되어야 한다.
동영상을 쉽게 활용할 수 있도록 정확성을 유지하고 2분에서 15분 사이의 동영상을 만드는 것이 좋다.
동영상의 설명 또는 아웃트로에 사용된 도구 및 라이브러리에 대한 정보가 포함되어야 한다. 어떤 버전의 마이크로 프론트엔드 솔루션을 사용했는지 특히 어떤 부분이 제시되었는지 예를 들어 어떤 기능을 사용했는지 해당 정보를 제공하면 동영상을 교체해야 하는지 또는 여전히 최신 상태인지 확인하는 것이 매우 간단하다.
짧은 동영상은 유지 관리 오버헤드를 피하는 데 도움이 된다. 또한 개발자가 많은 동영상을 스캔하지 않고도 올바른 콘텐츠를 찾는 데 도움이 될 것이다.
예를 들어 일부 영상은 개발자가 도움이 될 수 있는 코드 분석 도구에 대한 지식을 얻는 데 도움이 될 수 있다. 이러한 도구 중 일부는 이미 설정되어 사용할 준비가 되어 있을 수도 있다.

코드 분석 지원
적절한 DX를 위해 주의를 기울여야 하는 또 다른 영역은 코드 하이지닉 및 툴링이다. 특히 폐쇄형 마이크로 프론트엔드 솔루션에서 표준 템플릿은 이미 코딩 스타일을 정의해야 한다. .editorconfig 파일 또는 Puter와 같은 코드 포맷 도구뿐만 아니라 라이터를 통해 스타일을 적용하면 마이크로 프론트엔드에 친숙함과 향상된 가독성을 도입하는 스타일을 확립하는 데 도움이 된다. 개방형 솔루션의 경우 코드 포맷은 중요하지 않다. 여기서 린트는 개발자가 솔루션을 제출하기 전에 현지에서 대부분의 점검을 수행할 수 있도록 많이 강화해야 한다.
검증 및 툴링에 대해서는 완전한 타이핑을 제공해야 한다. 타이핑 또는 유형 선언은 개발 중에 더 나은 지침을 제공하고 추가적인 컴파일 타임 안전성을 제공하기 위해 TypeScript에 의해 선택될 수 있는 파일이다. 이러한 파일을 제공하는 가장 쉬운 방법은 처음부터 TypeScript로 개발하는 것이다. 그러나 TypeScript가 없더라도 선언 파일을 직접 작성하거나 문서 주석에서 생성할 수 있다.
일반적으로 TypeScript를 사용하여 라이브러리나 프레임워크와 같은 다른 코드의 기초를 이루는 코드를 작성하는 경향이 있다. 이러한 방식으로 코드는 컴파일 단계에서 확인될 뿐만 아니라 마이크로 프론트엔드 개발자와 같은 사용자들에게 적절한 입력이 제공될 수 있다. TypeScript 개발자에게만 유용하게 들리더라도 대부분의 IDE는 TypeScript를 사용하여 JavaScript를 지원한다. 따라서 이러한 타이핑은 TypeScript 뿐만 아니라 자바스크립트를 사용하는 개발에도 사용할 수 있다. 일반적으로, 자바스크립트로 변환되는 거의 모든 언어들은 형식 선언으로부터 이익을 얻는다.
컴파일 타임 검증 및 정적 코드 분석 도구를 사용하더라도 버그가 발생한다. 코드 기반에서 회귀를 피하는 가장 쉬운 방법은 테스트를 작성하는 것이다. 적절한 DX의 경우 특히나 쉬워야 한다.

테스트 가능성 향상
마지막으로 몇 가지 테스트를 쉽게 작성하는 것이다. 테스트에 대해 생각하면 결국 고전적인 테스트 피라미드로 이어질 것이다. 이 피라미드는 다음으로 구성된다.
	단위 테스트를 나타내는 기본 계층
	구성 요소 및 통합 테스트를 나타내는 중간 계층
	종단 간/승인 테스트를 나타내는 최상위 계층

최상위 계층은 부분적으로 수동 테스트로 구성될 수 있지만 모든 계층은 독점적으로 자동화된 테스트를 포함하도록 되어 있다.
테스트 환경을 개선하기 위해 다음을 수행하면 된다.
	유닛 테스트 프레임워크와 테스트 러너를 프로젝트 템플릿에 통합한다.
	핵심 프레임워크 기능에 대한 Mock을 제공한다.
	샌드박스 환경을 구축하여 솔루션을 격리하여 실행한다.
	지나치게 중요한 계약 테스트를 자동화하여 경계를 준수한다.
이상적으로 사전 구성된 모든 테스트 가능성은 옵트인 또는 옵트아웃이다. 예를 들어 프로젝트 스캐폴딩을 설치하는 동안 질문은 "테스트를 활성화하시겠습니까?"가 될 수 있다. 이상적으로는 어떤 테스트 프레임워크를 사용해야 하는지 질문할 수도 있다. 그러나 현실적으로 이러한 다양성을 지원하는 것이 생산성에 의미도 없고 큰 영향도 미치지 않는다. Jest와 같은 단일 테스트 프레임워크를 지원하는 것이 가장 좋은 선택일 수 도 있다. 여러분과 여러분의 팀이 가장 잘 알고 있는 프레임워크에 선택하는 것을 권장한다.
이제까지 적절한 DX의 레벨링을 완료했으므로 최상의 개발자 환경을 얻기 위한 단계를 살펴보고 잠재적으로 구현해보자.

최고의 개발자 경험 달성
지금까지의 단계를 통해 개발자로부터 인정을 받을 뿐만 아니라 생산성을 높일 수 있도록 했다. 개발자들은 정보를 빠르게 찾고 솔루션이 어떻게 작동하는지 알게 되며 코드가 잘 맞는지 확인할 수 있게 되었다.
그러나 개발자 효율성을 최대한 높이려면 조금 더 필요한 게 있다. 개발자에게 정보를 반영하거나 개발 프로세스 자체에서 개선할 수 있는 부분이 항상 있음을 알 수 있다. 
가장 먼저 살펴볼 항목은 개발 중에 나타나는 오류 코드이다.

오류 코드 통합
새로운 마이크로 프론트엔드를 개발할 때 통합하는 지점과 일반적으로 사용 가능한 API를 파악하기가 항상 간단한 것은 아니다. 더 많은 문서와 예를 통해 명확히 밝혀질 수 있는 혼란이 있 수 도 있지만 코드를 작성할 때는 거의 참조하지 않는다. 대신 개발자는 코드를 작성하고 예상대로 작동하지 않는다는 것을 알게 된 다음 도움을 줄 사람을 찾아야한다. 잠재적으로 버그를 신고할 수도 있다.
이 동작을 수정하려면 런타임 코드에 적절한 지침을 도입해야 한다. 일부 기능이나 API의 특정 패턴이나 사용을 감지하면 전체 설명이 포함된 오류 메시지를 인쇄하여 개발자에게 문제의 특성을 알릴 수 있다. 그러나 프론트엔드 번들에 텍스트 단락이 여러 개 있는 것은 최종 사용자가 사용하는 프로덕션 환경에서는 바람직하지 않다. 여기서 수행할 수 있는 작업은 React와 같은 라이브러리를 사용하는 방법을 따르는 것이다. 개발 버전은 자세한 오류 메시지를 제공하는 반면 프로덕션 번들은 약어로 된 오류 코드만 사용하는 여러 변형으로 제공된다.
예를 들어 다음 코드는 릴리스가 아닌 환경에서 보다 자세한 오류 메시지를 표시한다. 로컬 개발 또는 테스트 실행 시 전체 오류 메시지가 표시된다.
if (process.env.NODE_ENV !== "production") {
console.error("More descriptive error here");
} else {
console.error("ERR0123");
}

해당 코드는 완전히 생성될 수 있으므로 이전 상용구 코드를 작성할 필요가 없다. 이 문제를 해결하는 방법은 여러 가지가 있지만 가장 단순하고 유연하며 전송 가능한 방법은 컴파일 타임 기호를 사용하는 것이다.
웹팩에서는 다음과 같이 구성할 수 있다.
const errors = {
// ...
"ERR0123": "More descriptive error here",
};

module.exports = {
// ... normal Webpack configuration
plugins: [
new webpack.DefinePlugin(
Object.keys(errors).reduce((obj, code) => {
// either use the code or the description for the code
const msg = process.env.NODE_ENV === "production" ?
code : errors[code];
obj[`process.env.CODES_${code}`] = msg;
return obj;
}, {})
),
]
};

코드에 이 기능이 어떻게 사용되는지 알아보자.
console.error(process.env.CODES_ERR0123);

보시다시피 보일러 플레이트는 더 이상 많이 필요하지 않는다. 또한 오류 정의는 일부 다른 모듈에 배치될 수 있으며 이후 설명서에 통합될 수 있다.
자세한 오류 메시지와 좋은 오류 코드는 개발 중 문제 해결을 위한 좋은 출발점을 제공하지만 오프라인 우선 개발 접근 방식을 지원하여 한 단계 더 나아가는 것을 목표로 삼아야 한다.

오프라인 우선 개발 환경 제공
프론트엔드 시스템은 연결된 백엔드 시스템과 긴밀하게 통합되는 경우가 많다. 이는 API 변경에 대한 높은 민감도 또는 개발 중 종속성과 같은 몇 가지 문제를 야기한다. 앞서 살펴본 바와 같이 백엔드와 독립적으로 프론트엔드를 개발할 때 얻을 수 있는 이점 중 하나는 이 영역에서 더 많은 유연성을 얻을 수 있다는 것이다.
프론트엔드 및 백엔드의 분리된 개발은 단일 페이지 애플리케이션(SPA)이 빛을 발하는 부분이기도 하다. SPA는 프론트엔드에 이미 렌더링되어 있기 때문에 백엔드에서 분리된다. 이제 커플링을 어느 정도 남겨둘지는 개발자에게 달려 있다. 모든 커플링이 API 기본 URL에 의해 수행되는 경우 다음과 같이 실행되도록 구성할 수 있는 단일 프론트엔드를 사용하여 이러한 이점을 활용할 수 있다.
	모든 환경의 백엔드(운영, 스테이징 등)
	백엔드의 로컬 버전
	백엔드의 모의 버전
특히 마지막부분은 매우 흥미롭다. 모의 버전을 실행하면 많은 이점이 있다. 예를 들어 백엔드에서 제공하지 않고도 모든 시나리오를 정의하고 테스트할 수 있다. 이렇게 하면 잘못된 데이터 시나리오도 아주 잘 테스트할 수 있다.
또 다른 장점은 백엔드가 아직 완전히 개발될 필요가 없다는 것이다. OpenAPI 사양과 같은 간단한 API 정의만 있어도 프론트엔드 개발을 시작할 수 있다.
이러한 모의 설정은 다양한 방법으로 수행할 수 있다. Browsersync, http-proxy-middleware 또는 kras와 같은 라이브러리가 있다. 웹팩을 번들러로 사용하는 경우 http-proxy-middleware가 이미 웹팩 개발 서버에 통합되어 있음을 알 수 있다.
다음 코드 스니펫은 사용자 지정 프록시를 포함하도록 웹팩을 구성하는 방법을 보여준다.
module.exports = {
// ... normal Webpack configuration
devServer: {
publicPath: "/app",
proxy: [
{
// set the right context, e.g., all request to /api
context: [`/api/**`, `!/app/**`],
// redirect target to mock server running at
// port 5000
target: "http://localhost:5000",
changeOrigin: true,
},
],
},
};

이 사례에서 중요한 점은 애플리케이션의 코드를 건드리지 않고도 다른 서버를 구성할 수 있다는 것이다. 우선 도구를 제대로 설정해야 한다. 이렇게 하면 온라인 환경에서 로컬에서 실행 중인 모의 서버에 이르기까지 동일한 코드를 여러 백엔드와 함께 사용할 수 있다.
오프라인 우선은 클라이언트 측 렌더링 마이크로 프론트엔드 솔루션을 통해 달성하기가 더 쉽지만 서버 측 구성 접근 방식을 따르는 솔루션에서는 실현이 불가능하지는 않는다. 여기서는 로컬 모의 서버와 같은 프록시 대상을 정의할 수 있는 가벼운 버전의 오케스트레이션 또는 게이트웨이 서비스를 제공해야 한다.
두 경우 모두 기술 기반에서 추가 작업을 수행할 필요 없이 오프라인에서 솔루션을 개발할 수 있어야 한다. 물론 통합을 위해서는 마이크로 프론트엔드를 검색하거나 솔루션이 실제 데이터에서도 작동하는지 확인하기 위해 여전히 어느 정도의 연결이 필요한다.
통합 부분에서도 몇 가지 문제가 발생할 수 있다. 이러한 과제 중 하나는 어떤 마이크로 프론트엔드가 실제로 개별 컴포넌트를 전달하는지를 파악하는 것이다. 다행스럽게도 이 부분이 브라우저에서 사용할 수 있는 도구들이 빛을 발하는 부분이다.

브라우저 확장을 통한 사용자 정의
확립된 프레임워크를 선택하는 이유 중 하나는 이 모든 프레임워크가 일종의 플러그인과 툴 에코시스템과 함께 제공되기 때문이다. 예를 들어 단일 SPA를 선택하면 단일 스파 검사기라는 브라우저 확장 기능을 사용할 수 있다. 또한, Piral은 Piral Inspector라고 알려진 브라우저 확장 기능과 함께 제공된다.
이러한 브라우저 확장은 애플리케이션의 마이크로 프론트엔드 구성을 조작하고 확인할 수 있도록 하므로 매우 유용하다. 이렇게 하면 특정 마이크로 프론트엔드를 켜거나 끄고 구성이 여전히 괜찮은지 확인하는 것이 매우 간단하다.
예를 들어 다음 이미지에 표시된 Piral Inspector의 구성 요소 표시 기능을 살펴보자.
 
그림 15.2 – 마이크로 프런트엔드에서 어떤 구성 요소가 나오는지 보여주는 Piral Inspector
여기에서 브라우저 확장이 오른쪽 상단 모서리에 이름을 표시하고 배경에 일부 색상 인코딩을 표시하여 다양한 구성 요소의 출처를 표시하는 것을 볼 수 있다. 확장 기능이 없으면 이러한 타일을 노출시키는 마이크로 프론트엔드를 파악하기가 상당히 어려울 것이다.
브라우저 확장은 항상 유용하며 서버 측에서 구성된 마이크로 프론트엔드에는 훨씬 덜 유용할 것이다. 그럼에도 불구하고 여기서 할 수 있는 일은 마이크로 프론트엔드의 구성과 같은 전체 구성을 변경하거나 일부 특수 헤더를 통해 사용자 정의할 수 있는 일종의 포털을 제공하는 것이다.
요청 시 사용자 정의 헤더를 사용하려면 ModHeader와 같은 브라우저 확장을 설치할 수 있다. 이를 통해 예를 들어 애플리케이션의 특정 환경에 대한 프로필을 생성할 수 도 있다. 여기서 각 요청과 함께 사용자 정의 헤더가 전송된다. 그러면 오케스트레이션 계층이 이 헤더를 읽고 이 특정 요청에 대해서만 구성을 조정한다.
확실히 게이트웨이 포털은 특히 오케스트레이션 계층도 열 수 있기 때문에 훨씬 더 의미가 있다. 그러나 이상적으로는 이러한 기능은 이미 전문 개발자 포털에서 사용할 수 있어야 한다.

개발자 포털 구현
모든 대규모 프로젝트에는 많은 조정이 필요하다. 자율적인 팀을 지향하는 경향이 잠재적인 관료적 오버헤드를 최소화하는 데 확실히 도움이 될지라도 마이크로 프론트엔드는 확실히 이 규칙의 예외가 아니다.
모든 개발자를 위한 중앙 포털을 도입하여 반복 작업, 공통 콘텐츠 및 상태 정보를 단일 웹 사이트에 집계할 수 있다.
다음 스크린샷은 스캐폴딩 기능이 있는 개발자 포털을 보여준다.
 
그림 15.3 – 개발자 포럼에서 마이크로 프런트엔드의 스캐폴딩
앞의 스크린샷에 표시된 개발자 포털의 스캐폴딩 기능은 몇 가지 작업을 제공한다. 몇 가지 옵션(특히 사용할 템플릿)을 선택할 수 있는 것 외에도 마이크로 프론트엔드를 기능 플래그에 연결할 수도 있다. 또한 저장소 이름으로 사용될 마이크로 프론트엔드에 이름을 지정해야 한다.
CLI 도구를 통해 수행할 수 있는 실제 코드 스캐폴딩 외에도 이 웹 기반 접근 방식은 필요한 모든 CI/CD 파이프라인 및 코드 검토 정책도 생성한다. 또한 이를 전체 솔루션에 통합한다. 예를 들어 생성 후 마이크로 프론트엔드의 문자열에 대한 변환을 중앙에서 관리할 수 있다.
앞의 스크린샷에서 관찰할 또 다른 사항은 검색 상자가 검색 문서를 참조한다는 것이다. 여기에서 개발자 포털은 API 문서 및 플레이그라운드를 포함한 중앙 집중식 문서도 공개한다. 이는 많은 조회 없이 빠르게 지침을 찾고 도움을 받는 데 중요한 요소이다.
이러한 개발자 포털의 도움으로 새로운 개발자를 신속하게 온보딩하고 표준 유지 관리 작업과 같은 일상적인 개발에 편의를 제공하며 애플리케이션의 현재 상태를 시각화할 수 있다.

 
요약
이 장에서는 좋은 개발자 경험이 개발자 팀의 동의를 얻고 마이크로 프론트엔드 솔루션을 매력적이고 깔끔하게 유지하는 가장 좋은 방법이라는 것을 배웠다. 달성할 수 있는 다양한 수준의 개발자 경험과 이를 달성하는 방법에 대해서도 알게 됐다.
기존 프레임워크를 사용하면 앞서 설명한 경험의 대부분을 무료로 쉽게 얻을 수 있다. 자신의 기능을 맨 위에 추가하면 기술적으로 건전하고 다른 당사자가 유지 관리하면서 도메인별 문제를 수용하는 이상적인 경험으로 이어질 것이다.
그런 다음 훌륭한 DX의 중요한 요소는 문서화라는 것을 배웠다. 중앙 집중식 문서 포털을 제공하여 사람들이 관련 정보를 찾을 수 있도록 하는 것이다. 동영상과 같은 동적 부분을 추가하면 자료를 더욱 시각적으로 만드는 데 도움이 된다.
개발자 경험을 개선하려면 항상 주의를 살펴야 한다. 보시다시피 단위 테스트, 유형 선언 및 의미 있는 오류 코드와 같은 개선 사항은 DX를 개선할 뿐만 아니라 개발의 전반적인 효율성과 솔루션의 견고성에 기여한다.
다음 장에서는 다른 회사가 웹 애플리케이션에 마이크로 프론트엔드를 활용하는 문제에 어떻게 접근하는지 배운다.
 
16 사례 연구
이 장에서는 다른 사람들이 마이크로 프론트엔드라는 주제를 어떻게 다뤘는지 배울 것이다. 여기서 몇 가지 유사점은 있지만 몇가지 핵심 영역에서 다른 세 가지 다른 사례를 읽게 될 것이다. 세 가지 사례 모두 마이크로 프론트엔드를 대규모로 구현한 실제 경험을 나타낸다.

이 장에서는 다음 주제를 다룬다. 
•	사용자 대면 포털 솔루션
•	관리 포털 사이트
•	의료 관리 솔루션
더 이상 고민하지 않고 다른 사례 연구로 바로 이동해보자.

사용자 대면 포털 솔루션
첫 번째 사례 연구는 독일의 광학 시스템 및 광전자공학 제조업체에 관한 것이다. 그들은 계측, 현미경, 의료 기술, 소비자 광학 및 반도체 제조 기술과 같은 많은 사업 부문에서 활발히 활동하고 있다. 
이 그룹은 여러 지원 및 사업 부서가 있고 이를 통합하는 상위 조직이 있다. 전체적으로 전 세계적으로 30,000명 이상의 직원을 보유하고 있다. 그들의 2018/19년 수익은 65억 유로였다. 그들은 50개국 이상에서 운영하고 있다. 

문제 설명
그들은 전체 디지털 포트폴리오를 단일 포털로 집계하는 고객 상호 작용 포털을 만들고 싶었다. 이 포털은 관련 비즈니스 그룹에 관계없이 모든 고객이 액세스할 수 있어야 한다. 

기능 매칭 (예: 일부 전용 계약이 있는 계측 고객에게만 제공되는 기계) 측면에서 사용 가능한 정보가 포털에 표시되어야 한다. 일반 고객에게는 이 기능이 보이면 안 된다. 

솔루션은 사용 및 개발 측면에서 확장 가능해야 한다. 이것은 애플리케이션의 다른 부분이 다른 기능 팀에 의해 개발될 수 있음을 의미한다. 이상적으로는 특정 사업부와 관련된 기능은 해당 사업부에서 직접 고용하거나 급여를 받는 사람들이 개발하는 것이다. 보안은 확장성만큼 중요한 것으로 간주한다.

일부 기능은 이미 개발했다. 예를 들어 한 팀은 사전에 전화나 팩스에 필요한 기능인 서비스 티켓 디지털화를 위한 솔루션을 만들었다. 이 팀은 Node.js 서비스가 포함된 리액트를 스택으로 선택했다. 
기존 기능을 담당하는 팀은 포털 프로젝트를 위한 새 팀을 구성하기 위해 재배정했다. 

팀 설정
핵심 팀은 기술 기반을 형성하고 다른 팀이 따라야 하는 프로세스를 수립하는 임무를 맡았다. 3개의 내부 소규모 팀은 전담 비즈니스 중심을 기반으로 구성했다. 고용된 외부 팀 뿐만 아니라 다른 내부 부서의 더 많은 팀도 수용 가능하다면 수용해야 한다. 

내부 개발자는 모두 타입 스크립트의 고수이거나 최소한 자바 스크립트 코드 작성에 능숙하다. 그들은 모두 리액트를 중급 이상으로 알고 있다. 일부 외부 개발자는 앵귤러 또는 기타 프레임워크에 더 익숙하다. 

가장 중요한 아키텍처 조합과 전용 테스트 팀을 통해 높은 수준의 생산 품질을 보장받을 수 있다. 중요한 것은 모든 기술적 핵심 결정을 내릴 수 있는 단일 솔루션 설계자가 있다는 것이다. 이것은 많은 논의가 필요 없이 일관성과 빠른 반응을 보장했다. 

솔루션 설계자는 솔루션을 개념화하고 개별 핵심 부분은 지식 공유를 보장하기 위해 여러 팀에 배포했다. 솔루션이 어떻게 생겼는지 한 번 보자.

솔루션
솔루션은 세 가지 원칙을 기반으로 했다.
•	패턴 라이브러리를 사용하여 최대한 재사용 가능하게 디자인 및 동작 경험 일관성을 유지한다.
•	GraphQL 게이트웨이(BFF)에서 동적으로 결합되는 재사용 가능한 서비스를 개발한다. 
•	팀이 테스트에서 생산에 이르기까지 소유권과 책임을 지도로 완전한 자율성을 부여한다. 

속도를 높이기 위해 일부 기존 애플리케이션은 즉시 마이크로 프론트엔드로 변환하지 않는다. 대신 이러한 응용 프로그램에 대한 링크를 포털에 배치한다. 애플리케이션은 일관된 경험을 제공하고 최소한 고객에게 마치 하나의 솔루션인것처럼 보이게 하기 위해 약간의 변경만 가했다. 

마이크로 프론트엔드 부분의 아키텍처 측면에서 사이트리스 UI패턴을 선택했다. 앱 셸은 번역 제공, 게이트웨이 액세스, 라우팅 및 백엔드에서 이벤트 전달을 담당한다. 다음 다이어그램이 필수 아키텍처를 보여준다.
 
그림 16.1 – 마이크로 프론트엔드 솔루션의 아키텍쳐

이전 다이어그램에 나와 있는 것처럼 아키텍처에 대해 주의해야 할 한가지는 각 API 요청이 포털의 백엔드를 통해 수행되어야 한다는 것이다. 이 아키텍처를 선택한 이유는 이 구성 요소가 쿠zl 기반 권한 부여에서 토큰 기반 권한 부여로 요청을 변환하기 때문이다. 백엔드에서 실행되는 서비스는 후자만 이해한다. 마이크로 프론트엔드를 개발할 때 이 변환은 포털 프론트엔드의 특수 빌드와 함께 시작되는 로컬 백엔드 프록시에서 수행한다. 여기에는 핫 모듈 재로딩 및 표준 개발 도구와 같은 것을 가능하게 하는 마이크로 프론트엔드가 포함된다. 

대부분의 마이크로 프론트엔드는 리액트를 사용하여 작성되었기 때문에 리액트 및 리액트 라우터 같은 일부 공통 라이브러리는 포털에서 공유 종속성으로 선언되었다. 또한 패턴 라이브러리의 구성 요소는 리액트를 사용하여 구현했다. 

패턴 라이브러리 프로젝트는 사전에 시작되었지만 실제로 포털 프로젝트 동안 약간의 추진력을 얻었다. 또한 많은 번거로움 없이 일부 디자인 개선 및 재설계를 가능하게 되었다. 패턴 라이브러리가 공유되었기 때문에 대부분의 마이크로 프론트엔드는 동일하게 유지되었지만 개선 사항은 새 버전의 앱 셸로 배포되었다. 

일부 마이크로 프론트엔드는 다른 프레임워크에서 작성되었다. 대부분이 패턴 라이브러리의 CSS 클래스를 사용했지만 하나의 마이크로 프론트엔드는 스타일링을 위한 사용자 정의 구현을 가졌다. 결과적으로 이 마이크로 프론트엔드의 유지 보수 노력은 스타일 조정이 배포 되었을 때 확실히 더 높아졌다. 
패턴 라이브러리에 대한 디자인은 개발 팀과 병행하여 전담 디자인 팀이 생성했다. 일부 화면은 패턴을 보여주고 길을 안내하기 위해 특별히 설계했지만 대부분의 화면은 각 팀의 제품 소유자가 제공한 요구 사항을 따르도록 개발자에게 맡겼다. 
각 팀에는 한 명의 제품 소유자가 있었는데 이 제품 소유자는 가장 중요한 제품 소유자의 관리를 받았다. UX 및 테스트를 위해 공유 리소스와 팀도 구성했다. 아키텍처도 중앙 집중화했다. 
4개월 만에 첫 프로젝트를 공개한 만큼 파급력도 상당할 것으로 예상했다. 

영향
포털 솔루션은 약속을 이행했으며 고객이 기존 및 새로운 디지털 서비스에 쉽게 접근할 수 있도록 했다. 그것은 또한 회사의 다른 팀들에게 API 우선 또는 모듈화에 대한 강한 강조와 같은 현대적 개념을 통합하고 디지털 프로젝트에 접근하는 방법을 위한 일종의 등대 역할을 했다. 
이전에는 고객이 정보를 얻기 위해 다양한 웹사이트와 URL을 사용해야 하는 기술의 조각보 카펫처럼 보였다. 이러한 URL은 시장, 사업부 및 기능에 따라 다르다. 이제 단일 포털이 이 역할을 맡는다. 이 역할은 공개 웹사이트에서 액세스할 수 있다. 
결과적으로 회사의 공개 웹 존재를 디지털 전략에 통합했다. 마이크로 프론트엔드 솔루션을 통해 해당 구성 요소를 공개 웹 사이트 렌더링을 담당하는 CMS와 같은 다른 웹 응용 프로그램에서 사용할 수 있다. 
포털은 지원되는 지역 및 비즈니스 부문의 고객만 액세스할 수 있다. 모든 사용자는 일반적으로 자동으로 승인을 받아야 한다. 승인되면 고객은 로그인하여 다음 스크린샷에 표시된 개인 대시보드 페이지로 이동할 수 있다.











앞의 스크린샷에서 인증된 사용자를 위한 포털의 랜딩 페이지를 볼 수 있다. 각 마이크로 프론트엔드는 대시보드내 부분들에 기여할 수 있다. 모든 메뉴는 확장 가능하며 다양한 마이크로 프론트엔드로 채운다. 예를 들어 헤더의 내 메시지 버튼은 메시지 마이크로 프론트엔드에서 가져온다. 사용자 정보 자체도 다른 마이크로 프론트엔드의 단편이다.

포털을 통해 원하는 모든 시장에 점진적으로 출시할 수 있다. 이를 통해 전략 채택과 유연하고 사용자 친화적인 기능 통합에 대한 신속한 대응이 가능하다. 이를 위한 또 다른 핵심 요소는 기존 작업에 영향을 주지 않고 새로운 사업부를 신속하게 온보딩 할 수 있는 자율 개발을 수행할 수 있는 능력이었다. 

대체로 이 솔루션은 분산 웹 애플리케이션에 대한 사전 경험이나 지식이 없어도 마이크로 프론트엔드 시스템을 사용한 디지털 변환이 대부분 사내 개발 중심 회사에서 작동할 수 있다는 것을 보여준다. 

비교를 위해 두 번째 사례 연구를 살펴보자.

관리 포털 솔루션
이 두 번째 사례 연구에서는 독일의 히든 챔피언이 새로운 디지털 플랫폼 관리를 위해 마이크로 프론트엔드를 도입한 방법을 볼 수 있다. 이 회사는 주로 건설 현장에서 고품질 도구 및 보호 천을 개발 및 유통하는 전문 기업이다. 

이 회사는 전 세계에 70개 이상의 자회사가 있는 단일 법인으로 구성되어 있다. 유럽에서만 이 그룹은 440개 이상의 사이트를 보유하고 있다. 

전반적으로 전 세계적으로 약 4,000명의 직원이 있다. 그들의 2018/19 수익은 거의 15억 유로였다. 그들은 50개국 이상에서 활동하고 있다.

문제 설명
이들은 풀 스택 팀이 새로운 디지털 서비스 플랫폼의 관리자에게 적절한 수준의 구성 가능성을 제공할 수 있는 관리 포털을 만들고 싶었다. 관리 작업이 수행되는 각 서비스에서 관리 포털을 분리하는 대신 동일한 팀이 책임져야한다. 
풀 스택 팀의 이점은 백엔드와 프론트엔드가 정렬되어 움직인다는 것이다. 따라서 백엔드에서 기능을 변경하면 동일한 팀이 그 자리에서 변경 사항을 UI에 맞출 수 있다. 

팀 설정
외부 핵심 팀은 잠재적인 기술 기반을 평가하고 제시하는 임무를 맡았다. 그런 다음 동일한 팀에서 첫 번째 마이크로 프론트엔드가 들어갈 수 있을 때까지 개선된 첫 번째 버전을 만들었다.

프로덕트 오너는 모두 내부 직원이었지만 대부분의 개발자와 기능 팀은 외부 회사에서 왔다. 이러한 조정은 각 팀이 가능한한 독립적으로 활동할 수 있도록 항상 회사 내부를 통해 이뤄졌다. 
중앙 테스트 팀을 이용 가능했다. 백엔드 API에는 계약 테스트가 필요했다.
솔루션이 어떻게 생겼는지 보자.

솔루션
이에 대한 솔루션은 이전 사례 연구와 매우 유사하지만 다음 영역에서 다르다. 
•	기존 패턴 라이브러리를 사용해야 했다. 프로젝트에 전담 디자이너가 없었다.
•	GraphQL 게이트웨이는 없었고 직접 대상이 되어야 하는 일부 마이크로서비스만 있었다.
•	팀은 더 이상 정렬되지 않는다. 시스템은 내부적으로만 개방된 시스템이다. 
이 프로젝트는 포털의 모습과 포털 개발 방식을 설명하는 개념 증명으로 시작되었다. 개념 증명의 범위는 관리 포털에서 가장 많이 찾는 기능 중 하나인 ID 관리를 포함하는 것이었다. 또한 여기에는 ID 추가 또는 수정과 같은 하위 기능이 포함되어 있어 ID를 읽는 것보다 더 많은 권한이 필요하다. 따라서 이것은 사용자의 실제 권한에 따라 다양한 마이크로 프론트엔드를 로드할 수 있는 확장 시스템을 설명할 기회를 제공했다. 

추진력을 얻기 위해 Piral 형태의 기존 프레임워크가 사용되었다. 이것은 포털의 프론트엔드를 에뮬레이터로 도입했으며, 마이크로 프론트엔드 개발자는 마이크로 프론트엔드를 게시하기 전에 디버그하고 볼 수 있다. 앱 셸 자체는 개념 증명을 구현하는 동일한 팀에서 유지 관리했다.

이전 사례 연구와의 또 다른 차이점은 CI/CD 프로세스이다. 개방형 시스템 상태를 수용하기 위해 모든 팀은 자체 CI/CD 프로세스를 설정할 수 있다. 궁극적으로 이런 모든 파이프라인은 내부 npm 레지스트리에 불과한 공통 스테이징 시스템으로 이어진다. 레지스트리의 변경 사항은 플랫폼 소유자가 제어하는 공통 CI/CD 시스템에 의해 선택된다. 프로덕션 및 사전 프로덕션 시스템의 경우 게시할 마이크로 프론트엔드와 시기를 결정한다. 

이러한 배포 파이프라인 구조를 선택한 이유 중 하나는 마이크로서비스가 동일한 플랫폼에 게시되는 방식을 모방하기 위함이었다. 이런 식으로 다른 풀스택 팀은 새로운 것을 배울 필요가 없었다. 결국 도커 이미지로 패키징된 마이크로 서비스를 배포할 때 알고 있던 동일한 패턴이 npm 패키징된 마이크로 프론트엔드로 복사되었다. 

백엔드와의 유사성은 다른 선택에도 반영되었다. 예를 들어 시스템을 안정적으로 유지하면서 적절한 격리를 보장하기 위해 계약 기반 테스트를 도입했다. 동일한 시스템을 프론트엔드에도 활용할 수 있으며 주로 API 호출을 안정적으로 유지하도록 하기 위해서이다. 이는 포털의 API에 변화를 가져오는 것을 방지하기 위해 수행했는데 이는 이전에 작동하던 마이크로 프론트엔드를 파괴할 수 있다.  

솔루션의 아키텍처는 다음 다이어그램에 요약되어 있다. 이전 사례 연구와 마찬가지로 이 솔루션은 단일 설계자가 여러 설계자에게 보고함으로써 도출되었다. 이 경우 설계자 그룹은 PoC(개념 증명)을 사용하여 프로젝트를 어떻게 계속 진행할지 결정한다. 

 
그림 16.3 – 마이크로 프론트엔드 솔루션의 아키텍처
앞의 아키텍처 다이어그램에서 앱 쉘의 책임 중 하나가 고급 검색 기능을 사용자에게 노출하는 것임을 알 수 있다. 검색 기능은 각 마이크로 프론트엔드가 일부 추가 검색 공급자를 제공할 수 있는 분산 접근 방식을 사용했다. 글로벌 검색이 시작되면 사용 가능한 모든 공급자가 검색 결과에 기여하도록 호출한다.

검색 기능은 다음과 같은 세 가지 모드로 작동한다.
•	사용 가능한 모든 공급자를 호출하고 결과를 집계하는 글로벌 검색 요청
•	현재 페이지와 연결된 공급자만 호출하는 지역 검색 요청
•	표 형식 정보를 표시하는 모든 페이지에서 사용할 수 있는 지역 결과 필터링

결과적으로 관리 포털의 검색 기능은 유능하고 강력했다. 그것은 사용자에게 이용 가능한 모든 서비스들의 정보에 대한 빠른 접근을 제공했다. 

관리 포털의 유연성과 확장성은 디지털 플랫폼에도 상당한 영향을 미쳤다.

영향
관리 포털은 회사가 아래와 같이 두 가지를 달성하는데 도움을 줬다.
•	프로덕트 오너와 관리자가 플랫폼에 직접 참여할 수 있도록 지원한다.
•	관리 기능을 제공하는 책임을 여러 기능 팀에 분산시킨다. 

이 해결책은 이런 기대를 충족시켰다고 해도 과언이 아니다. PoC(개념 증명)은 이미 긍정적으로 받아들여졌기 때문에 설계자 그룹은 고객 포털에도 동일한 접근 방식을 도입하기로 결정했다. 나중에 공공 웹사이트의 일부도 변경했다. 

표준 웹 사이트 및 기타 구축된 웹 사이트를 위해 새로운 마이크로 프론트엔드 피드를 도입했다. 이 피드의 마이크로 프론트엔드는 공유된 의존성을 사용하지 않았으며 특정 공통적인 문제만 해결했다. 이러한 문제들 중 하나는 법적으로 필요한 쿠키 동의의 텍스트, 디자인, 행위를 통일 시킨 공동 쿠키 동의 양식을 제시하는 것이었다. 하나의 스크립트로 회사의 모든 웹사이트는 이제 동의 대화 상자 뿐만 아니라 다른 일반적인 기능까지 포함할 수 있다. 

다음 사진에는 관리 포털의 초기 버전이 나와 있다.
 
그림 16.4 – 관리 포털의 신원 정보 개요 페이지
앞의 사진에서 페이지가 관리하는 ID에 대한 개요를 제공하는 것을 확인할 수 있다. 이 페이지는 ID 마이크로 프론트엔드가 제공한다. 
ID 추가 버튼과 대부분의 작업 버튼은 “신원 생성” 또는 “신원 편집”마이크로 프론트엔드와 같은 다른 마이크로 프론트엔드에서 가져온 확장 기능이다. 이러한 마이크로 프론트엔드는 필요한 백엔드 권한이 있는 사용자에게만 프로비저닝한다. 

Piral을 기초로 사용하는 것은 기존 생태계와 문서를 활용하여 굉장히 유용했다. 이를 통해 개발은 문서와 실제 구현의 도메인별 세부사항에 초점을 맞출 수 있었다. 또한 새로운 팀원들의 온보딩 속도를 매우 빠르게 만들었다. 

약속한 대로, 서로 다른 팀들이 제공한 기능의 소유권을 가져갔다. 백엔드에서 무언가 바꾼다면 프론트엔드에 그 변화를 반영할 수 있는 힘과 책임을 가졌다. 포털 사용자는 전체 솔루션이 항상 일관성 있게 작동하는 것처럼 보였기 때문에 이런 변경은 아무런 영향을 미치지 않았다. 

마지막으로 유연한 웹 도구 제작에 관한 세 번째 사례 연구를 살펴보자.

의료 관리 솔루션
OpenMRS는 전자 의료 기록(EMR) 소프트웨어를 만드는 데 도움을 준 협업 오픈 소스 프로젝트이다. 2014년 5월에 처음 출시했으며 원래 자바로 작성했다. 

OpenMRS, Inc.는 모든 프로젝트 관련 지적 재산의 소유자이자 소프트웨어의 공용 라이선스를 관리하는 등록된 비영리회사이다. 기업은 또한 법적 문제와 재무적 문제에서도 프로젝트를 대표한다. 

전체적으로 이 프로젝트에는 약 200명의 영구 기여자들이 12개의 팀으로 나눠져 있다. 개발은 대부분 깃허브에서 이뤄지며 프로젝트 관리는 지라에서 이뤄진다. 

문제 설명
이 프로젝트의 생태계는 거대하다. 백엔드가 자바 모듈의 형태로 확장될 수 있는 메커니즘을 제공하는 반면 프론트엔드는 종종 필요악으로 간주되어 재실행되거나 적절한 대안으로 대체되었다. 

여기서 한 가지 문제는 많은 배포 생성자들이 SPA 경험을 하고 싶어한다는 점이다. 몇몇은 Angular를 프레임워크로 선택한 반면 다른 이들은 리액트를 선택했다. 심지어 다른 형태들도 있다. 마이크로 프론트엔드 솔루션은 백엔드에서 유사한 확장성 사례와 함께 최신 SPA 환경을 제공함으로써 이 차이를 좁힐 수 있도록 지원한다.

고려해야 할 또 다른 측면은 풍부한 구성 가능성이다. 시스템은 추가적인 기능을 강화할 수 있을 만큼 확장 가능해야 하지만 외관부터 제공된 기능에 이르기까지 모든 것을 조정할 수 있을 만큼 충분히 구성 가능해야 한다. 

팀 설정
각 배포판마다 자체 팀이 있을 수 있지만 핵심 팀은 “마이크로 프론트엔드 스쿼드”라고 부른다. 이 팀에서는 모든 기본적인 기술적 결정을 의견 요청서(RFC, Request for Comments)의 형태로 논의한다. 이 팀은 지리적으로 분산되어 근무한다. 많은 개발자들이 아프리카에서 일하며 일부는 미국에서 다른 일부는 유럽과 인도에서 일한다. 

지시된 일의 대부분은 JIRA를 통해 조직한다. 일부 기여자들은 다른 보건 단체에서 급여를 받는 반면 다른 기여자들은 더 큰 기금이나 오픈 소스 보조금의 일부를 통해 기여한다. 또 다른 일부는 그들의 여가 시간을 활용해 기여한다.

매주 모든 기여자들이 가상 dev로 모인다. 이 회의에서는 마이크로 프론트엔드 프로젝트의 비전과 방향을 논의한다. 최근 작품이나 곧 출간될 작품에 대한 데모와 발표도 있다.

마이크로 프론트엔드 팀에는 한 명의 직속 설계자와 여러 명의 리드 개발자가 있으며, 각기 다른 표준 시간대 및 다른 조직의 주요 개발자로 구성되어 있다. 팀이 중앙 집중화된 동안 프로덕트 오너는 분산된다. QA 테스터와 같은 기타 관련 리소스는 OpenMRS 프로젝트 내에서 사용할 수 있다. 이것들은 다른 팀들을 통해 공유된다.

그 팀에서는 거의 모든 개발자가 다른 아이템으로 작업한다. 종종 이 아이템들은 다른 마이크로 프론트엔드에도 있었는데 이를 통해 개발자들이 서로 책임을 져야 하는 영역에 대해 침범하지 않는 다는 이점을 가질 수 있었다. 그러나 대부분의 개발자들이 타입스크립트에 대한 지식이 거의 없거나 리액트를 사용하지 않았기 때문에 약간의 교육이 필요했다. 

그 해결책이 어떻게 생겼는지 보자.

솔루션
이 솔루션은 다음 사항을 고려해야 한다.
•	프레임워크 또는 라이브러리에 대한 제한 없음
•	모든 것이 구성 가능해야 함
•	간편한 배포 및 설정

가장 중요한 점은 API에서 SPA를 분리하는 것이었다. 마찬가지로 마이크로 프론트엔드는 배포 방식에 있어 유연성이 부여되는 방식으로 설정했다. 예를 들어 SPA는 전용 모듈을 통해 OpenMRS 백엔드에서 직접 서비스될 수 있지만 nginx와 같은 전용 웹 서버에서도 서비스할 수 있다. 마찬가지로 마이크로 프론트엔드 자산은 표준 자산과 함께 내장될 수 있지만 다른 곳에서 호스트할 수도 있다.

이전의 두 사례 연구와 달리 이 솔루션은 마이크로 프론트엔드를 동적으로 프로비저닝하지 않는다. 대신 정적인 가져오기 맵을 사용한다. 물론 가져오기 맵은 수작업으로 변경할 수 있다. 마이크로 프론트엔드는 SystemJS에 의해 ESM 형식으로 롤 아웃한다. 

솔루션의 아키텍처는 다음 다이어그램에 설명되어 있다.
 
그림 16.5 – 마이크로 프론트엔드 솔루션의 아키텍처

OpenMRS는 일반적으로 다양한 배포 형태로 출시한다. 그러나 “기본” 배포로 볼 수 있는 참조 응용 프로그램도 있다. 두 경우 모두 배포 생성자는 배포 매니페스트를 통해 프론트엔드에 필요한 모든 부품을 조립할 수 있다. 이 개념은 앞의 도표와 같다. 매니페스트에 배포에 포함되어야 하는 앱 쉘 버전과 마이크로 프론트 버전을 정의한다. 

모든 리소스는 공유 npm 레지스트리에 릴리스되었거나 로컬로 사용할 수 있는 npm 패키지에서 가져온다. 이를 통해 커뮤니티의 모든 사용자가 자신의 마이크로 프론트엔드를 독립적으로 게시할 수 있으며 마이크로 프론트엔드 공유를 장려한다. 

모든 것을 구성할 수 있도록 프론트엔드 구성 시스템을 도입했다. 시스템 관리자는 기본 구성을 재정의하는 JSON 파일로 이어지는 사용자 지정 URL을 지정할 수 있다. 제공된 사용자 지정 구성을 정의한 구성 스키마와 비교하고 확인하여 일관성을 보장한다. 구성 옵션을 제공하는 각 마이크로 프론트엔드는 구성 스키마를 선언해야 한다.
마이크로 프론트엔드는 프레임워크 독립적인 라우팅을 위해 단일 SPA를 활용하는 앱 쉘에 이해 조정한다. 확장 슬롯 메커니즘은 단일 공간 소포 위에 구축했다. 이는 기존 기술을 기존 생태계와 함께 사용하는 동시에 유연성을 유지하고 맞춤형 요구사항을 충족시키는 절충안이었다. 
처음에 앱 쉘은 거의 독점적으로 단일 스파 루트 구성과 가져오기 맵으로 구성했다. 모든 여러 관심사를 확인한 후 일부 기능이 코어로 이동했다. 또한 서비스 작업자와 같은 일부 PWA 펀더멘털을 앱 쉘과 통합하여 오프라인 사용을 허용했다. 리액트 및 RxJS와 같은 모든 공유 종속성은 즉시 애플리케이션에 번들로 제공한다. 가져오기 맵에는 마이크로 프론트엔드만 표시한다.
설계에 관한 한 IBM의 Carbon Design이라는 기존 솔루션을 선택했다. 이 선택의 장점은 다른 프레임워크와 함께 사용할 수 있으며 기능이 완전하다는 것이었다. 전체 패턴 라이브러리이며 여러 화면에 대한 안내를 제공한다. 그것은 또한 디자인의 비전과 프로젝트의 아이디어와 많이 일치하는 전문적인 디자인을 가지고 있다. 
그러나 Carbon Design이 구성 요소의 기초가 되었음에도 불구하고 디자이너는 화면을 만들고 사용자 흐름을 만드는 것을 도왔다. 그런 다음 이러한 흐름을 기존 사용자와 함께 테스트하여 유용성을 검증하고 여전히 누락된 것이 무엇인지 확인했다.
새롭게 설계된 완전히 동적인 모듈식 애플리케이션의 영향은 무엇이었을까? 이 부분은 다음 부분에서 살펴보겠다. 

영향
늘 그렇듯 기존 솔루션을 대체하려는 새로운 솔루션의 시작은 험난하다. 어떤 사람들은 새로운 해결책을 간절히 기다리고 있지만 대부분의 사람들은 그들의 사용 패턴을 바꾸고 싶어하지 않는다. 또한 그것을 기다리는 사람들은 보통 비현실적으로 높은 기대를 가지고 있는 사람들이다. 

새로운 OpenMRS 프론트엔드 애플리케이션의 경우 커뮤니티의 반응이 전반적으로 좋았다. 클래식 UI가 비활성화되지 않았고 여전히 기본 배포의 일부였기 때문에 모든 사용자가 사용할 응용 프로그램을 선택할 수 있었다. 클래식 UI의 일부 덜 사용자 지향적인 부분이 초기 배포에 포팅되지 않았기 때문에 이 또한 매우 중요했다. 

어느 쪽이든 오프라인 역량과 프레임워크 독립성이 가장 큰 성과다. 오프라인 기능을 통해 사용자는 서버에 연결되지 않은 상태에서 환자를 동기화하고 돌볼 수 있다. 프레임워크 독립성을 통해 사용자는 자신의 스택을 사용하여 다른 조직에서 개발한 조각을 포함할 수 있다. 예를 들어 표준 폼 엔진은 앵귤러를 사용한 팀에 의해 렌더링을 구현했다. 

다음 사진은 응용 프로그램의 가장 중요한 화면 중 하나를 보여준다.
 
그림 16.6 – 공개된 바이탈 및 생체 정보를 가진 환자 요약 페이지

앞의 사진에서는 환자 요약 페이지를 표시한다. 이것은 환자의 개요를 얻을 수 있는 중앙 대시보드이다. 요약 페이지는 구성 및 사용자 지정이 가능한 많은 대시보드 중 하나일뿐이다. 모든 대시보드는 “환자 차트”라는 마이크로 프론트엔드에서 관리한다. “환자 배너”와 같은 다양한 마이크로 프론트엔드는 관련 환자 정보에 대한 일부 UI 조각을 제공하는 것 혹은 “면역화” 대시보드와 같은 특수한 대시보드에 기여한다. 

이 접근 방식의 유연성은 상당히 복잡하고 광범위한 구성의 단점을 수반하기 때문에 관리자와 구현자를 위한 마이크로 프론트엔드를 만들었다. 이 마이크로 프론트엔드를 통해 현재 애플리케이션을 검사하고 수정한 다음 결과 구성을 재사용하기 위해 저장할 수 있다. 

전체적으로 이 솔루션은 사용 가능한 솔루션을 통합했다. 각 배포판이 자체 프론트엔드를 구축하도록 하는 대신 이제는 단일 애플리케이션이 존재한다.

 
요약
이 장에서는 마이크로 프론트엔드 솔루션을 도입하는 문제에 다른 사람들이 어떻게 접근하는지 배웠다. 기술적 의사결정이 어떻게 이뤄지고 마이크로 프론트엔드 솔루션이 어떤 모습이어야 하는지에 있어 비즈니스 요인은 항상 중요한 역할을 한다. 이와 대조적으로 모듈화를 강화함으로써 팀에게 힘을 실어주는 것은 대개 개발 경험의 주요 결과 중 하나이다. 

마이크로 프론트엔드를 사용하면 긴 릴리스 주기 및 관련 없는 기능이 구현될 때까지 기다릴 필요 없이 기업의 출시 기간을 단축할 수 있다. 도메인이 제대로 분해된다면 모든 모듈은 이치에 맞을 뿐 아니라 진정한 자립을 할 수 있다. 확장 구성 요소와 같은 패턴을 사용하여 UI를 동적으로 구성할 수 있으며 항상 사용 가능한 기능에 맞게 완벽하게 조정할 수 있다. 

마이크로 프론트엔드는 조직적인 문제만큼이나 기술적인 과제이다. 이해당사자와의 소통은 물론 개별 팀 간, 팀 내 다른 역할도 바꿔야한다. 변경 관리, 견고한 거버넌스 모델, 의존성 관리 및 설계 철학에 대한 필요성에 대해서도 읽었다. 이러한 모든 측면이 즉시 필요하지만 효과적으로 다루려면 몇 가지 솔루션이 필요하다. 대부분의 경우 실용적인 접근법을 따르는 것으로 충분하다. 완벽한 해결책을 찾기 위해 귀중한 시간과 노력을 낭비하지 마라.

에필로그
여기가 바로 마이크로 프론트엔드로의 여정이 끝나는 곳이다. 이제 이 책에 나와 있는 기술, 팁, 요령 및 실습을 사용하여 여러분의 지식을 활용하고 뛰어난 웹 애플리케이션을 구축할 차례이다. 중요한 통찰력을 얻고 구성 요소를 분리하는 방법에 대해 재밌게 읽었길 바란다. 독립 모듈 생성은 필요한 사전 작업이 수행되는 경우에만 작동한다. 도메인 분해가 잘 되는 것은 항상 어렵기 때문에 첫 번째 시도에 제대로 작동하기 위해 추가적으로 정교함이 필요하다는 것을 잊지마라. 

또한 마이크로 프론트엔드 솔루션이 정말 필요한지 평가하는 것도 잊지마라. 단순 모놀리스는 효과와 성능 면에서 이길 수 없다. 마이크로 프론트엔드를 선택하는 것은 기술적인 문제가 아니라 실제 비즈니스 요구에 대한 것이어야 한다. 일반적으로 마이크로 프론트엔드 또는 특정 아키텍처 스타일에 찬성하거나 반대하는 결정을 내리기 전에 의사소통을 개방하고 모든 사람의 말을 경청하도록 노력하라.

행운을 빈다!
